import { __decorate, __metadata, __rest } from "tslib";
import { Component, ContentChildren, Input, QueryList } from "@angular/core";
import * as Éµngcc0 from '@angular/core';
var AgGridColumn = /** @class */ (function () {
    function AgGridColumn() {
        // inputs - pretty much most of ColDef, with the exception of template, templateUrl and internal only properties
        // @START@
        this.filterFramework = undefined;
        this.filterParams = undefined;
        this.floatingFilterComponent = undefined;
        this.floatingFilterComponentParams = undefined;
        this.floatingFilterComponentFramework = undefined;
        this.filter = undefined;
        /** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name.     */
        this.headerName = undefined;
        /** Function or expression. Gets the value for display in the header.     */
        this.headerValueGetter = undefined;
        /** Whether to show the column when the group is open / closed.     */
        /** Tooltip for the column header     */
        this.headerTooltip = undefined;
        /** CSS class to use for the header cell. Can be a string, array of strings, or function.     */
        this.headerClass = undefined;
        /** Suppress the grid taking action for the relevant keyboard event when a header is focused.     */
        this.suppressHeaderKeyboardEvent = undefined;
        /** Whether to show the column when the group is open / closed.     */
        this.columnGroupShow = undefined;
        /** CSS class to use for the tool panel cell. Can be a string, array of strings, or function.     */
        this.toolPanelClass = undefined;
        /** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel.     */
        this.suppressColumnsToolPanel = undefined;
        /** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel.     */
        this.suppressFiltersToolPanel = undefined;
        this.tooltipComponent = undefined;
        this.tooltipComponentFramework = undefined;
        this.tooltipComponentParams = undefined;
        /** A list containing a mix of columns and column groups.     */
        this.children = undefined;
        /** The unique ID to give the column. This is optional. If missing, a unique ID will be generated. This ID is used to identify the column group in the column API.     */
        this.groupId = undefined;
        /** Set to `true` if this group should be opened by default.     */
        this.openByDefault = undefined;
        /** Set to `true` to keep columns in this group beside each other in the grid. Moving the columns outside of the group (and hence breaking the group) is not allowed.     */
        this.marryChildren = undefined;
        /** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used*     */
        this.headerGroupComponent = undefined;
        /** The custom header group component to be used for rendering the component header in the hosting framework (ie: Angular/React/VueJs). If none specified the default AG Grid is used*     */
        this.headerGroupComponentFramework = undefined;
        /** The params used to configure the header group component.     *     */
        this.headerGroupComponentParams = undefined;
        /** The unique ID to give the column. This is optional. If missing, the ID will default to the field.
         * If both field and colId are missing, a unique ID will be generated.
         * This ID is used to identify the column in the API for sorting, filtering etc.     */
        this.colId = undefined;
        /** The field of the row to get the cells data from     */
        this.field = undefined;
        /** A comma separated string or array of strings containing `ColumnType` keys which can be used as a template for a column.
         * This helps to reduce duplication of properties when you have a lot of common column properties.     */
        this.type = undefined;
        /** Function or expression. Gets the value from your data for display.     */
        this.valueGetter = undefined;
        /** A function or expression to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering.     */
        this.valueFormatter = undefined;
        /** Provided a reference data map to be used to map column values to their respective value from the map.     */
        this.refData = undefined;
        /** Function to return a string key for a value.
         * This string is used for grouping, Set filtering, and searching within cell editor dropdowns.
         * When filtering and searching the string is exposed to the user, so make sure to return a human-readable value.     */
        this.keyCreator = undefined;
        /** Custom comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed.
         * By default the grid uses `===` is used which should work for most use cases.     */
        this.equals = undefined;
        /** The field of the tooltip to apply to the cell.     */
        this.tooltipField = undefined;
        /** Callback that should return the string used for a tooltip, `tooltipField` takes precedence if set.     */
        this.tooltipValueGetter = undefined;
        /** `boolean` or `Function`. Set to `true` (or return `true` from function) to render a selection checkbox in the column.     */
        this.checkboxSelection = undefined;
        /** Icons to use inside the column instead of the grid's default icons. Leave undefined to use defaults.     */
        this.icons = undefined;
        /** Set to `true` if this column is not navigable (i.e. cannot be tabbed into), otherwise `false`.
         * Can also be a callback function to have different rows navigable.     */
        this.suppressNavigable = undefined;
        /** Allows the user to suppress certain keyboard events in the grid cell     */
        this.suppressKeyboardEvent = undefined;
        /** Pasting is on by default as long as cells are editable (non-editable cells cannot be modified, even with a paste operation).
         * Set to `true` turn paste operations off.     */
        this.suppressPaste = undefined;
        /** Set to true to prevent the fillHandle from being rendered in any cell that belongs to this column     */
        this.suppressFillHandle = undefined;
        /** Set to `true` for this column to be hidden.     */
        this.hide = undefined;
        /** Same as 'hide', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialHide = undefined;
        /** Set to `true` to block making column visible / hidden via the UI (API will still work).     */
        this.lockVisible = undefined;
        /** Set to `true` to always have this column displayed first.     */
        this.lockPosition = undefined;
        /** Set to `true` if you do not want this column to be movable via dragging.     */
        this.suppressMovable = undefined;
        /** Set to `true` if this column is editable, otherwise `false`. Can also be a function to have different rows editable.     */
        this.editable = undefined;
        /** Function or expression. Sets the value into your data for saving. Return `true` if the data changed.     */
        this.valueSetter = undefined;
        /** Function or expression. Parses the value for saving.     */
        this.valueParser = undefined;
        /** A `cellEditor` to use for this column.     */
        this.cellEditor = undefined;
        /** Framework `cellEditor` to use for this column.     */
        this.cellEditorFramework = undefined;
        /** Params to be passed to the cell editor component.     */
        this.cellEditorParams = undefined;
        /** Callback to select which cell editor to be used for a given row within the same column.     */
        this.cellEditorSelector = undefined;
        /** Set to `true` to have cells under this column enter edit mode after single click.     */
        this.singleClickEdit = undefined;
        /** @deprecated use `valueSetter` instead
         */
        this.newValueHandler = undefined;
        /** Set to `true`, to have the cell editor appear in a popup.     */
        this.cellEditorPopup = undefined;
        /** Set the position for the popup cell editor. Possible values are
         *   - `over` Popup will be positioned over the cell
         *   - `under` Popup will be positioned below the cell leaving the cell value visible.
         *
         * The default is `over`.     */
        this.cellEditorPopupPosition = undefined;
        /** Callback for after the value of a cell has changed, either due to editing or the application calling `api.setValue()`.     */
        this.onCellValueChanged = undefined;
        /** Callback called when a cell is clicked.     */
        this.onCellClicked = undefined;
        /** Callback called when a cell is double clicked.     */
        this.onCellDoubleClicked = undefined;
        /** Callback called when a cell is right clicked.     */
        this.onCellContextMenu = undefined;
        /** A function to tell the grid what quick filter text to use for this column if you don't want to use the default (which is calling `toString` on the value).     */
        this.getQuickFilterText = undefined;
        /** Function or expression. Gets the value for filtering purposes.     */
        this.filterValueGetter = undefined;
        /** Whether to display a floating filter for this column.     */
        this.floatingFilter = undefined;
        /** The custom header component to be used for rendering the component header. If none specified the default AG Grid header component is used.     *     */
        this.headerComponent = undefined;
        /** The custom header component to be used for rendering the component header in the hosting framework (ie: Angular/React/VueJs). If none specified the default AG Grid header component is used*     */
        this.headerComponentFramework = undefined;
        /** The parameters to be passed to the header component.     *     */
        this.headerComponentParams = undefined;
        /** Set to an array containing zero, one or many of the following options: `'filterMenuTab' | 'generalMenuTab' | 'columnsMenuTab'`.
         * This is used to figure out which menu tabs are present and in which order the tabs are shown.     */
        this.menuTabs = undefined;
        /** Params used to change the behaviour and appearance of the Columns Menu tab.     */
        this.columnsMenuParams = undefined;
        /** Set to `true` if no menu should be shown for this column header.     */
        this.suppressMenu = undefined;
        /** If `true` or the callback returns `true`, a 'select all' checkbox will be put into the header.     */
        this.headerCheckboxSelection = undefined;
        /** If `true`, the header checkbox selection will only select filtered items.     */
        this.headerCheckboxSelectionFilteredOnly = undefined;
        /** Defines the chart data type that should be used for a column.     */
        this.chartDataType = undefined;
        /** Pin a column to one side: `right` or `left`. A value of `true` is converted to `'left'`.     */
        this.pinned = undefined;
        /** Same as 'pinned', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialPinned = undefined;
        /** Set to true to block the user pinning the column, the column can only be pinned via definitions or API     */
        this.lockPinned = undefined;
        /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
         */
        this.pinnedRowCellRenderer = undefined;
        /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
         */
        this.pinnedRowCellRendererFramework = undefined;
        /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
         */
        this.pinnedRowCellRendererParams = undefined;
        /** @deprecated Use valueFormatter for pinned rows, and check params.node.rowPinned.
         */
        this.pinnedRowValueFormatter = undefined;
        /** Set to true to pivot by this column.     */
        this.pivot = undefined;
        /** Same as 'pivot', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialPivot = undefined;
        /** Set this in columns you want to pivot by.
         * If only pivoting by one column, set this to any number (e.g. `0`).
         * If pivoting by multiple columns, set this to where you want this column to be in the order of pivots (e.g. `0` for first, `1` for second, and so on).     */
        this.pivotIndex = undefined;
        /** Same as 'pivotIndex', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialPivotIndex = undefined;
        /** Comparator to use when ordering the pivot columns, when this column is used to pivot on.
         * The values will always be strings, as the pivot service uses strings as keys for the pivot groups.     */
        this.pivotComparator = undefined;
        /** Set to `true` if you want to be able to pivot by this column via the GUI. This will not block the API or properties being used to achieve pivot.     */
        this.enablePivot = undefined;
        /** An object of css values / or function returning an object of css values for a particular cell.     */
        this.cellStyle = undefined;
        /** Class to use for the cell. Can be string, array of strings, or function that returns a string or array of strings.     */
        this.cellClass = undefined;
        /** Rules which can be applied to include certain CSS classes.     */
        this.cellClassRules = undefined;
        /** A `cellRenderer` to use for this column.     */
        this.cellRenderer = undefined;
        /** Framework `cellRenderer` to use for this column.     */
        this.cellRendererFramework = undefined;
        /** Params to be passed to the cell renderer component.     */
        this.cellRendererParams = undefined;
        /** Callback to select which cell renderer to be used for a given row within the same column.     */
        this.cellRendererSelector = undefined;
        /** Set to `true` to have the grid calculate the height of a row based on contents of this column.     */
        this.autoHeight = undefined;
        /** Set to `true` to have the text wrap inside the cell - typically used with `autoHeight`.     */
        this.wrapText = undefined;
        /** Set to `true` to flash a cell when it's refreshed.     */
        this.enableCellChangeFlash = undefined;
        /** Set to `true` to prevent this column from flashing on changes. Only applicable if cell flashing is turned on for the grid.     */
        this.suppressCellFlash = undefined;
        /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow row dragging.     */
        this.rowDrag = undefined;
        /** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.
         * If this callback is not set, the current cell value will be used.     */
        this.rowDragText = undefined;
        /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow dragging for native drag and drop.     */
        this.dndSource = undefined;
        /** Function to allow custom drag functionality for native drag and drop.     */
        this.dndSourceOnRowDrag = undefined;
        /** Set to `true` to row group by this column.     */
        this.rowGroup = undefined;
        /** Same as 'rowGroup', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialRowGroup = undefined;
        /** Set this in columns you want to group by.
         * If only grouping by one column, set this to any number (e.g. `0`).
         * If grouping by multiple columns, set this to where you want this column to be in the group (e.g. `0` for first, `1` for second, and so on).     */
        this.rowGroupIndex = undefined;
        /** Same as 'rowGroupIndex', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialRowGroupIndex = undefined;
        /** Set to `true` if you want to be able to row group by this column via the GUI.
         * This will not block the API or properties being used to achieve row grouping.     */
        this.enableRowGroup = undefined;
        /** Set to `true` if you want to be able to aggregate by this column via the GUI.
         * This will not block the API or properties being used to achieve aggregation.     */
        this.enableValue = undefined;
        /** Name of function to use for aggregation. You can also provide your own agg function.     */
        this.aggFunc = undefined;
        /** Same as 'aggFunc', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialAggFunc = undefined;
        /** Aggregation functions allowed on this column e.g. `['sum', 'avg']`.
         * If missing, all installed functions are allowed.
         * This will only restrict what the GUI allows a user to select, it does not impact when you set a function via the API.     */
        this.allowedAggFuncs = undefined;
        /** Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group.     */
        this.showRowGroup = undefined;
        /** Set to `true` to allow sorting on this column.     */
        this.sortable = undefined;
        /** If sorting by default, set it here. Set to 'asc' or 'desc'.     */
        this.sort = undefined;
        /** Same as `sort`, except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialSort = undefined;
        /** If sorting more than one column by default, specifies order in which the sorting should be applied.     */
        this.sortIndex = undefined;
        /** Same as 'sortIndex', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialSortIndex = undefined;
        /** Array defining the order in which sorting occurs (if sorting is enabled). An array with any of the following in any order ['asc','desc',null]     */
        this.sortingOrder = undefined;
        /** Comparator function for custom sorting.     */
        this.comparator = undefined;
        /** Set to `true` if you want the unsorted icon to be shown when no sort is applied to this column.     */
        this.unSortIcon = undefined;
        /** @deprecated since v24 - use sortIndex instead
         */
        this.sortedAt = undefined;
        /** By default, each cell will take up the width of one column. You can change this behaviour to allow cells to span multiple columns.     */
        this.colSpan = undefined;
        /** By default, each cell will take up the height of one row. You can change this behaviour to allow cells to span multiple rows.     */
        this.rowSpan = undefined;
        /** Initial width in pixels for the cell.     */
        this.width = undefined;
        /** Same as 'width', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialWidth = undefined;
        /** Minimum width in pixels for the cell.     */
        this.minWidth = undefined;
        /** Maximum width in pixels for the cell.     */
        this.maxWidth = undefined;
        /** Used instead of `width` when the goal is to fill the remaining empty space of the grid.     */
        this.flex = undefined;
        /** Same as 'flex', except only applied when creating a new column. Not applied when updating column definitions.     */
        this.initialFlex = undefined;
        /** Set to `true` to allow this column should be resized.     */
        this.resizable = undefined;
        /** Set to `true` if you want this column's width to be fixed during 'size to fit' operations.     */
        this.suppressSizeToFit = undefined;
        /** Set to `true` if you do not want this column to be auto-resizable by double clicking it's edge.     */
        this.suppressAutoSize = undefined;
        // @END@
    }
    AgGridColumn_1 = AgGridColumn;
    AgGridColumn.prototype.hasChildColumns = function () {
        if (this.childColumns && this.childColumns.length > 0) {
            // necessary because of https://github.com/angular/angular/issues/10098
            return !(this.childColumns.length === 1 && this.childColumns.first === this);
        }
        return false;
    };
    AgGridColumn.prototype.toColDef = function () {
        var colDef = this.createColDefFromGridColumn(this);
        if (this.hasChildColumns()) {
            colDef["children"] = this.getChildColDefs(this.childColumns);
        }
        return colDef;
    };
    AgGridColumn.prototype.getChildColDefs = function (childColumns) {
        return childColumns
            // necessary because of https://github.com/angular/angular/issues/10098
            .filter(function (column) { return !column.hasChildColumns(); })
            .map(function (column) {
            return column.toColDef();
        });
    };
    AgGridColumn.prototype.createColDefFromGridColumn = function (from) {
        var childColumns = from.childColumns, colDef = __rest(from, ["childColumns"]);
        return colDef;
    };
    var AgGridColumn_1;
    __decorate([
        ContentChildren(AgGridColumn_1),
        __metadata("design:type", QueryList)
    ], AgGridColumn.prototype, "childColumns", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "filterFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "filterParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "floatingFilterComponent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "floatingFilterComponentParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "floatingFilterComponentFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "filter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "headerName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerValueGetter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "headerTooltip", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "suppressHeaderKeyboardEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "columnGroupShow", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "toolPanelClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressColumnsToolPanel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressFiltersToolPanel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "tooltipComponent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "tooltipComponentFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "tooltipComponentParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AgGridColumn.prototype, "children", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "groupId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "openByDefault", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "marryChildren", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerGroupComponent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerGroupComponentFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerGroupComponentParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "colId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "field", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "valueGetter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "valueFormatter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "refData", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "keyCreator", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "equals", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "tooltipField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "tooltipValueGetter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "checkboxSelection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "icons", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "suppressNavigable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "suppressKeyboardEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "suppressPaste", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressFillHandle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "hide", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "initialHide", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "lockVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "lockPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressMovable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "editable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "valueSetter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "valueParser", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellEditor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellEditorFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellEditorParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "cellEditorSelector", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "singleClickEdit", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "newValueHandler", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "cellEditorPopup", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "cellEditorPopupPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "onCellValueChanged", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "onCellClicked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "onCellDoubleClicked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "onCellContextMenu", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "getQuickFilterText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "filterValueGetter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "floatingFilter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerComponent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerComponentFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerComponentParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AgGridColumn.prototype, "menuTabs", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "columnsMenuParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressMenu", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "headerCheckboxSelection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "headerCheckboxSelectionFilteredOnly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "chartDataType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "pinned", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "initialPinned", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "lockPinned", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "pinnedRowCellRenderer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "pinnedRowCellRendererFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "pinnedRowCellRendererParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "pinnedRowValueFormatter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "pivot", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "initialPivot", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "pivotIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "initialPivotIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "pivotComparator", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "enablePivot", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellClassRules", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellRenderer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellRendererFramework", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "cellRendererParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "cellRendererSelector", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "autoHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "wrapText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "enableCellChangeFlash", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressCellFlash", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "rowDrag", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "rowDragText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "dndSource", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "dndSourceOnRowDrag", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "rowGroup", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "initialRowGroup", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "rowGroupIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "initialRowGroupIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "enableRowGroup", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "enableValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "aggFunc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "initialAggFunc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AgGridColumn.prototype, "allowedAggFuncs", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AgGridColumn.prototype, "showRowGroup", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "sortable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "sort", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AgGridColumn.prototype, "initialSort", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "sortIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "initialSortIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AgGridColumn.prototype, "sortingOrder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "comparator", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "unSortIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "sortedAt", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "colSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AgGridColumn.prototype, "rowSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "initialWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "minWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "maxWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "flex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AgGridColumn.prototype, "initialFlex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "resizable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressSizeToFit", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AgGridColumn.prototype, "suppressAutoSize", void 0);
AgGridColumn.Éµfac = function AgGridColumn_Factory(t) { return new (t || AgGridColumn)(); };
AgGridColumn.Éµcmp = Éµngcc0.ÉµÉµdefineComponent({ type: AgGridColumn, selectors: [["ag-grid-column"]], contentQueries: function AgGridColumn_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        Éµngcc0.ÉµÉµcontentQuery(dirIndex, AgGridColumn_1, 0);
    } if (rf & 2) {
        var _t;
        Éµngcc0.ÉµÉµqueryRefresh(_t = Éµngcc0.ÉµÉµloadQuery()) && (ctx.childColumns = _t);
    } }, inputs: { filterFramework: "filterFramework", filterParams: "filterParams", floatingFilterComponent: "floatingFilterComponent", floatingFilterComponentParams: "floatingFilterComponentParams", floatingFilterComponentFramework: "floatingFilterComponentFramework", filter: "filter", headerName: "headerName", headerValueGetter: "headerValueGetter", headerTooltip: "headerTooltip", headerClass: "headerClass", suppressHeaderKeyboardEvent: "suppressHeaderKeyboardEvent", columnGroupShow: "columnGroupShow", toolPanelClass: "toolPanelClass", suppressColumnsToolPanel: "suppressColumnsToolPanel", suppressFiltersToolPanel: "suppressFiltersToolPanel", tooltipComponent: "tooltipComponent", tooltipComponentFramework: "tooltipComponentFramework", tooltipComponentParams: "tooltipComponentParams", children: "children", groupId: "groupId", openByDefault: "openByDefault", marryChildren: "marryChildren", headerGroupComponent: "headerGroupComponent", headerGroupComponentFramework: "headerGroupComponentFramework", headerGroupComponentParams: "headerGroupComponentParams", colId: "colId", field: "field", type: "type", valueGetter: "valueGetter", valueFormatter: "valueFormatter", refData: "refData", keyCreator: "keyCreator", equals: "equals", tooltipField: "tooltipField", tooltipValueGetter: "tooltipValueGetter", checkboxSelection: "checkboxSelection", icons: "icons", suppressNavigable: "suppressNavigable", suppressKeyboardEvent: "suppressKeyboardEvent", suppressPaste: "suppressPaste", suppressFillHandle: "suppressFillHandle", hide: "hide", initialHide: "initialHide", lockVisible: "lockVisible", lockPosition: "lockPosition", suppressMovable: "suppressMovable", editable: "editable", valueSetter: "valueSetter", valueParser: "valueParser", cellEditor: "cellEditor", cellEditorFramework: "cellEditorFramework", cellEditorParams: "cellEditorParams", cellEditorSelector: "cellEditorSelector", singleClickEdit: "singleClickEdit", newValueHandler: "newValueHandler", cellEditorPopup: "cellEditorPopup", cellEditorPopupPosition: "cellEditorPopupPosition", onCellValueChanged: "onCellValueChanged", onCellClicked: "onCellClicked", onCellDoubleClicked: "onCellDoubleClicked", onCellContextMenu: "onCellContextMenu", getQuickFilterText: "getQuickFilterText", filterValueGetter: "filterValueGetter", floatingFilter: "floatingFilter", headerComponent: "headerComponent", headerComponentFramework: "headerComponentFramework", headerComponentParams: "headerComponentParams", menuTabs: "menuTabs", columnsMenuParams: "columnsMenuParams", suppressMenu: "suppressMenu", headerCheckboxSelection: "headerCheckboxSelection", headerCheckboxSelectionFilteredOnly: "headerCheckboxSelectionFilteredOnly", chartDataType: "chartDataType", pinned: "pinned", initialPinned: "initialPinned", lockPinned: "lockPinned", pinnedRowCellRenderer: "pinnedRowCellRenderer", pinnedRowCellRendererFramework: "pinnedRowCellRendererFramework", pinnedRowCellRendererParams: "pinnedRowCellRendererParams", pinnedRowValueFormatter: "pinnedRowValueFormatter", pivot: "pivot", initialPivot: "initialPivot", pivotIndex: "pivotIndex", initialPivotIndex: "initialPivotIndex", pivotComparator: "pivotComparator", enablePivot: "enablePivot", cellStyle: "cellStyle", cellClass: "cellClass", cellClassRules: "cellClassRules", cellRenderer: "cellRenderer", cellRendererFramework: "cellRendererFramework", cellRendererParams: "cellRendererParams", cellRendererSelector: "cellRendererSelector", autoHeight: "autoHeight", wrapText: "wrapText", enableCellChangeFlash: "enableCellChangeFlash", suppressCellFlash: "suppressCellFlash", rowDrag: "rowDrag", rowDragText: "rowDragText", dndSource: "dndSource", dndSourceOnRowDrag: "dndSourceOnRowDrag", rowGroup: "rowGroup", initialRowGroup: "initialRowGroup", rowGroupIndex: "rowGroupIndex", initialRowGroupIndex: "initialRowGroupIndex", enableRowGroup: "enableRowGroup", enableValue: "enableValue", aggFunc: "aggFunc", initialAggFunc: "initialAggFunc", allowedAggFuncs: "allowedAggFuncs", showRowGroup: "showRowGroup", sortable: "sortable", sort: "sort", initialSort: "initialSort", sortIndex: "sortIndex", initialSortIndex: "initialSortIndex", sortingOrder: "sortingOrder", comparator: "comparator", unSortIcon: "unSortIcon", sortedAt: "sortedAt", colSpan: "colSpan", rowSpan: "rowSpan", width: "width", initialWidth: "initialWidth", minWidth: "minWidth", maxWidth: "maxWidth", flex: "flex", initialFlex: "initialFlex", resizable: "resizable", suppressSizeToFit: "suppressSizeToFit", suppressAutoSize: "suppressAutoSize" }, decls: 0, vars: 0, template: function AgGridColumn_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(AgGridColumn, [{
        type: Component,
        args: [{
                selector: 'ag-grid-column',
                template: ''
            }]
    }], function () { return []; }, { filterFramework: [{
            type: Input
        }], filterParams: [{
            type: Input
        }], floatingFilterComponent: [{
            type: Input
        }], floatingFilterComponentParams: [{
            type: Input
        }], floatingFilterComponentFramework: [{
            type: Input
        }], filter: [{
            type: Input
        }], headerName: [{
            type: Input
        }], headerValueGetter: [{
            type: Input
        }], headerTooltip: [{
            type: Input
        }], headerClass: [{
            type: Input
        }], suppressHeaderKeyboardEvent: [{
            type: Input
        }], columnGroupShow: [{
            type: Input
        }], toolPanelClass: [{
            type: Input
        }], suppressColumnsToolPanel: [{
            type: Input
        }], suppressFiltersToolPanel: [{
            type: Input
        }], tooltipComponent: [{
            type: Input
        }], tooltipComponentFramework: [{
            type: Input
        }], tooltipComponentParams: [{
            type: Input
        }], children: [{
            type: Input
        }], groupId: [{
            type: Input
        }], openByDefault: [{
            type: Input
        }], marryChildren: [{
            type: Input
        }], headerGroupComponent: [{
            type: Input
        }], headerGroupComponentFramework: [{
            type: Input
        }], headerGroupComponentParams: [{
            type: Input
        }], colId: [{
            type: Input
        }], field: [{
            type: Input
        }], type: [{
            type: Input
        }], valueGetter: [{
            type: Input
        }], valueFormatter: [{
            type: Input
        }], refData: [{
            type: Input
        }], keyCreator: [{
            type: Input
        }], equals: [{
            type: Input
        }], tooltipField: [{
            type: Input
        }], tooltipValueGetter: [{
            type: Input
        }], checkboxSelection: [{
            type: Input
        }], icons: [{
            type: Input
        }], suppressNavigable: [{
            type: Input
        }], suppressKeyboardEvent: [{
            type: Input
        }], suppressPaste: [{
            type: Input
        }], suppressFillHandle: [{
            type: Input
        }], hide: [{
            type: Input
        }], initialHide: [{
            type: Input
        }], lockVisible: [{
            type: Input
        }], lockPosition: [{
            type: Input
        }], suppressMovable: [{
            type: Input
        }], editable: [{
            type: Input
        }], valueSetter: [{
            type: Input
        }], valueParser: [{
            type: Input
        }], cellEditor: [{
            type: Input
        }], cellEditorFramework: [{
            type: Input
        }], cellEditorParams: [{
            type: Input
        }], cellEditorSelector: [{
            type: Input
        }], singleClickEdit: [{
            type: Input
        }], newValueHandler: [{
            type: Input
        }], cellEditorPopup: [{
            type: Input
        }], cellEditorPopupPosition: [{
            type: Input
        }], onCellValueChanged: [{
            type: Input
        }], onCellClicked: [{
            type: Input
        }], onCellDoubleClicked: [{
            type: Input
        }], onCellContextMenu: [{
            type: Input
        }], getQuickFilterText: [{
            type: Input
        }], filterValueGetter: [{
            type: Input
        }], floatingFilter: [{
            type: Input
        }], headerComponent: [{
            type: Input
        }], headerComponentFramework: [{
            type: Input
        }], headerComponentParams: [{
            type: Input
        }], menuTabs: [{
            type: Input
        }], columnsMenuParams: [{
            type: Input
        }], suppressMenu: [{
            type: Input
        }], headerCheckboxSelection: [{
            type: Input
        }], headerCheckboxSelectionFilteredOnly: [{
            type: Input
        }], chartDataType: [{
            type: Input
        }], pinned: [{
            type: Input
        }], initialPinned: [{
            type: Input
        }], lockPinned: [{
            type: Input
        }], pinnedRowCellRenderer: [{
            type: Input
        }], pinnedRowCellRendererFramework: [{
            type: Input
        }], pinnedRowCellRendererParams: [{
            type: Input
        }], pinnedRowValueFormatter: [{
            type: Input
        }], pivot: [{
            type: Input
        }], initialPivot: [{
            type: Input
        }], pivotIndex: [{
            type: Input
        }], initialPivotIndex: [{
            type: Input
        }], pivotComparator: [{
            type: Input
        }], enablePivot: [{
            type: Input
        }], cellStyle: [{
            type: Input
        }], cellClass: [{
            type: Input
        }], cellClassRules: [{
            type: Input
        }], cellRenderer: [{
            type: Input
        }], cellRendererFramework: [{
            type: Input
        }], cellRendererParams: [{
            type: Input
        }], cellRendererSelector: [{
            type: Input
        }], autoHeight: [{
            type: Input
        }], wrapText: [{
            type: Input
        }], enableCellChangeFlash: [{
            type: Input
        }], suppressCellFlash: [{
            type: Input
        }], rowDrag: [{
            type: Input
        }], rowDragText: [{
            type: Input
        }], dndSource: [{
            type: Input
        }], dndSourceOnRowDrag: [{
            type: Input
        }], rowGroup: [{
            type: Input
        }], initialRowGroup: [{
            type: Input
        }], rowGroupIndex: [{
            type: Input
        }], initialRowGroupIndex: [{
            type: Input
        }], enableRowGroup: [{
            type: Input
        }], enableValue: [{
            type: Input
        }], aggFunc: [{
            type: Input
        }], initialAggFunc: [{
            type: Input
        }], allowedAggFuncs: [{
            type: Input
        }], showRowGroup: [{
            type: Input
        }], sortable: [{
            type: Input
        }], sort: [{
            type: Input
        }], initialSort: [{
            type: Input
        }], sortIndex: [{
            type: Input
        }], initialSortIndex: [{
            type: Input
        }], sortingOrder: [{
            type: Input
        }], comparator: [{
            type: Input
        }], unSortIcon: [{
            type: Input
        }], sortedAt: [{
            type: Input
        }], colSpan: [{
            type: Input
        }], rowSpan: [{
            type: Input
        }], width: [{
            type: Input
        }], initialWidth: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], maxWidth: [{
            type: Input
        }], flex: [{
            type: Input
        }], initialFlex: [{
            type: Input
        }], resizable: [{
            type: Input
        }], suppressSizeToFit: [{
            type: Input
        }], suppressAutoSize: [{
            type: Input
        }], childColumns: [{
            type: ContentChildren,
            args: [AgGridColumn_1]
        }] }); })();
    return AgGridColumn;
}());
export { AgGridColumn };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWctZ3JpZC1jb2x1bW4uY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJhZy1ncmlkLWFuZ3VsYXIvbGliL2FnLWdyaWQtY29sdW1uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNN0U7QUFDb0IsSUFEcEI7QUFBMEIsUUFrQ3RCLGdIQUFnSDtBQUNwSCxRQUFJLFVBQVU7QUFDZCxRQUFvQixvQkFBZSxHQUFRLFNBQVMsQ0FBQztBQUNyRCxRQUFvQixpQkFBWSxHQUFRLFNBQVMsQ0FBQztBQUNsRCxRQUFvQiw0QkFBdUIsR0FBUSxTQUFTLENBQUM7QUFDN0QsUUFBb0Isa0NBQTZCLEdBQVEsU0FBUyxDQUFDO0FBQ25FLFFBQW9CLHFDQUFnQyxHQUFRLFNBQVMsQ0FBQztBQUN0RSxRQUFvQixXQUFNLEdBQVEsU0FBUyxDQUFDO0FBQzVDLFFBQUksNElBQTRJO0FBQ2hKLFFBQW9CLGVBQVUsR0FBdUIsU0FBUyxDQUFDO0FBQy9ELFFBQUksNEVBQTRFO0FBQ2hGLFFBQW9CLHNCQUFpQixHQUErQyxTQUFTLENBQUM7QUFDOUYsUUFBSSxzRUFBc0U7QUFDMUUsUUFBQSx3Q0FBd0M7QUFDeEMsUUFBb0Isa0JBQWEsR0FBdUIsU0FBUyxDQUFDO0FBQ2xFLFFBQUksZ0dBQWdHO0FBQ3BHLFFBQW9CLGdCQUFXLEdBQTRCLFNBQVMsQ0FBQztBQUNyRSxRQUFJLG9HQUFvRztBQUN4RyxRQUFvQixnQ0FBMkIsR0FBeUUsU0FBUyxDQUFDO0FBQ2xJLFFBQUksc0VBQXNFO0FBQzFFLFFBQW9CLG9CQUFlLEdBQXVCLFNBQVMsQ0FBQztBQUNwRSxRQUFJLG9HQUFvRztBQUN4RyxRQUFvQixtQkFBYyxHQUErQixTQUFTLENBQUM7QUFDM0UsUUFBSSxxR0FBcUc7QUFDekcsUUFBb0IsNkJBQXdCLEdBQXdCLFNBQVMsQ0FBQztBQUM5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QUssRUFBRTtBQUFFO0FBQTBDLHFEQUFRO0FBQy9ELElBQ1k7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBRTtBQUEyQyxtREFBTTtBQUM5RCxJQUNZO0FBQWEsUUFBckIsS0FBSyxFQUFFO0FBQUU7QUFBMkMsMkRBQWM7QUFDdEUsSUFDWTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFFO0FBQTJDLDBEQUFhO0lBOVR6RCxZQUFZLHlDQUp4QixTQUFTLENBQUMsY0FDUCxRQUFRLEVBQUU7ZUFBZ0IsY0FDMUIsUUFBUSxFQUFFLEVBQUUsVUFDZixDQUFDLFFBQ1csWUFBWSxDQTRXeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQ0Q7QUFBQyxJQURELG1CQUFDO0FBQ0EsQ0FEQSxBQTVXRCxJQTRXQztBQUNELFNBN1dhLFlBQVk7QUFDeEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsQ2xhc3NGdW5jLCBDZWxsQ2xhc3NSdWxlcywgQ2VsbENsaWNrZWRFdmVudCwgQ2VsbENvbnRleHRNZW51RXZlbnQsIENlbGxEb3VibGVDbGlja2VkRXZlbnQsIENlbGxFZGl0b3JTZWxlY3RvckZ1bmMsIENlbGxSZW5kZXJlclNlbGVjdG9yRnVuYywgQ2VsbFN0eWxlLCBDZWxsU3R5bGVGdW5jLCBDaGVja2JveFNlbGVjdGlvbkNhbGxiYWNrLCBDb2xEZWYsIENvbEdyb3VwRGVmLCBDb2xTcGFuUGFyYW1zLCBDb2x1bW5zTWVudVBhcmFtcywgRG5kU291cmNlQ2FsbGJhY2ssIEVkaXRhYmxlQ2FsbGJhY2ssIEdldFF1aWNrRmlsdGVyVGV4dFBhcmFtcywgSGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjaywgSGVhZGVyQ2xhc3MsIEhlYWRlclZhbHVlR2V0dGVyRnVuYywgSUFnZ0Z1bmMsIElDZWxsRWRpdG9yQ29tcCwgSUNlbGxSZW5kZXJlckNvbXAsIElDZWxsUmVuZGVyZXJGdW5jLCBJSGVhZGVyR3JvdXBDb21wLCBJUm93RHJhZ0l0ZW0sIElUb29sdGlwQ29tcCwgSVRvb2x0aXBQYXJhbXMsIEtleUNyZWF0b3JQYXJhbXMsIE5ld1ZhbHVlUGFyYW1zLCBSb3dEcmFnQ2FsbGJhY2ssIFJvd05vZGUsIFJvd1NwYW5QYXJhbXMsIFN1cHByZXNzSGVhZGVyS2V5Ym9hcmRFdmVudFBhcmFtcywgU3VwcHJlc3NLZXlib2FyZEV2ZW50UGFyYW1zLCBTdXBwcmVzc05hdmlnYWJsZUNhbGxiYWNrLCBTdXBwcmVzc1Bhc3RlQ2FsbGJhY2ssIFRvb2xQYW5lbENsYXNzLCBWYWx1ZUZvcm1hdHRlckZ1bmMsIFZhbHVlR2V0dGVyRnVuYywgVmFsdWVQYXJzZXJGdW5jLCBWYWx1ZVNldHRlckZ1bmMgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgUXVlcnlMaXN0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZy1ncmlkLWNvbHVtbicsXG4gICAgdGVtcGxhdGU6ICcnXG59KVxuZXhwb3J0IGNsYXNzIEFnR3JpZENvbHVtbiB7XG4gICAgQENvbnRlbnRDaGlsZHJlbihBZ0dyaWRDb2x1bW4pIHB1YmxpYyBjaGlsZENvbHVtbnM6IFF1ZXJ5TGlzdDxBZ0dyaWRDb2x1bW4+O1xuXG4gICAgcHVibGljIGhhc0NoaWxkQ29sdW1ucygpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRDb2x1bW5zICYmIHRoaXMuY2hpbGRDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzEwMDk4XG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLmNoaWxkQ29sdW1ucy5sZW5ndGggPT09IDEgJiYgdGhpcy5jaGlsZENvbHVtbnMuZmlyc3QgPT09IHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9Db2xEZWYoKTogQ29sRGVmIHtcbiAgICAgICAgbGV0IGNvbERlZjogQ29sRGVmID0gdGhpcy5jcmVhdGVDb2xEZWZGcm9tR3JpZENvbHVtbih0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNDaGlsZENvbHVtbnMoKSkge1xuICAgICAgICAgICAgKDxhbnk+Y29sRGVmKVtcImNoaWxkcmVuXCJdID0gdGhpcy5nZXRDaGlsZENvbERlZnModGhpcy5jaGlsZENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xEZWY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDaGlsZENvbERlZnMoY2hpbGRDb2x1bW5zOiBRdWVyeUxpc3Q8QWdHcmlkQ29sdW1uPikge1xuICAgICAgICByZXR1cm4gY2hpbGRDb2x1bW5zXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xMDA5OFxuICAgICAgICAgICAgLmZpbHRlcihjb2x1bW4gPT4gIWNvbHVtbi5oYXNDaGlsZENvbHVtbnMoKSlcbiAgICAgICAgICAgIC5tYXAoKGNvbHVtbjogQWdHcmlkQ29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi50b0NvbERlZigpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2xEZWZGcm9tR3JpZENvbHVtbihmcm9tOiBBZ0dyaWRDb2x1bW4pOiBDb2xEZWYge1xuICAgICAgICBsZXQgeyBjaGlsZENvbHVtbnMsIC4uLmNvbERlZiB9ID0gZnJvbTtcbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICAvLyBpbnB1dHMgLSBwcmV0dHkgbXVjaCBtb3N0IG9mIENvbERlZiwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCBhbmQgaW50ZXJuYWwgb25seSBwcm9wZXJ0aWVzXG4gICAgLy8gQFNUQVJUQFxuICAgIEBJbnB1dCgpIHB1YmxpYyBmaWx0ZXJGcmFtZXdvcms6IGFueSA9IHVuZGVmaW5lZDtcbiAgICBASW5wdXQoKSBwdWJsaWMgZmlsdGVyUGFyYW1zOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgQElucHV0KCkgcHVibGljIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50OiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgQElucHV0KCkgcHVibGljIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50UGFyYW1zOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgQElucHV0KCkgcHVibGljIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50RnJhbWV3b3JrOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgQElucHV0KCkgcHVibGljIGZpbHRlcjogYW55ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBUaGUgbmFtZSB0byByZW5kZXIgaW4gdGhlIGNvbHVtbiBoZWFkZXIuIElmIG5vdCBzcGVjaWZpZWQgYW5kIGZpZWxkIGlzIHNwZWNpZmllZCwgdGhlIGZpZWxkIG5hbWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBoZWFkZXIgbmFtZS4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gR2V0cyB0aGUgdmFsdWUgZm9yIGRpc3BsYXkgaW4gdGhlIGhlYWRlci4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlclZhbHVlR2V0dGVyOiBzdHJpbmcgfCBIZWFkZXJWYWx1ZUdldHRlckZ1bmMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFdoZXRoZXIgdG8gc2hvdyB0aGUgY29sdW1uIHdoZW4gdGhlIGdyb3VwIGlzIG9wZW4gLyBjbG9zZWQuICAgICAqL1xuLyoqIFRvb2x0aXAgZm9yIHRoZSBjb2x1bW4gaGVhZGVyICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJUb29sdGlwOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIENTUyBjbGFzcyB0byB1c2UgZm9yIHRoZSBoZWFkZXIgY2VsbC4gQ2FuIGJlIGEgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlckNsYXNzOiBIZWFkZXJDbGFzcyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU3VwcHJlc3MgdGhlIGdyaWQgdGFraW5nIGFjdGlvbiBmb3IgdGhlIHJlbGV2YW50IGtleWJvYXJkIGV2ZW50IHdoZW4gYSBoZWFkZXIgaXMgZm9jdXNlZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHN1cHByZXNzSGVhZGVyS2V5Ym9hcmRFdmVudDogKChwYXJhbXM6IFN1cHByZXNzSGVhZGVyS2V5Ym9hcmRFdmVudFBhcmFtcykgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFdoZXRoZXIgdG8gc2hvdyB0aGUgY29sdW1uIHdoZW4gdGhlIGdyb3VwIGlzIG9wZW4gLyBjbG9zZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb2x1bW5Hcm91cFNob3c6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ1NTIGNsYXNzIHRvIHVzZSBmb3IgdGhlIHRvb2wgcGFuZWwgY2VsbC4gQ2FuIGJlIGEgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHRvb2xQYW5lbENsYXNzOiBUb29sUGFuZWxDbGFzcyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyBjb2x1bW4gb3IgZ3JvdXAgdG8gYXBwZWFyIGluIHRoZSBDb2x1bW5zIFRvb2wgUGFuZWwuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdXBwcmVzc0NvbHVtbnNUb29sUGFuZWw6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgY29sdW1uIChmaWx0ZXIpIG9yIGdyb3VwIChmaWx0ZXIgZ3JvdXApIHRvIGFwcGVhciBpbiB0aGUgRmlsdGVycyBUb29sIFBhbmVsLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc3VwcHJlc3NGaWx0ZXJzVG9vbFBhbmVsOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0b29sdGlwQ29tcG9uZW50OiB7IG5ldygpOiBJVG9vbHRpcENvbXA7IH0gfCBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgQElucHV0KCkgcHVibGljIHRvb2x0aXBDb21wb25lbnRGcmFtZXdvcms6IGFueSA9IHVuZGVmaW5lZDtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9vbHRpcENvbXBvbmVudFBhcmFtczogYW55ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGxpc3QgY29udGFpbmluZyBhIG1peCBvZiBjb2x1bW5zIGFuZCBjb2x1bW4gZ3JvdXBzLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2hpbGRyZW46IChDb2xEZWYgfCBDb2xHcm91cERlZilbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogVGhlIHVuaXF1ZSBJRCB0byBnaXZlIHRoZSBjb2x1bW4uIFRoaXMgaXMgb3B0aW9uYWwuIElmIG1pc3NpbmcsIGEgdW5pcXVlIElEIHdpbGwgYmUgZ2VuZXJhdGVkLiBUaGlzIElEIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGNvbHVtbiBncm91cCBpbiB0aGUgY29sdW1uIEFQSS4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGdyb3VwSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIGdyb3VwIHNob3VsZCBiZSBvcGVuZWQgYnkgZGVmYXVsdC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG9wZW5CeURlZmF1bHQ6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8ga2VlcCBjb2x1bW5zIGluIHRoaXMgZ3JvdXAgYmVzaWRlIGVhY2ggb3RoZXIgaW4gdGhlIGdyaWQuIE1vdmluZyB0aGUgY29sdW1ucyBvdXRzaWRlIG9mIHRoZSBncm91cCAoYW5kIGhlbmNlIGJyZWFraW5nIHRoZSBncm91cCkgaXMgbm90IGFsbG93ZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBtYXJyeUNoaWxkcmVuOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBUaGUgY3VzdG9tIGhlYWRlciBncm91cCBjb21wb25lbnQgdG8gYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgaGVhZGVyLiBJZiBub25lIHNwZWNpZmllZCB0aGUgZGVmYXVsdCBBRyBHcmlkIGlzIHVzZWQqICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJHcm91cENvbXBvbmVudDogc3RyaW5nIHwgeyBuZXcoKTogSUhlYWRlckdyb3VwQ29tcDsgfSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogVGhlIGN1c3RvbSBoZWFkZXIgZ3JvdXAgY29tcG9uZW50IHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50IGhlYWRlciBpbiB0aGUgaG9zdGluZyBmcmFtZXdvcmsgKGllOiBBbmd1bGFyL1JlYWN0L1Z1ZUpzKS4gSWYgbm9uZSBzcGVjaWZpZWQgdGhlIGRlZmF1bHQgQUcgR3JpZCBpcyB1c2VkKiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaGVhZGVyR3JvdXBDb21wb25lbnRGcmFtZXdvcms6IGFueSA9IHVuZGVmaW5lZDtcbiAgICAvKiogVGhlIHBhcmFtcyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgaGVhZGVyIGdyb3VwIGNvbXBvbmVudC4gICAgICogICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlckdyb3VwQ29tcG9uZW50UGFyYW1zOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSB1bmlxdWUgSUQgdG8gZ2l2ZSB0aGUgY29sdW1uLiBUaGlzIGlzIG9wdGlvbmFsLiBJZiBtaXNzaW5nLCB0aGUgSUQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmaWVsZC5cbiAgICAgKiBJZiBib3RoIGZpZWxkIGFuZCBjb2xJZCBhcmUgbWlzc2luZywgYSB1bmlxdWUgSUQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAgICogVGhpcyBJRCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBjb2x1bW4gaW4gdGhlIEFQSSBmb3Igc29ydGluZywgZmlsdGVyaW5nIGV0Yy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNvbElkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBmaWVsZCBvZiB0aGUgcm93IHRvIGdldCB0aGUgY2VsbHMgZGF0YSBmcm9tICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmaWVsZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIGBDb2x1bW5UeXBlYCBrZXlzIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgdGVtcGxhdGUgZm9yIGEgY29sdW1uLlxuICAgICAqIFRoaXMgaGVscHMgdG8gcmVkdWNlIGR1cGxpY2F0aW9uIG9mIHByb3BlcnRpZXMgd2hlbiB5b3UgaGF2ZSBhIGxvdCBvZiBjb21tb24gY29sdW1uIHByb3BlcnRpZXMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0eXBlOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gR2V0cyB0aGUgdmFsdWUgZnJvbSB5b3VyIGRhdGEgZm9yIGRpc3BsYXkuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB2YWx1ZUdldHRlcjogc3RyaW5nIHwgVmFsdWVHZXR0ZXJGdW5jIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGZ1bmN0aW9uIG9yIGV4cHJlc3Npb24gdG8gZm9ybWF0IGEgdmFsdWUsIHNob3VsZCByZXR1cm4gYSBzdHJpbmcuIE5vdCB1c2VkIGZvciBDU1YgZXhwb3J0IG9yIGNvcHkgdG8gY2xpcGJvYXJkLCBvbmx5IGZvciBVSSBjZWxsIHJlbmRlcmluZy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHZhbHVlRm9ybWF0dGVyOiBzdHJpbmcgfCBWYWx1ZUZvcm1hdHRlckZ1bmMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFByb3ZpZGVkIGEgcmVmZXJlbmNlIGRhdGEgbWFwIHRvIGJlIHVzZWQgdG8gbWFwIGNvbHVtbiB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSBmcm9tIHRoZSBtYXAuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZWZEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gdG8gcmV0dXJuIGEgc3RyaW5nIGtleSBmb3IgYSB2YWx1ZS5cbiAgICAgKiBUaGlzIHN0cmluZyBpcyB1c2VkIGZvciBncm91cGluZywgU2V0IGZpbHRlcmluZywgYW5kIHNlYXJjaGluZyB3aXRoaW4gY2VsbCBlZGl0b3IgZHJvcGRvd25zLlxuICAgICAqIFdoZW4gZmlsdGVyaW5nIGFuZCBzZWFyY2hpbmcgdGhlIHN0cmluZyBpcyBleHBvc2VkIHRvIHRoZSB1c2VyLCBzbyBtYWtlIHN1cmUgdG8gcmV0dXJuIGEgaHVtYW4tcmVhZGFibGUgdmFsdWUuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBrZXlDcmVhdG9yOiAoKHBhcmFtczogS2V5Q3JlYXRvclBhcmFtcykgPT4gc3RyaW5nKSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ3VzdG9tIGNvbXBhcmF0b3IgZm9yIHZhbHVlcywgdXNlZCBieSByZW5kZXJlciB0byBrbm93IGlmIHZhbHVlcyBoYXZlIGNoYW5nZWQuIENlbGxzIHdobydzIHZhbHVlcyBoYXZlIG5vdCBjaGFuZ2VkIGRvbid0IGdldCByZWZyZXNoZWQuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgZ3JpZCB1c2VzIGA9PT1gIGlzIHVzZWQgd2hpY2ggc2hvdWxkIHdvcmsgZm9yIG1vc3QgdXNlIGNhc2VzLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgZXF1YWxzOiAoKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSkgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBmaWVsZCBvZiB0aGUgdG9vbHRpcCB0byBhcHBseSB0byB0aGUgY2VsbC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHRvb2x0aXBGaWVsZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayB0aGF0IHNob3VsZCByZXR1cm4gdGhlIHN0cmluZyB1c2VkIGZvciBhIHRvb2x0aXAsIGB0b29sdGlwRmllbGRgIHRha2VzIHByZWNlZGVuY2UgaWYgc2V0LiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgdG9vbHRpcFZhbHVlR2V0dGVyOiAoKHBhcmFtczogSVRvb2x0aXBQYXJhbXMpID0+IHN0cmluZykgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIHJlbmRlciBhIHNlbGVjdGlvbiBjaGVja2JveCBpbiB0aGUgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBDaGVja2JveFNlbGVjdGlvbkNhbGxiYWNrIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBJY29ucyB0byB1c2UgaW5zaWRlIHRoZSBjb2x1bW4gaW5zdGVhZCBvZiB0aGUgZ3JpZCdzIGRlZmF1bHQgaWNvbnMuIExlYXZlIHVuZGVmaW5lZCB0byB1c2UgZGVmYXVsdHMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uczogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbiB8IHN0cmluZzsgfSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIGNvbHVtbiBpcyBub3QgbmF2aWdhYmxlIChpLmUuIGNhbm5vdCBiZSB0YWJiZWQgaW50byksIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqIENhbiBhbHNvIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaGF2ZSBkaWZmZXJlbnQgcm93cyBuYXZpZ2FibGUuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdXBwcmVzc05hdmlnYWJsZTogYm9vbGVhbiB8IFN1cHByZXNzTmF2aWdhYmxlQ2FsbGJhY2sgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEFsbG93cyB0aGUgdXNlciB0byBzdXBwcmVzcyBjZXJ0YWluIGtleWJvYXJkIGV2ZW50cyBpbiB0aGUgZ3JpZCBjZWxsICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdXBwcmVzc0tleWJvYXJkRXZlbnQ6ICgocGFyYW1zOiBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXMpID0+IGJvb2xlYW4pIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBQYXN0aW5nIGlzIG9uIGJ5IGRlZmF1bHQgYXMgbG9uZyBhcyBjZWxscyBhcmUgZWRpdGFibGUgKG5vbi1lZGl0YWJsZSBjZWxscyBjYW5ub3QgYmUgbW9kaWZpZWQsIGV2ZW4gd2l0aCBhIHBhc3RlIG9wZXJhdGlvbikuXG4gICAgICogU2V0IHRvIGB0cnVlYCB0dXJuIHBhc3RlIG9wZXJhdGlvbnMgb2ZmLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc3VwcHJlc3NQYXN0ZTogYm9vbGVhbiB8IFN1cHByZXNzUGFzdGVDYWxsYmFjayB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgZmlsbEhhbmRsZSBmcm9tIGJlaW5nIHJlbmRlcmVkIGluIGFueSBjZWxsIHRoYXQgYmVsb25ncyB0byB0aGlzIGNvbHVtbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc3VwcHJlc3NGaWxsSGFuZGxlOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGZvciB0aGlzIGNvbHVtbiB0byBiZSBoaWRkZW4uICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBoaWRlOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzICdoaWRlJywgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbml0aWFsSGlkZTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBibG9jayBtYWtpbmcgY29sdW1uIHZpc2libGUgLyBoaWRkZW4gdmlhIHRoZSBVSSAoQVBJIHdpbGwgc3RpbGwgd29yaykuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBsb2NrVmlzaWJsZTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBhbHdheXMgaGF2ZSB0aGlzIGNvbHVtbiBkaXNwbGF5ZWQgZmlyc3QuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBsb2NrUG9zaXRpb246IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgY29sdW1uIHRvIGJlIG1vdmFibGUgdmlhIGRyYWdnaW5nLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc3VwcHJlc3NNb3ZhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHRoaXMgY29sdW1uIGlzIGVkaXRhYmxlLCBvdGhlcndpc2UgYGZhbHNlYC4gQ2FuIGFsc28gYmUgYSBmdW5jdGlvbiB0byBoYXZlIGRpZmZlcmVudCByb3dzIGVkaXRhYmxlLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgZWRpdGFibGU6IGJvb2xlYW4gfCBFZGl0YWJsZUNhbGxiYWNrIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBGdW5jdGlvbiBvciBleHByZXNzaW9uLiBTZXRzIHRoZSB2YWx1ZSBpbnRvIHlvdXIgZGF0YSBmb3Igc2F2aW5nLiBSZXR1cm4gYHRydWVgIGlmIHRoZSBkYXRhIGNoYW5nZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB2YWx1ZVNldHRlcjogc3RyaW5nIHwgVmFsdWVTZXR0ZXJGdW5jIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBGdW5jdGlvbiBvciBleHByZXNzaW9uLiBQYXJzZXMgdGhlIHZhbHVlIGZvciBzYXZpbmcuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB2YWx1ZVBhcnNlcjogc3RyaW5nIHwgVmFsdWVQYXJzZXJGdW5jIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGBjZWxsRWRpdG9yYCB0byB1c2UgZm9yIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2VsbEVkaXRvcjogc3RyaW5nIHwgeyBuZXcoKTogSUNlbGxFZGl0b3JDb21wOyB9IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBGcmFtZXdvcmsgYGNlbGxFZGl0b3JgIHRvIHVzZSBmb3IgdGhpcyBjb2x1bW4uICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjZWxsRWRpdG9yRnJhbWV3b3JrOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFBhcmFtcyB0byBiZSBwYXNzZWQgdG8gdGhlIGNlbGwgZWRpdG9yIGNvbXBvbmVudC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNlbGxFZGl0b3JQYXJhbXM6IGFueSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ2FsbGJhY2sgdG8gc2VsZWN0IHdoaWNoIGNlbGwgZWRpdG9yIHRvIGJlIHVzZWQgZm9yIGEgZ2l2ZW4gcm93IHdpdGhpbiB0aGUgc2FtZSBjb2x1bW4uICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjZWxsRWRpdG9yU2VsZWN0b3I6IENlbGxFZGl0b3JTZWxlY3RvckZ1bmMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gaGF2ZSBjZWxscyB1bmRlciB0aGlzIGNvbHVtbiBlbnRlciBlZGl0IG1vZGUgYWZ0ZXIgc2luZ2xlIGNsaWNrLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc2luZ2xlQ2xpY2tFZGl0OiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHZhbHVlU2V0dGVyYCBpbnN0ZWFkXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG5ld1ZhbHVlSGFuZGxlcjogKChwYXJhbXM6IE5ld1ZhbHVlUGFyYW1zKSA9PiBib29sZWFuKSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCwgdG8gaGF2ZSB0aGUgY2VsbCBlZGl0b3IgYXBwZWFyIGluIGEgcG9wdXAuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjZWxsRWRpdG9yUG9wdXA6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0aGUgcG9zaXRpb24gZm9yIHRoZSBwb3B1cCBjZWxsIGVkaXRvci4gUG9zc2libGUgdmFsdWVzIGFyZVxuICAgICAqICAgLSBgb3ZlcmAgUG9wdXAgd2lsbCBiZSBwb3NpdGlvbmVkIG92ZXIgdGhlIGNlbGxcbiAgICAgKiAgIC0gYHVuZGVyYCBQb3B1cCB3aWxsIGJlIHBvc2l0aW9uZWQgYmVsb3cgdGhlIGNlbGwgbGVhdmluZyB0aGUgY2VsbCB2YWx1ZSB2aXNpYmxlLlxuICAgICAqIFxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGBvdmVyYC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNlbGxFZGl0b3JQb3B1cFBvc2l0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIENhbGxiYWNrIGZvciBhZnRlciB0aGUgdmFsdWUgb2YgYSBjZWxsIGhhcyBjaGFuZ2VkLCBlaXRoZXIgZHVlIHRvIGVkaXRpbmcgb3IgdGhlIGFwcGxpY2F0aW9uIGNhbGxpbmcgYGFwaS5zZXRWYWx1ZSgpYC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG9uQ2VsbFZhbHVlQ2hhbmdlZDogKChldmVudDogTmV3VmFsdWVQYXJhbXMpID0+IHZvaWQpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIGNlbGwgaXMgY2xpY2tlZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG9uQ2VsbENsaWNrZWQ6ICgoZXZlbnQ6IENlbGxDbGlja2VkRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIGNlbGwgaXMgZG91YmxlIGNsaWNrZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBvbkNlbGxEb3VibGVDbGlja2VkOiAoKGV2ZW50OiBDZWxsRG91YmxlQ2xpY2tlZEV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBjZWxsIGlzIHJpZ2h0IGNsaWNrZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBvbkNlbGxDb250ZXh0TWVudTogKChldmVudDogQ2VsbENvbnRleHRNZW51RXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGZ1bmN0aW9uIHRvIHRlbGwgdGhlIGdyaWQgd2hhdCBxdWljayBmaWx0ZXIgdGV4dCB0byB1c2UgZm9yIHRoaXMgY29sdW1uIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCAod2hpY2ggaXMgY2FsbGluZyBgdG9TdHJpbmdgIG9uIHRoZSB2YWx1ZSkuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBnZXRRdWlja0ZpbHRlclRleHQ6ICgocGFyYW1zOiBHZXRRdWlja0ZpbHRlclRleHRQYXJhbXMpID0+IHN0cmluZykgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEZ1bmN0aW9uIG9yIGV4cHJlc3Npb24uIEdldHMgdGhlIHZhbHVlIGZvciBmaWx0ZXJpbmcgcHVycG9zZXMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmaWx0ZXJWYWx1ZUdldHRlcjogc3RyaW5nIHwgVmFsdWVHZXR0ZXJGdW5jIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBXaGV0aGVyIHRvIGRpc3BsYXkgYSBmbG9hdGluZyBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgZmxvYXRpbmdGaWx0ZXI6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBjdXN0b20gaGVhZGVyIGNvbXBvbmVudCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCBoZWFkZXIuIElmIG5vbmUgc3BlY2lmaWVkIHRoZSBkZWZhdWx0IEFHIEdyaWQgaGVhZGVyIGNvbXBvbmVudCBpcyB1c2VkLiAgICAgKiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaGVhZGVyQ29tcG9uZW50OiBzdHJpbmcgfCB7IG5ldygpOiBhbnk7IH0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBjdXN0b20gaGVhZGVyIGNvbXBvbmVudCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCBoZWFkZXIgaW4gdGhlIGhvc3RpbmcgZnJhbWV3b3JrIChpZTogQW5ndWxhci9SZWFjdC9WdWVKcykuIElmIG5vbmUgc3BlY2lmaWVkIHRoZSBkZWZhdWx0IEFHIEdyaWQgaGVhZGVyIGNvbXBvbmVudCBpcyB1c2VkKiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaGVhZGVyQ29tcG9uZW50RnJhbWV3b3JrOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgaGVhZGVyIGNvbXBvbmVudC4gICAgICogICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlckNvbXBvbmVudFBhcmFtczogYW55ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYW4gYXJyYXkgY29udGFpbmluZyB6ZXJvLCBvbmUgb3IgbWFueSBvZiB0aGUgZm9sbG93aW5nIG9wdGlvbnM6IGAnZmlsdGVyTWVudVRhYicgfCAnZ2VuZXJhbE1lbnVUYWInIHwgJ2NvbHVtbnNNZW51VGFiJ2AuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggbWVudSB0YWJzIGFyZSBwcmVzZW50IGFuZCBpbiB3aGljaCBvcmRlciB0aGUgdGFicyBhcmUgc2hvd24uICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBtZW51VGFiczogc3RyaW5nW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFBhcmFtcyB1c2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3VyIGFuZCBhcHBlYXJhbmNlIG9mIHRoZSBDb2x1bW5zIE1lbnUgdGFiLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY29sdW1uc01lbnVQYXJhbXM6IENvbHVtbnNNZW51UGFyYW1zIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIG5vIG1lbnUgc2hvdWxkIGJlIHNob3duIGZvciB0aGlzIGNvbHVtbiBoZWFkZXIuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdXBwcmVzc01lbnU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIElmIGB0cnVlYCBvciB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAsIGEgJ3NlbGVjdCBhbGwnIGNoZWNrYm94IHdpbGwgYmUgcHV0IGludG8gdGhlIGhlYWRlci4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGhlYWRlckNoZWNrYm94U2VsZWN0aW9uOiBib29sZWFuIHwgSGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjayB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogSWYgYHRydWVgLCB0aGUgaGVhZGVyIGNoZWNrYm94IHNlbGVjdGlvbiB3aWxsIG9ubHkgc2VsZWN0IGZpbHRlcmVkIGl0ZW1zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25GaWx0ZXJlZE9ubHk6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIERlZmluZXMgdGhlIGNoYXJ0IGRhdGEgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBhIGNvbHVtbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNoYXJ0RGF0YVR5cGU6ICdjYXRlZ29yeScgfCAnc2VyaWVzJyB8ICd0aW1lJyB8ICdleGNsdWRlZCcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFBpbiBhIGNvbHVtbiB0byBvbmUgc2lkZTogYHJpZ2h0YCBvciBgbGVmdGAuIEEgdmFsdWUgb2YgYHRydWVgIGlzIGNvbnZlcnRlZCB0byBgJ2xlZnQnYC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbm5lZDogYm9vbGVhbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgJ3Bpbm5lZCcsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaW5pdGlhbFBpbm5lZDogYm9vbGVhbiB8IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gYmxvY2sgdGhlIHVzZXIgcGlubmluZyB0aGUgY29sdW1uLCB0aGUgY29sdW1uIGNhbiBvbmx5IGJlIHBpbm5lZCB2aWEgZGVmaW5pdGlvbnMgb3IgQVBJICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBsb2NrUGlubmVkOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2VsbFJlbmRlcmVyU2VsZWN0b3IgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgQ2VsbCBSZW5kZXJlciBmb3IgcGlubmVkIHJvd3MuIENoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGlubmVkUm93Q2VsbFJlbmRlcmVyOiB7IG5ldygpOiBJQ2VsbFJlbmRlcmVyQ29tcDsgfSB8IElDZWxsUmVuZGVyZXJGdW5jIHwgc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2VsbFJlbmRlcmVyU2VsZWN0b3IgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgQ2VsbCBSZW5kZXJlciBmb3IgcGlubmVkIHJvd3MuIENoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGlubmVkUm93Q2VsbFJlbmRlcmVyRnJhbWV3b3JrOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBjZWxsUmVuZGVyZXJTZWxlY3RvciBpZiB5b3Ugd2FudCBhIGRpZmZlcmVudCBDZWxsIFJlbmRlcmVyIGZvciBwaW5uZWQgcm93cy4gQ2hlY2sgcGFyYW1zLm5vZGUucm93UGlubmVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwaW5uZWRSb3dDZWxsUmVuZGVyZXJQYXJhbXM6IGFueSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHZhbHVlRm9ybWF0dGVyIGZvciBwaW5uZWQgcm93cywgYW5kIGNoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGlubmVkUm93VmFsdWVGb3JtYXR0ZXI6IHN0cmluZyB8IFZhbHVlRm9ybWF0dGVyRnVuYyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gcGl2b3QgYnkgdGhpcyBjb2x1bW4uICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyAncGl2b3QnLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGluaXRpYWxQaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRoaXMgaW4gY29sdW1ucyB5b3Ugd2FudCB0byBwaXZvdCBieS5cbiAgICAgKiBJZiBvbmx5IHBpdm90aW5nIGJ5IG9uZSBjb2x1bW4sIHNldCB0aGlzIHRvIGFueSBudW1iZXIgKGUuZy4gYDBgKS5cbiAgICAgKiBJZiBwaXZvdGluZyBieSBtdWx0aXBsZSBjb2x1bW5zLCBzZXQgdGhpcyB0byB3aGVyZSB5b3Ugd2FudCB0aGlzIGNvbHVtbiB0byBiZSBpbiB0aGUgb3JkZXIgb2YgcGl2b3RzIChlLmcuIGAwYCBmb3IgZmlyc3QsIGAxYCBmb3Igc2Vjb25kLCBhbmQgc28gb24pLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGl2b3RJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyAncGl2b3RJbmRleCcsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaW5pdGlhbFBpdm90SW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ29tcGFyYXRvciB0byB1c2Ugd2hlbiBvcmRlcmluZyB0aGUgcGl2b3QgY29sdW1ucywgd2hlbiB0aGlzIGNvbHVtbiBpcyB1c2VkIHRvIHBpdm90IG9uLlxuICAgICAqIFRoZSB2YWx1ZXMgd2lsbCBhbHdheXMgYmUgc3RyaW5ncywgYXMgdGhlIHBpdm90IHNlcnZpY2UgdXNlcyBzdHJpbmdzIGFzIGtleXMgZm9yIHRoZSBwaXZvdCBncm91cHMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwaXZvdENvbXBhcmF0b3I6ICgodmFsdWVBOiBzdHJpbmcsIHZhbHVlQjogc3RyaW5nKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIGJlIGFibGUgdG8gcGl2b3QgYnkgdGhpcyBjb2x1bW4gdmlhIHRoZSBHVUkuIFRoaXMgd2lsbCBub3QgYmxvY2sgdGhlIEFQSSBvciBwcm9wZXJ0aWVzIGJlaW5nIHVzZWQgdG8gYWNoaWV2ZSBwaXZvdC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZVBpdm90OiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBbiBvYmplY3Qgb2YgY3NzIHZhbHVlcyAvIG9yIGZ1bmN0aW9uIHJldHVybmluZyBhbiBvYmplY3Qgb2YgY3NzIHZhbHVlcyBmb3IgYSBwYXJ0aWN1bGFyIGNlbGwuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjZWxsU3R5bGU6IENlbGxTdHlsZSB8IENlbGxTdHlsZUZ1bmMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIENsYXNzIHRvIHVzZSBmb3IgdGhlIGNlbGwuIENhbiBiZSBzdHJpbmcsIGFycmF5IG9mIHN0cmluZ3MsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2VsbENsYXNzOiBzdHJpbmcgfCBzdHJpbmdbXSB8IENlbGxDbGFzc0Z1bmMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFJ1bGVzIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGluY2x1ZGUgY2VydGFpbiBDU1MgY2xhc3Nlcy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNlbGxDbGFzc1J1bGVzOiBDZWxsQ2xhc3NSdWxlcyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQSBgY2VsbFJlbmRlcmVyYCB0byB1c2UgZm9yIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2VsbFJlbmRlcmVyOiB7IG5ldygpOiBJQ2VsbFJlbmRlcmVyQ29tcDsgfSB8IElDZWxsUmVuZGVyZXJGdW5jIHwgc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBGcmFtZXdvcmsgYGNlbGxSZW5kZXJlcmAgdG8gdXNlIGZvciB0aGlzIGNvbHVtbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNlbGxSZW5kZXJlckZyYW1ld29yazogYW55ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBQYXJhbXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBjZWxsIHJlbmRlcmVyIGNvbXBvbmVudC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNlbGxSZW5kZXJlclBhcmFtczogYW55ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayB0byBzZWxlY3Qgd2hpY2ggY2VsbCByZW5kZXJlciB0byBiZSB1c2VkIGZvciBhIGdpdmVuIHJvdyB3aXRoaW4gdGhlIHNhbWUgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgY2VsbFJlbmRlcmVyU2VsZWN0b3I6IENlbGxSZW5kZXJlclNlbGVjdG9yRnVuYyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBoYXZlIHRoZSBncmlkIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIGEgcm93IGJhc2VkIG9uIGNvbnRlbnRzIG9mIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgYXV0b0hlaWdodDogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBoYXZlIHRoZSB0ZXh0IHdyYXAgaW5zaWRlIHRoZSBjZWxsIC0gdHlwaWNhbGx5IHVzZWQgd2l0aCBgYXV0b0hlaWdodGAuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3cmFwVGV4dDogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBmbGFzaCBhIGNlbGwgd2hlbiBpdCdzIHJlZnJlc2hlZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZUNlbGxDaGFuZ2VGbGFzaDogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBwcmV2ZW50IHRoaXMgY29sdW1uIGZyb20gZmxhc2hpbmcgb24gY2hhbmdlcy4gT25seSBhcHBsaWNhYmxlIGlmIGNlbGwgZmxhc2hpbmcgaXMgdHVybmVkIG9uIGZvciB0aGUgZ3JpZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHN1cHByZXNzQ2VsbEZsYXNoOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBgYm9vbGVhbmAgb3IgYEZ1bmN0aW9uYC4gU2V0IHRvIGB0cnVlYCAob3IgcmV0dXJuIGB0cnVlYCBmcm9tIGZ1bmN0aW9uKSB0byBhbGxvdyByb3cgZHJhZ2dpbmcuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyByb3dEcmFnOiBib29sZWFuIHwgUm93RHJhZ0NhbGxiYWNrIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBIGNhbGxiYWNrIHRoYXQgc2hvdWxkIHJldHVybiBhIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgYnkgdGhlIGByb3dEcmFnQ29tcGAgd2hpbGUgZHJhZ2dpbmcgYSByb3cuXG4gICAgICogSWYgdGhpcyBjYWxsYmFjayBpcyBub3Qgc2V0LCB0aGUgY3VycmVudCBjZWxsIHZhbHVlIHdpbGwgYmUgdXNlZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHJvd0RyYWdUZXh0OiAoKHBhcmFtczogSVJvd0RyYWdJdGVtLCBkcmFnSXRlbUNvdW50OiBudW1iZXIpID0+IHN0cmluZykgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIGFsbG93IGRyYWdnaW5nIGZvciBuYXRpdmUgZHJhZyBhbmQgZHJvcC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGRuZFNvdXJjZTogYm9vbGVhbiB8IERuZFNvdXJjZUNhbGxiYWNrIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBGdW5jdGlvbiB0byBhbGxvdyBjdXN0b20gZHJhZyBmdW5jdGlvbmFsaXR5IGZvciBuYXRpdmUgZHJhZyBhbmQgZHJvcC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGRuZFNvdXJjZU9uUm93RHJhZzogKChwYXJhbXM6IHsgcm93Tm9kZTogUm93Tm9kZSwgZHJhZ0V2ZW50OiBEcmFnRXZlbnQ7IH0pID0+IHZvaWQpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIHRvIHJvdyBncm91cCBieSB0aGlzIGNvbHVtbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHJvd0dyb3VwOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzICdyb3dHcm91cCcsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaW5pdGlhbFJvd0dyb3VwOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdGhpcyBpbiBjb2x1bW5zIHlvdSB3YW50IHRvIGdyb3VwIGJ5LlxuICAgICAqIElmIG9ubHkgZ3JvdXBpbmcgYnkgb25lIGNvbHVtbiwgc2V0IHRoaXMgdG8gYW55IG51bWJlciAoZS5nLiBgMGApLlxuICAgICAqIElmIGdyb3VwaW5nIGJ5IG11bHRpcGxlIGNvbHVtbnMsIHNldCB0aGlzIHRvIHdoZXJlIHlvdSB3YW50IHRoaXMgY29sdW1uIHRvIGJlIGluIHRoZSBncm91cCAoZS5nLiBgMGAgZm9yIGZpcnN0LCBgMWAgZm9yIHNlY29uZCwgYW5kIHNvIG9uKS4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHJvd0dyb3VwSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgJ3Jvd0dyb3VwSW5kZXgnLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGluaXRpYWxSb3dHcm91cEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gYmUgYWJsZSB0byByb3cgZ3JvdXAgYnkgdGhpcyBjb2x1bW4gdmlhIHRoZSBHVUkuXG4gICAgICogVGhpcyB3aWxsIG5vdCBibG9jayB0aGUgQVBJIG9yIHByb3BlcnRpZXMgYmVpbmcgdXNlZCB0byBhY2hpZXZlIHJvdyBncm91cGluZy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZVJvd0dyb3VwOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIGJlIGFibGUgdG8gYWdncmVnYXRlIGJ5IHRoaXMgY29sdW1uIHZpYSB0aGUgR1VJLlxuICAgICAqIFRoaXMgd2lsbCBub3QgYmxvY2sgdGhlIEFQSSBvciBwcm9wZXJ0aWVzIGJlaW5nIHVzZWQgdG8gYWNoaWV2ZSBhZ2dyZWdhdGlvbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZVZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBOYW1lIG9mIGZ1bmN0aW9uIHRvIHVzZSBmb3IgYWdncmVnYXRpb24uIFlvdSBjYW4gYWxzbyBwcm92aWRlIHlvdXIgb3duIGFnZyBmdW5jdGlvbi4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGFnZ0Z1bmM6IHN0cmluZyB8IElBZ2dGdW5jIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyAnYWdnRnVuYycsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgaW5pdGlhbEFnZ0Z1bmM6IHN0cmluZyB8IElBZ2dGdW5jIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBBZ2dyZWdhdGlvbiBmdW5jdGlvbnMgYWxsb3dlZCBvbiB0aGlzIGNvbHVtbiBlLmcuIGBbJ3N1bScsICdhdmcnXWAuXG4gICAgICogSWYgbWlzc2luZywgYWxsIGluc3RhbGxlZCBmdW5jdGlvbnMgYXJlIGFsbG93ZWQuXG4gICAgICogVGhpcyB3aWxsIG9ubHkgcmVzdHJpY3Qgd2hhdCB0aGUgR1VJIGFsbG93cyBhIHVzZXIgdG8gc2VsZWN0LCBpdCBkb2VzIG5vdCBpbXBhY3Qgd2hlbiB5b3Ugc2V0IGEgZnVuY3Rpb24gdmlhIHRoZSBBUEkuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd2VkQWdnRnVuY3M6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBncmlkIHBsYWNlIHRoZSB2YWx1ZXMgZm9yIHRoZSBncm91cCBpbnRvIHRoZSBjZWxsLCBvciBwdXQgdGhlIG5hbWUgb2YgYSBncm91cGVkIGNvbHVtbiB0byBqdXN0IHNob3cgdGhhdCBncm91cC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNob3dSb3dHcm91cDogc3RyaW5nIHwgYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBhbGxvdyBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc29ydGFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIElmIHNvcnRpbmcgYnkgZGVmYXVsdCwgc2V0IGl0IGhlcmUuIFNldCB0byAnYXNjJyBvciAnZGVzYycuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzb3J0OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzIGBzb3J0YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbml0aWFsU29ydDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBJZiBzb3J0aW5nIG1vcmUgdGhhbiBvbmUgY29sdW1uIGJ5IGRlZmF1bHQsIHNwZWNpZmllcyBvcmRlciBpbiB3aGljaCB0aGUgc29ydGluZyBzaG91bGQgYmUgYXBwbGllZC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNvcnRJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyAnc29ydEluZGV4JywgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbml0aWFsU29ydEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEFycmF5IGRlZmluaW5nIHRoZSBvcmRlciBpbiB3aGljaCBzb3J0aW5nIG9jY3VycyAoaWYgc29ydGluZyBpcyBlbmFibGVkKS4gQW4gYXJyYXkgd2l0aCBhbnkgb2YgdGhlIGZvbGxvd2luZyBpbiBhbnkgb3JkZXIgWydhc2MnLCdkZXNjJyxudWxsXSAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc29ydGluZ09yZGVyOiAoc3RyaW5nIHwgbnVsbClbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQ29tcGFyYXRvciBmdW5jdGlvbiBmb3IgY3VzdG9tIHNvcnRpbmcuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb21wYXJhdG9yOiAoKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSwgbm9kZUE6IFJvd05vZGUsIG5vZGVCOiBSb3dOb2RlLCBpc0ludmVydGVkOiBib29sZWFuKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRoZSB1bnNvcnRlZCBpY29uIHRvIGJlIHNob3duIHdoZW4gbm8gc29ydCBpcyBhcHBsaWVkIHRvIHRoaXMgY29sdW1uLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgdW5Tb3J0SWNvbjogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgdjI0IC0gdXNlIHNvcnRJbmRleCBpbnN0ZWFkXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNvcnRlZEF0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEJ5IGRlZmF1bHQsIGVhY2ggY2VsbCB3aWxsIHRha2UgdXAgdGhlIHdpZHRoIG9mIG9uZSBjb2x1bW4uIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyIHRvIGFsbG93IGNlbGxzIHRvIHNwYW4gbXVsdGlwbGUgY29sdW1ucy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGNvbFNwYW46ICgocGFyYW1zOiBDb2xTcGFuUGFyYW1zKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIC8qKiBCeSBkZWZhdWx0LCBlYWNoIGNlbGwgd2lsbCB0YWtlIHVwIHRoZSBoZWlnaHQgb2Ygb25lIHJvdy4gWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXIgdG8gYWxsb3cgY2VsbHMgdG8gc3BhbiBtdWx0aXBsZSByb3dzLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcm93U3BhbjogKChwYXJhbXM6IFJvd1NwYW5QYXJhbXMpID0+IG51bWJlcikgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEluaXRpYWwgd2lkdGggaW4gcGl4ZWxzIGZvciB0aGUgY2VsbC4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgJ3dpZHRoJywgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbml0aWFsV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogTWluaW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjZWxsLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgbWluV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogTWF4aW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjZWxsLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgbWF4V2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogVXNlZCBpbnN0ZWFkIG9mIGB3aWR0aGAgd2hlbiB0aGUgZ29hbCBpcyB0byBmaWxsIHRoZSByZW1haW5pbmcgZW1wdHkgc3BhY2Ugb2YgdGhlIGdyaWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmbGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgJ2ZsZXgnLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGluaXRpYWxGbGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhpcyBjb2x1bW4gc2hvdWxkIGJlIHJlc2l6ZWQuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXNpemFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdGhpcyBjb2x1bW4ncyB3aWR0aCB0byBiZSBmaXhlZCBkdXJpbmcgJ3NpemUgdG8gZml0JyBvcGVyYXRpb25zLiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc3VwcHJlc3NTaXplVG9GaXQ6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgY29sdW1uIHRvIGJlIGF1dG8tcmVzaXphYmxlIGJ5IGRvdWJsZSBjbGlja2luZyBpdCdzIGVkZ2UuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdXBwcmVzc0F1dG9TaXplOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5cbiAgICAvLyBFbmFibGUgdHlwZSBjb2VyY2lvbiBmb3IgYm9vbGVhbiBJbnB1dHMgdG8gc3VwcG9ydCB1c2UgbGlrZSAnZW5hYmxlQ2hhcnRzJyBpbnN0ZWFkIG9mIGZvcmNpbmcgJ1tlbmFibGVDaGFydHNdPVwidHJ1ZVwiJyBcbiAgICAvLyBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvdGVtcGxhdGUtdHlwZWNoZWNrI2lucHV0LXNldHRlci1jb2VyY2lvbiBcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NDZWxsRmxhc2g6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzQ29sdW1uc1Rvb2xQYW5lbDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NGaWx0ZXJzVG9vbFBhbmVsOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9vcGVuQnlEZWZhdWx0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9tYXJyeUNoaWxkcmVuOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9oaWRlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9pbml0aWFsSGlkZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcm93R3JvdXA6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2luaXRpYWxSb3dHcm91cDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcGl2b3Q6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2luaXRpYWxQaXZvdDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfY2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hlYWRlckNoZWNrYm94U2VsZWN0aW9uOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9oZWFkZXJDaGVja2JveFNlbGVjdGlvbkZpbHRlcmVkT25seTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NNZW51OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc01vdmFibGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2xvY2tQb3NpdGlvbjogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Zpc2libGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2xvY2tQaW5uZWQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3VuU29ydEljb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzU2l6ZVRvRml0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0F1dG9TaXplOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lbmFibGVSb3dHcm91cDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlUGl2b3Q6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2VuYWJsZVZhbHVlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lZGl0YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NQYXN0ZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NOYXZpZ2FibGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2VuYWJsZUNlbGxDaGFuZ2VGbGFzaDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcm93RHJhZzogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZG5kU291cmNlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9hdXRvSGVpZ2h0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV93cmFwVGV4dDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc29ydGFibGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Jlc2l6YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc2luZ2xlQ2xpY2tFZGl0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9mbG9hdGluZ0ZpbHRlcjogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfY2VsbEVkaXRvclBvcHVwOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0ZpbGxIYW5kbGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgLy8gQEVOREBcblxufVxuIl19