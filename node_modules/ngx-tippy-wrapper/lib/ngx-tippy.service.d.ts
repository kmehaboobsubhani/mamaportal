import { RendererFactory2 } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxTippyInstance, NgxTippyProps, NgxTippyContent, NgxHideAllOptions, InstancesChanges } from './ngx-tippy.interfaces';
import * as ɵngcc0 from '@angular/core';
export declare class NgxTippyService {
    private tippyInstances;
    private tippyInstances$;
    private renderer;
    constructor(rendererFactory: RendererFactory2);
    /**
     * Working with storage
     */
    /**
     * Write tippy instances to storage
     *
     * @param name { string } name of tippy instance
     * @param state { NgxTippyInstance } tippy instance
     */
    setInstance(name: string, state: NgxTippyInstance): void;
    /**
     * Get specific tippy instance
     *
     * @param name { string } name of tippy instance
     * @returns { NgxTippyInstance | null } specific tippy instance or null
     */
    getInstance(name: string): NgxTippyInstance | null;
    /**
     * Get all tippy instances from storage
     *
     * @returns { Map<string, NgxTippyInstance> | null } all tippy instances or null
     */
    getInstances(): Map<string, NgxTippyInstance> | null;
    /**
     * Working with tippy instance methods
     */
    /**
     * Programmatically show the tippy
     *
     * @param name { string } name of tippy instance
     */
    show(name: string): void;
    /**
     * Programmatically hide the tippy
     *
     * @param name { string } name of tippy instance
     */
    hide(name: string): void;
    /**
     * Will hide the tippy only if the cursor is outside of the tippy's interactive region
     * This allows you to programmatically hook into interactive behavior upon a mouseleave event if implementing custom event listeners
     *
     * @param name { string } name of tippy instance
     * @param name { mouseEvent } pass the mouse event object in from your event listener
     */
    hideWithInteractivity(name: string, mouseEvent: MouseEvent): void;
    /**
     * Prevent a tippy from showing or hiding
     *
     * @param name { string } name of tippy instance
     */
    disable(name: string): void;
    /**
     * Re-enable a tippy
     *
     * @param name { string } name of tippy instance
     */
    enable(name: string): void;
    /**
     * Update any tippy props
     *
     * @param name { string } name of tippy instance
     * @param tippyProps { NgxTippyProps } new props
     */
    setProps(name: string, tippyProps: NgxTippyProps): void;
    /**
     * Update the content for tippy
     *
     * @param name { string } name of tippy instance
     * @param tippyContent { NgxTippyContent } new content
     */
    setContent(name: string, tippyContent: NgxTippyContent): void;
    /**
     * The element(s) that the trigger event listeners are added to
     * Allows you to separate the tippy's positioning from its trigger source
     *
     * @param name { string } name of tippy instance
     * @param triggerTarget { Element | Element[] } element(s) that the trigger tooltip
     */
    setTriggerTarget(name: string, triggerTarget: Element | Element[]): void;
    /**
     * Unmount the tippy from the DOM
     *
     * @param name { string } name of tippy instance
     */
    unmount(name: string): void;
    /**
     * Clears the instances delay timeouts
     *
     * @param name { string } name of tippy instance
     */
    clearDelayTimeouts(name: string): void;
    /**
     * Permanently destroy and clean up the tippy instance
     *
     * @param name { string } name of tippy instance
     */
    destroy(name: string): void;
    /** Working with tippy static methods */
    /**
     * Set the default props for each new tippy instance
     *
     * @param tippyProps { NgxTippyProps } default props
     */
    setDefaultProps(tippyProps: NgxTippyProps): void;
    /**
     * Show all tippies
     */
    showAll(): void;
    /**
     * Hide all tippies or hide all except a particular one
     * Additional hide them with duration
     *
     * @param { NgxHideAllOptions } [options] - additional hiding options
     */
    hideAll(options?: NgxHideAllOptions): void;
    /**
     * Subscription to change of tippy instances
     *
     * @returns { Observable<InstancesChanges> } observable of tippy instances change
     */
    get instancesChanges(): Observable<InstancesChanges>;
    /**
     * Service methods
     */
    setTemplateVisible(tippyContent: NgxTippyContent): void;
    private emitInstancesChange;
    private createRenderer;
    private throwError;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgxTippyService, never>;
}

//# sourceMappingURL=ngx-tippy.service.d.ts.map