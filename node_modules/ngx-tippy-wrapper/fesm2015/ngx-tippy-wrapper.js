import { isDevMode, ɵɵdefineInjectable, ɵɵinject, RendererFactory2, Injectable, Directive, ElementRef, Renderer2, Inject, PLATFORM_ID, Input, Component, ViewChild, NgModule } from '@angular/core';
import { isPlatformServer, CommonModule } from '@angular/common';
import tippy, { hideAll, createSingleton } from 'tippy.js';
import { Subject } from 'rxjs';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["contentWrapper"];
const _c1 = ["*"];
class NgxTippyService {
    constructor(rendererFactory) {
        this.tippyInstances = new Map();
        this.tippyInstances$ = new Subject();
        this.createRenderer(rendererFactory);
    }
    /**
     * Working with storage
     */
    /**
     * Write tippy instances to storage
     *
     * @param name { string } name of tippy instance
     * @param state { NgxTippyInstance } tippy instance
     */
    setInstance(name, state) {
        this.tippyInstances.set(name, state);
        this.emitInstancesChange('setInstance', name);
    }
    /**
     * Get specific tippy instance
     *
     * @param name { string } name of tippy instance
     * @returns { NgxTippyInstance | null } specific tippy instance or null
     */
    getInstance(name) {
        return this.tippyInstances.has(name) ? this.tippyInstances.get(name) : null;
    }
    /**
     * Get all tippy instances from storage
     *
     * @returns { Map<string, NgxTippyInstance> | null } all tippy instances or null
     */
    getInstances() {
        return this.tippyInstances.size ? this.tippyInstances : null;
    }
    /**
     * Working with tippy instance methods
     */
    /**
     * Programmatically show the tippy
     *
     * @param name { string } name of tippy instance
     */
    show(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).show();
        this.emitInstancesChange('show', name);
    }
    /**
     * Programmatically hide the tippy
     *
     * @param name { string } name of tippy instance
     */
    hide(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).hide();
        this.emitInstancesChange('hide', name);
    }
    /**
     * Will hide the tippy only if the cursor is outside of the tippy's interactive region
     * This allows you to programmatically hook into interactive behavior upon a mouseleave event if implementing custom event listeners
     *
     * @param name { string } name of tippy instance
     * @param name { mouseEvent } pass the mouse event object in from your event listener
     */
    hideWithInteractivity(name, mouseEvent) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).hideWithInteractivity(mouseEvent);
        this.emitInstancesChange('hideWithInteractivity', name);
    }
    /**
     * Prevent a tippy from showing or hiding
     *
     * @param name { string } name of tippy instance
     */
    disable(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).disable();
        this.emitInstancesChange('disable', name);
    }
    /**
     * Re-enable a tippy
     *
     * @param name { string } name of tippy instance
     */
    enable(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).enable();
        this.emitInstancesChange('enable', name);
    }
    /**
     * Update any tippy props
     *
     * @param name { string } name of tippy instance
     * @param tippyProps { NgxTippyProps } new props
     */
    setProps(name, tippyProps) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).setProps(tippyProps);
        this.emitInstancesChange('setProps', name);
    }
    /**
     * Update the content for tippy
     *
     * @param name { string } name of tippy instance
     * @param tippyContent { NgxTippyContent } new content
     */
    setContent(name, tippyContent) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.setTemplateVisible(tippyContent);
        this.tippyInstances.get(name).setContent(tippyContent);
        this.emitInstancesChange('setContent', name);
    }
    /**
     * The element(s) that the trigger event listeners are added to
     * Allows you to separate the tippy's positioning from its trigger source
     *
     * @param name { string } name of tippy instance
     * @param triggerTarget { Element | Element[] } element(s) that the trigger tooltip
     */
    setTriggerTarget(name, triggerTarget) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).setProps({ triggerTarget });
        this.emitInstancesChange('setTriggerTarget', name);
    }
    /**
     * Unmount the tippy from the DOM
     *
     * @param name { string } name of tippy instance
     */
    unmount(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).unmount();
        this.emitInstancesChange('unmount', name);
    }
    /**
     * Clears the instances delay timeouts
     *
     * @param name { string } name of tippy instance
     */
    clearDelayTimeouts(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).clearDelayTimeouts();
        this.emitInstancesChange('clearDelayTimeouts', name);
    }
    /**
     * Permanently destroy and clean up the tippy instance
     *
     * @param name { string } name of tippy instance
     */
    destroy(name) {
        if (!this.tippyInstances.has(name)) {
            this.throwError(`Instance with identifier '${name}' does not exist`);
        }
        this.tippyInstances.get(name).destroy();
        this.emitInstancesChange('destroy', name);
        this.tippyInstances.delete(name);
    }
    /** Working with tippy static methods */
    /**
     * Set the default props for each new tippy instance
     *
     * @param tippyProps { NgxTippyProps } default props
     */
    setDefaultProps(tippyProps) {
        tippy.setDefaultProps(tippyProps);
    }
    /**
     * Show all tippies
     */
    showAll() {
        this.tippyInstances.forEach((tippyInstance, key) => {
            tippyInstance.show();
            this.emitInstancesChange('show', key);
        });
    }
    /**
     * Hide all tippies or hide all except a particular one
     * Additional hide them with duration
     *
     * @param { NgxHideAllOptions } [options] - additional hiding options
     */
    hideAll(options) {
        const exclude = options && this.tippyInstances.has(options.excludeName) && this.tippyInstances.get(options.excludeName);
        const duration = options && options.duration;
        hideAll({ duration, exclude });
    }
    /**
     * Subscription to change of tippy instances
     *
     * @returns { Observable<InstancesChanges> } observable of tippy instances change
     */
    get instancesChanges() {
        return this.tippyInstances$.asObservable();
    }
    /**
     * Service methods
     */
    setTemplateVisible(tippyContent) {
        tippyContent instanceof Element && this.renderer.setStyle(tippyContent, 'display', 'block');
    }
    emitInstancesChange(reason, name) {
        const instance = this.tippyInstances.get(name);
        this.tippyInstances$.next({ name, reason, instance });
    }
    createRenderer(rendererFactory) {
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    throwError(message, errorConstrictor = Error) {
        if (!isDevMode())
            return;
        throw new errorConstrictor(message);
    }
}
NgxTippyService.ɵfac = function NgxTippyService_Factory(t) { return new (t || NgxTippyService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)); };
NgxTippyService.ɵprov = ɵɵdefineInjectable({ factory: function NgxTippyService_Factory() { return new NgxTippyService(ɵɵinject(RendererFactory2)); }, token: NgxTippyService, providedIn: "root" });
NgxTippyService.ctorParameters = () => [
    { type: RendererFactory2 }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.RendererFactory2 }]; }, null); })();

class NgxTippyDirective {
    constructor(tippyEl, ngxTippyService, renderer, platform) {
        this.tippyEl = tippyEl;
        this.ngxTippyService = ngxTippyService;
        this.renderer = renderer;
        this.platform = platform;
    }
    ngOnInit() {
        if (isPlatformServer(this.platform))
            return;
        this.initTippy();
    }
    /**
     * Tooltip initialize
     * Content can be directly passed through `ngxTippy` selector
     */
    initTippy() {
        if (this.ngxTippy === null || this.ngxTippy === undefined)
            return;
        const tippyTarget = this.tippyEl.nativeElement;
        const tippyTemplate = this.ngxTippy;
        tippy(tippyTarget, Object.assign(Object.assign({}, (this.tippyProps || {})), (tippyTemplate && { content: tippyTemplate })));
        this.ngxTippyService.setTemplateVisible(tippyTemplate);
        this.setTippyInstance(tippyTarget);
    }
    setTippyInstance(tippyTarget) {
        const tippyInstance = tippyTarget._tippy;
        this.writeInstancesToStorage(tippyInstance);
        this.setClassName(tippyInstance);
    }
    setClassName(tippyInstance) {
        if (!this.tippyClassName)
            return;
        const classNames = this.tippyClassName.split(' ');
        classNames.length &&
            classNames.forEach((className) => {
                this.renderer.addClass(tippyInstance.popper.firstElementChild, className);
            });
    }
    /**
     * To manipulate tooltips, write all instances to storage
     * `tippyName` used as unique key
     * If `tippyName` does not provided - it will be generated using `tippyInstance.id`
     *
     * @param tippyInstance { NgxTippyInstance }
     */
    writeInstancesToStorage(tippyInstance) {
        this.ngxTippyService.setInstance(this.tippyName || `tippy-${tippyInstance.id}`, tippyInstance);
    }
}
NgxTippyDirective.ɵfac = function NgxTippyDirective_Factory(t) { return new (t || NgxTippyDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxTippyService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
NgxTippyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxTippyDirective, selectors: [["", "ngxTippy", ""]], inputs: { ngxTippy: "ngxTippy", tippyProps: "tippyProps", tippyName: "tippyName", tippyClassName: "tippyClassName" } });
NgxTippyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxTippyService },
    { type: Renderer2 },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxTippyDirective.propDecorators = {
    ngxTippy: [{ type: Input }],
    tippyProps: [{ type: Input }],
    tippyName: [{ type: Input }],
    tippyClassName: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxTippy]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NgxTippyService }, { type: ɵngcc0.Renderer2 }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { ngxTippy: [{
            type: Input
        }], tippyProps: [{
            type: Input
        }], tippyName: [{
            type: Input
        }], tippyClassName: [{
            type: Input
        }] }); })();

/**
 * This component implements next case: different tooltip content to many different elements, while only needing to initialize once with shared props
 */
class NgxTippyGroupComponent {
    constructor(platform) {
        this.platform = platform;
    }
    ngAfterViewInit() {
        if (isPlatformServer(this.platform))
            return;
        this.setTooltips();
    }
    setTooltips() {
        const contentWrapperNativeEl = this.contentWrapper.nativeElement;
        const tooltips = Array.from(contentWrapperNativeEl.querySelectorAll('[data-grouped]'));
        this.initTippy(tooltips);
    }
    initTippy(tooltips) {
        tippy(tooltips, this.tippyProps);
    }
}
NgxTippyGroupComponent.ɵfac = function NgxTippyGroupComponent_Factory(t) { return new (t || NgxTippyGroupComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
NgxTippyGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTippyGroupComponent, selectors: [["ngx-tippy-group"]], viewQuery: function NgxTippyGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
    } }, inputs: { tippyProps: "tippyProps" }, ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["contentWrapper", ""]], template: function NgxTippyGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
NgxTippyGroupComponent.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxTippyGroupComponent.propDecorators = {
    tippyProps: [{ type: Input }],
    contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { read: ElementRef, static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyGroupComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tippy-group',
                template: `
    <div #contentWrapper>
      <ng-content></ng-content>
    </div>
  `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { tippyProps: [{
            type: Input
        }], contentWrapper: [{
            type: ViewChild,
            args: ['contentWrapper', { read: ElementRef, static: false }]
        }] }); })();

/**
 * This component implements case - singleton: single tippy element that takes the place of an array of regular tippy instances
 */
class NgxTippySingletonComponent {
    constructor(platform) {
        this.platform = platform;
    }
    ngAfterViewInit() {
        if (isPlatformServer(this.platform))
            return;
        this.setTooltips();
    }
    setTooltips() {
        const contentWrapperNativeEl = this.contentWrapper.nativeElement;
        const tooltips = Array.from(contentWrapperNativeEl.querySelectorAll('[data-singleton]'));
        this.initTippy(tooltips);
    }
    initTippy(tooltips) {
        createSingleton(tippy(tooltips), this.tippyProps);
    }
}
NgxTippySingletonComponent.ɵfac = function NgxTippySingletonComponent_Factory(t) { return new (t || NgxTippySingletonComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
NgxTippySingletonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTippySingletonComponent, selectors: [["ngx-tippy-singleton"]], viewQuery: function NgxTippySingletonComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
    } }, inputs: { tippyProps: "tippyProps" }, ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["contentWrapper", ""]], template: function NgxTippySingletonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
NgxTippySingletonComponent.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxTippySingletonComponent.propDecorators = {
    tippyProps: [{ type: Input }],
    contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { read: ElementRef, static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippySingletonComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tippy-singleton',
                template: `
    <div #contentWrapper>
      <ng-content></ng-content>
    </div>
  `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { tippyProps: [{
            type: Input
        }], contentWrapper: [{
            type: ViewChild,
            args: ['contentWrapper', { read: ElementRef, static: false }]
        }] }); })();

class NgxTippyModule {
}
NgxTippyModule.ɵfac = function NgxTippyModule_Factory(t) { return new (t || NgxTippyModule)(); };
NgxTippyModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxTippyModule });
NgxTippyModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxTippyModule, { declarations: function () { return [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent],
                exports: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent],
                providers: []
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-tippy-wrapper
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxTippyDirective, NgxTippyGroupComponent, NgxTippyModule, NgxTippyService, NgxTippySingletonComponent };

//# sourceMappingURL=ngx-tippy-wrapper.js.map