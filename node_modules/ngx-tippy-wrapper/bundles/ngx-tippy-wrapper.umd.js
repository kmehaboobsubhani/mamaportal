(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),exports, require('@angular/core'), require('@angular/common'), require('tippy.js'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-tippy-wrapper', ['@angular/core','@angular/common','exports', '@angular/core', '@angular/common', 'tippy.js', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global['ngx-tippy-wrapper'] = {}, global.ng.core, global.ng.common, global.tippy, global.rxjs));
}(this, (function (ɵngcc0,ɵngcc1,exports, i0, common, tippy, rxjs) { 
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var tippy__default = /*#__PURE__*/_interopDefaultLegacy(tippy);

    var NgxTippyService = /** @class */ (function () {
        function NgxTippyService(rendererFactory) {
            this.tippyInstances = new Map();
            this.tippyInstances$ = new rxjs.Subject();
            this.createRenderer(rendererFactory);
        }
        /**
         * Working with storage
         */
        /**
         * Write tippy instances to storage
         *
         * @param name { string } name of tippy instance
         * @param state { NgxTippyInstance } tippy instance
         */
        NgxTippyService.prototype.setInstance = function (name, state) {
            this.tippyInstances.set(name, state);
            this.emitInstancesChange('setInstance', name);
        };
        /**
         * Get specific tippy instance
         *
         * @param name { string } name of tippy instance
         * @returns { NgxTippyInstance | null } specific tippy instance or null
         */
        NgxTippyService.prototype.getInstance = function (name) {
            return this.tippyInstances.has(name) ? this.tippyInstances.get(name) : null;
        };
        /**
         * Get all tippy instances from storage
         *
         * @returns { Map<string, NgxTippyInstance> | null } all tippy instances or null
         */
        NgxTippyService.prototype.getInstances = function () {
            return this.tippyInstances.size ? this.tippyInstances : null;
        };
        /**
         * Working with tippy instance methods
         */
        /**
         * Programmatically show the tippy
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.show = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).show();
            this.emitInstancesChange('show', name);
        };
        /**
         * Programmatically hide the tippy
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.hide = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).hide();
            this.emitInstancesChange('hide', name);
        };
        /**
         * Will hide the tippy only if the cursor is outside of the tippy's interactive region
         * This allows you to programmatically hook into interactive behavior upon a mouseleave event if implementing custom event listeners
         *
         * @param name { string } name of tippy instance
         * @param name { mouseEvent } pass the mouse event object in from your event listener
         */
        NgxTippyService.prototype.hideWithInteractivity = function (name, mouseEvent) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).hideWithInteractivity(mouseEvent);
            this.emitInstancesChange('hideWithInteractivity', name);
        };
        /**
         * Prevent a tippy from showing or hiding
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.disable = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).disable();
            this.emitInstancesChange('disable', name);
        };
        /**
         * Re-enable a tippy
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.enable = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).enable();
            this.emitInstancesChange('enable', name);
        };
        /**
         * Update any tippy props
         *
         * @param name { string } name of tippy instance
         * @param tippyProps { NgxTippyProps } new props
         */
        NgxTippyService.prototype.setProps = function (name, tippyProps) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).setProps(tippyProps);
            this.emitInstancesChange('setProps', name);
        };
        /**
         * Update the content for tippy
         *
         * @param name { string } name of tippy instance
         * @param tippyContent { NgxTippyContent } new content
         */
        NgxTippyService.prototype.setContent = function (name, tippyContent) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.setTemplateVisible(tippyContent);
            this.tippyInstances.get(name).setContent(tippyContent);
            this.emitInstancesChange('setContent', name);
        };
        /**
         * The element(s) that the trigger event listeners are added to
         * Allows you to separate the tippy's positioning from its trigger source
         *
         * @param name { string } name of tippy instance
         * @param triggerTarget { Element | Element[] } element(s) that the trigger tooltip
         */
        NgxTippyService.prototype.setTriggerTarget = function (name, triggerTarget) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).setProps({ triggerTarget: triggerTarget });
            this.emitInstancesChange('setTriggerTarget', name);
        };
        /**
         * Unmount the tippy from the DOM
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.unmount = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).unmount();
            this.emitInstancesChange('unmount', name);
        };
        /**
         * Clears the instances delay timeouts
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.clearDelayTimeouts = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).clearDelayTimeouts();
            this.emitInstancesChange('clearDelayTimeouts', name);
        };
        /**
         * Permanently destroy and clean up the tippy instance
         *
         * @param name { string } name of tippy instance
         */
        NgxTippyService.prototype.destroy = function (name) {
            if (!this.tippyInstances.has(name)) {
                this.throwError("Instance with identifier '" + name + "' does not exist");
            }
            this.tippyInstances.get(name).destroy();
            this.emitInstancesChange('destroy', name);
            this.tippyInstances.delete(name);
        };
        /** Working with tippy static methods */
        /**
         * Set the default props for each new tippy instance
         *
         * @param tippyProps { NgxTippyProps } default props
         */
        NgxTippyService.prototype.setDefaultProps = function (tippyProps) {
            tippy__default['default'].setDefaultProps(tippyProps);
        };
        /**
         * Show all tippies
         */
        NgxTippyService.prototype.showAll = function () {
            var _this = this;
            this.tippyInstances.forEach(function (tippyInstance, key) {
                tippyInstance.show();
                _this.emitInstancesChange('show', key);
            });
        };
        /**
         * Hide all tippies or hide all except a particular one
         * Additional hide them with duration
         *
         * @param { NgxHideAllOptions } [options] - additional hiding options
         */
        NgxTippyService.prototype.hideAll = function (options) {
            var exclude = options && this.tippyInstances.has(options.excludeName) && this.tippyInstances.get(options.excludeName);
            var duration = options && options.duration;
            tippy.hideAll({ duration: duration, exclude: exclude });
        };
        Object.defineProperty(NgxTippyService.prototype, "instancesChanges", {
            /**
             * Subscription to change of tippy instances
             *
             * @returns { Observable<InstancesChanges> } observable of tippy instances change
             */
            get: function () {
                return this.tippyInstances$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Service methods
         */
        NgxTippyService.prototype.setTemplateVisible = function (tippyContent) {
            tippyContent instanceof Element && this.renderer.setStyle(tippyContent, 'display', 'block');
        };
        NgxTippyService.prototype.emitInstancesChange = function (reason, name) {
            var instance = this.tippyInstances.get(name);
            this.tippyInstances$.next({ name: name, reason: reason, instance: instance });
        };
        NgxTippyService.prototype.createRenderer = function (rendererFactory) {
            this.renderer = rendererFactory.createRenderer(null, null);
        };
        NgxTippyService.prototype.throwError = function (message, errorConstrictor) {
            if (errorConstrictor === void 0) { errorConstrictor = Error; }
            if (!i0.isDevMode())
                return;
            throw new errorConstrictor(message);
        };
NgxTippyService.ɵfac = function NgxTippyService_Factory(t) { return new (t || NgxTippyService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)); };
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyService, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.RendererFactory2 }]; }, null); })();
        return NgxTippyService;
    }());
    NgxTippyService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxTippyService_Factory() { return new NgxTippyService(i0.ɵɵinject(i0.RendererFactory2)); }, token: NgxTippyService, providedIn: "root" });
    NgxTippyService.ctorParameters = function () { return [
        { type: i0.RendererFactory2 }
    ]; };

    var NgxTippyDirective = /** @class */ (function () {
        function NgxTippyDirective(tippyEl, ngxTippyService, renderer, platform) {
            this.tippyEl = tippyEl;
            this.ngxTippyService = ngxTippyService;
            this.renderer = renderer;
            this.platform = platform;
        }
        NgxTippyDirective.prototype.ngOnInit = function () {
            if (common.isPlatformServer(this.platform))
                return;
            this.initTippy();
        };
        /**
         * Tooltip initialize
         * Content can be directly passed through `ngxTippy` selector
         */
        NgxTippyDirective.prototype.initTippy = function () {
            if (this.ngxTippy === null || this.ngxTippy === undefined)
                return;
            var tippyTarget = this.tippyEl.nativeElement;
            var tippyTemplate = this.ngxTippy;
            tippy__default['default'](tippyTarget, Object.assign(Object.assign({}, (this.tippyProps || {})), (tippyTemplate && { content: tippyTemplate })));
            this.ngxTippyService.setTemplateVisible(tippyTemplate);
            this.setTippyInstance(tippyTarget);
        };
        NgxTippyDirective.prototype.setTippyInstance = function (tippyTarget) {
            var tippyInstance = tippyTarget._tippy;
            this.writeInstancesToStorage(tippyInstance);
            this.setClassName(tippyInstance);
        };
        NgxTippyDirective.prototype.setClassName = function (tippyInstance) {
            var _this = this;
            if (!this.tippyClassName)
                return;
            var classNames = this.tippyClassName.split(' ');
            classNames.length &&
                classNames.forEach(function (className) {
                    _this.renderer.addClass(tippyInstance.popper.firstElementChild, className);
                });
        };
        /**
         * To manipulate tooltips, write all instances to storage
         * `tippyName` used as unique key
         * If `tippyName` does not provided - it will be generated using `tippyInstance.id`
         *
         * @param tippyInstance { NgxTippyInstance }
         */
        NgxTippyDirective.prototype.writeInstancesToStorage = function (tippyInstance) {
            this.ngxTippyService.setInstance(this.tippyName || "tippy-" + tippyInstance.id, tippyInstance);
        };
NgxTippyDirective.ɵfac = function NgxTippyDirective_Factory(t) { return new (t || NgxTippyDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxTippyService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(i0.PLATFORM_ID)); };
NgxTippyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxTippyDirective, selectors: [["", "ngxTippy", ""]], inputs: { ngxTippy: "ngxTippy", tippyProps: "tippyProps", tippyName: "tippyName", tippyClassName: "tippyClassName" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyDirective, [{
        type: i0.Directive,
        args: [{
                selector: '[ngxTippy]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NgxTippyService }, { type: ɵngcc0.Renderer2 }, { type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, { ngxTippy: [{
            type: i0.Input
        }], tippyProps: [{
            type: i0.Input
        }], tippyName: [{
            type: i0.Input
        }], tippyClassName: [{
            type: i0.Input
        }] }); })();
        return NgxTippyDirective;
    }());
    NgxTippyDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgxTippyService },
        { type: i0.Renderer2 },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    NgxTippyDirective.propDecorators = {
        ngxTippy: [{ type: i0.Input }],
        tippyProps: [{ type: i0.Input }],
        tippyName: [{ type: i0.Input }],
        tippyClassName: [{ type: i0.Input }]
    };

    /**
     * This component implements next case: different tooltip content to many different elements, while only needing to initialize once with shared props
     */
    var NgxTippyGroupComponent = /** @class */ (function () {
        function NgxTippyGroupComponent(platform) {
            this.platform = platform;
        }
        NgxTippyGroupComponent.prototype.ngAfterViewInit = function () {
            if (common.isPlatformServer(this.platform))
                return;
            this.setTooltips();
        };
        NgxTippyGroupComponent.prototype.setTooltips = function () {
            var contentWrapperNativeEl = this.contentWrapper.nativeElement;
            var tooltips = Array.from(contentWrapperNativeEl.querySelectorAll('[data-grouped]'));
            this.initTippy(tooltips);
        };
        NgxTippyGroupComponent.prototype.initTippy = function (tooltips) {
            tippy__default['default'](tooltips, this.tippyProps);
        };
NgxTippyGroupComponent.ɵfac = function NgxTippyGroupComponent_Factory(t) { return new (t || NgxTippyGroupComponent)(ɵngcc0.ɵɵdirectiveInject(i0.PLATFORM_ID)); };
NgxTippyGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTippyGroupComponent, selectors: [["ngx-tippy-group"]], viewQuery: function NgxTippyGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1, i0.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
    } }, inputs: { tippyProps: "tippyProps" }, ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["contentWrapper", ""]], template: function NgxTippyGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyGroupComponent, [{
        type: i0.Component,
        args: [{
                selector: 'ngx-tippy-group',
                template: "\n    <div #contentWrapper>\n      <ng-content></ng-content>\n    </div>\n  "
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, { tippyProps: [{
            type: i0.Input
        }], contentWrapper: [{
            type: i0.ViewChild,
            args: ['contentWrapper', { read: i0.ElementRef, static: false }]
        }] }); })();
        return NgxTippyGroupComponent;
    }());
    NgxTippyGroupComponent.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    NgxTippyGroupComponent.propDecorators = {
        tippyProps: [{ type: i0.Input }],
        contentWrapper: [{ type: i0.ViewChild, args: ['contentWrapper', { read: i0.ElementRef, static: false },] }]
    };

    /**
     * This component implements case - singleton: single tippy element that takes the place of an array of regular tippy instances
     */
    var NgxTippySingletonComponent = /** @class */ (function () {
        function NgxTippySingletonComponent(platform) {
            this.platform = platform;
        }
        NgxTippySingletonComponent.prototype.ngAfterViewInit = function () {
            if (common.isPlatformServer(this.platform))
                return;
            this.setTooltips();
        };
        NgxTippySingletonComponent.prototype.setTooltips = function () {
            var contentWrapperNativeEl = this.contentWrapper.nativeElement;
            var tooltips = Array.from(contentWrapperNativeEl.querySelectorAll('[data-singleton]'));
            this.initTippy(tooltips);
        };
        NgxTippySingletonComponent.prototype.initTippy = function (tooltips) {
            tippy.createSingleton(tippy__default['default'](tooltips), this.tippyProps);
        };
NgxTippySingletonComponent.ɵfac = function NgxTippySingletonComponent_Factory(t) { return new (t || NgxTippySingletonComponent)(ɵngcc0.ɵɵdirectiveInject(i0.PLATFORM_ID)); };
NgxTippySingletonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTippySingletonComponent, selectors: [["ngx-tippy-singleton"]], viewQuery: function NgxTippySingletonComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1, i0.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
    } }, inputs: { tippyProps: "tippyProps" }, ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["contentWrapper", ""]], template: function NgxTippySingletonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippySingletonComponent, [{
        type: i0.Component,
        args: [{
                selector: 'ngx-tippy-singleton',
                template: "\n    <div #contentWrapper>\n      <ng-content></ng-content>\n    </div>\n  "
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, { tippyProps: [{
            type: i0.Input
        }], contentWrapper: [{
            type: i0.ViewChild,
            args: ['contentWrapper', { read: i0.ElementRef, static: false }]
        }] }); })();
        return NgxTippySingletonComponent;
    }());
    NgxTippySingletonComponent.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    NgxTippySingletonComponent.propDecorators = {
        tippyProps: [{ type: i0.Input }],
        contentWrapper: [{ type: i0.ViewChild, args: ['contentWrapper', { read: i0.ElementRef, static: false },] }]
    };

    var NgxTippyModule = /** @class */ (function () {
        function NgxTippyModule() {
        }
NgxTippyModule.ɵfac = function NgxTippyModule_Factory(t) { return new (t || NgxTippyModule)(); };
NgxTippyModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxTippyModule });
NgxTippyModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxTippyModule, { declarations: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent], imports: [ɵngcc1.CommonModule], exports: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxTippyModule, [{
        type: i0.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent],
                exports: [NgxTippyDirective, NgxTippyGroupComponent, NgxTippySingletonComponent],
                providers: []
            }]
    }], function () { return []; }, null); })();
        return NgxTippyModule;
    }());

    /*
     * Public API Surface of ngx-tippy-wrapper
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgxTippyDirective = NgxTippyDirective;
    exports.NgxTippyGroupComponent = NgxTippyGroupComponent;
    exports.NgxTippyModule = NgxTippyModule;
    exports.NgxTippyService = NgxTippyService;
    exports.NgxTippySingletonComponent = NgxTippySingletonComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-tippy-wrapper.umd.js.map