import { Component, HostBinding, Input } from '@angular/core';
import classNames from 'classnames';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export class WrapperComponent {
    constructor() {
        this.fluid = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'c-wrapper': true,
            'c-wrapper-fluid': !!this.fluid
        });
        return classes;
    }
}
WrapperComponent.ɵfac = function WrapperComponent_Factory(t) { return new (t || WrapperComponent)(); };
WrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WrapperComponent, selectors: [["c-wrapper"], ["", "c-wrapper", ""]], hostVars: 2, hostBindings: function WrapperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { fluid: "fluid" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function WrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
WrapperComponent.propDecorators = {
    fluid: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WrapperComponent, [{
        type: Component,
        args: [{
                selector: 'c-wrapper, [c-wrapper]',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { fluid: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JhcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmV1aS1hbmd1bGFyL3NyYy9saWIvbGF5b3V0L3dyYXBwZXIvd3JhcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sVUFBVSxNQUFNLFlBQVksQ0FBQzs7OztBQU1wQyxNQUFNLE9BQU8sZ0JBQWdCO0FBRTdCLElBTkE7QUFDSSxRQUtPLFVBQUssR0FBRyxLQUFLLENBQUM7QUFFekIsSUFlQSxDQUFDO0FBQ0EsSUFoQkMsSUFDSSxVQUFVO0FBQ2YsUUFBRyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDM0IsSUFBQyxDQUFDO0FBRUgsSUFBRSxJQUFJLFdBQVc7QUFFakIsUUFBSSxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQ3hCO0FBQ0wsWUFBTyxXQUFXLEVBQUUsSUFBSTtBQUN4QixZQUFPLGlCQUFpQixFQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSztBQUN2QyxTQUFNLENBQ0YsQ0FBQztBQUNMLFFBQUcsT0FBTyxPQUFPLENBQUM7QUFDbEIsSUFBQyxDQUFDO0FBQ0Y7OENBdkJBLFNBQVMsU0FBQyxtQkFDVCxRQUFRLEVBQUU7YUFBd0IsbUJBQ2xDLFFBQVEsRUFBRSwyQkFBMkIsZUFDdEM7Ozs7OzZCQUNLO0FBQUU7QUFFSSxvQkFBVCxLQUFLO0FBQU0seUJBRVgsV0FBVyxTQUFDLE9BQU87QUFDakI7Ozs7Ozs7Ozs7Ozs7QUFaQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFNQSxBQUFBLEFBQUEsQUFBQSxBQUpBLEFBTUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQWlCQSxBQUFBLEFBZkEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQXRCQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFHQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLXdyYXBwZXIsIFtjLXdyYXBwZXJdJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlckNvbXBvbmVudCB7XG5cbiAgQElucHV0KCkgZmx1aWQgPSBmYWxzZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgZ2V0IGdldENsYXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdENsYXNzZXM7XG4gIH1cblxuICBnZXQgaG9zdENsYXNzZXMoKSB7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lcyhcbiAgICAgIHtcbiAgICAgICAgJ2Mtd3JhcHBlcic6IHRydWUsXG4gICAgICAgICdjLXdyYXBwZXItZmx1aWQnIDogISF0aGlzLmZsdWlkXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIGNsYXNzZXM7XG4gIH1cbn1cbiJdfQ==