import { Component, HostBinding, Input } from '@angular/core';
import classNames from 'classnames';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export class CardBodyComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-body': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) { return new (t || CardBodyComponent)(); };
CardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardBodyComponent, selectors: [["c-card-body"], ["", "c-card-body", ""]], hostVars: 2, hostBindings: function CardBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { align: "align", color: "color", borderColor: "borderColor", textColor: "textColor" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardBodyComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-body, [c-card-body]',
                template: '<ng-content></ng-content>'
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], align: [{
            type: Input
        }], color: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }] }); })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZC1ib2R5LmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJkL2NhcmQtYm9keS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sVUFBVSxNQUFNLFlBQVksQ0FBQzs7OztBQU1wQyxNQUFNLE9BQU8saUJBQWlCO0FBRTlCLElBS0UsSUFDSSxVQUFVO0FBQ2YsUUFBRyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDM0IsSUFBQyxDQUFDO0FBRUgsSUFBRSxJQUFJLFdBQVc7QUFFakIsUUFBSSxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQ3hCO0FBQ0wsWUFBTyxXQUFXLEVBQUUsSUFBSTtBQUN4QixZQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSztBQUN2QyxZQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVztBQUN2RCxZQUFPLENBQUMsUUFBUSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUztBQUNqRCxZQUFPLENBQUMsUUFBUSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSztBQUN6QyxTQUFNLENBQ0YsQ0FBQztBQUNMLFFBQUcsT0FBTyxPQUFPLENBQUM7QUFDbEIsSUFBQyxDQUFDO0FBQ0Y7K0NBN0JBLFNBQVMsU0FBQyxtQkFDVCxRQUFRLEVBQUU7ZUFBNEIsbUJBQ3RDLFFBQVEsRUFBRSwyQkFBMkIsZUFDdEM7Ozs7OzZCQUNLO0FBQUU7QUFFSSxvQkFBVCxLQUFLO0FBQU0sb0JBQ1gsS0FBSztBQUFNLDBCQUNYLEtBQUs7QUFBTSx3QkFDWCxLQUFLO0FBQU0seUJBRVgsV0FBVyxTQUFDLE9BQU87QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFmQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFNQSxBQUFBLEFBQUEsQUFBQSxBQU9BLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQTVCQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFHQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLWNhcmQtYm9keSwgW2MtY2FyZC1ib2R5XScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZEJvZHlDb21wb25lbnQge1xuXG4gIEBJbnB1dCgpIGFsaWduOiAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCc7XG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGJvcmRlckNvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHRleHRDb2xvcjogc3RyaW5nO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICBnZXQgZ2V0Q2xhc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ob3N0Q2xhc3NlcztcbiAgfVxuXG4gIGdldCBob3N0Q2xhc3NlcygpIHtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKFxuICAgICAge1xuICAgICAgICAnY2FyZC1ib2R5JzogdHJ1ZSxcbiAgICAgICAgW2BiZy0ke3RoaXMuY29sb3J9YF06IHRoaXMuY29sb3IsXG4gICAgICAgIFtgYm9yZGVyLSR7dGhpcy5ib3JkZXJDb2xvcn1gXTogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgICAgW2B0ZXh0LSR7dGhpcy50ZXh0Q29sb3J9YF06IHRoaXMudGV4dENvbG9yLFxuICAgICAgICBbYHRleHQtJHt0aGlzLmFsaWdufWBdOiB0aGlzLmFsaWduXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIGNsYXNzZXM7XG4gIH1cbn1cbiJdfQ==