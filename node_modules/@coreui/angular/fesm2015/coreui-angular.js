import { Component, HostBinding, Inject, Input, NgModule, EventEmitter, Directive, ElementRef, Output, SecurityContext, Renderer2, ɵɵdefineInjectable, ɵɵinject, Injectable, Host, HostListener, forwardRef, ChangeDetectorRef, Optional, NgZone, ViewChild, ContentChildren, ContentChild, RendererFactory2, Pipe, ViewContainerRef, ComponentFactoryResolver } from '@angular/core';
import { CommonModule, DOCUMENT } from '@angular/common';
import classNames from 'classnames';
import { animation, style, animate, useAnimation, AnimationBuilder, trigger, state, transition, group, query } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { NavigationEnd, Router, ActivatedRoute, RouterModule } from '@angular/router';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { BaseChartDirective, ThemeService } from 'ng2-charts';
import { BreakpointObserver } from '@angular/cdk/layout';
import { Platform } from '@angular/cdk/platform';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';
import * as ɵngcc2 from '@angular/platform-browser';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@angular/router';
import * as ɵngcc5 from 'ng2-charts';
import * as ɵngcc6 from '@angular/cdk/layout';
import * as ɵngcc7 from '@angular/cdk/platform';

const _c0 = ["*"];
const _c1 = [[["", "c-accordion-header", ""]], "*"];
const _c2 = ["[c-accordion-header]", "*"];
function AlertComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function AlertComponent_ng_template_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onClose(); });
    ɵngcc0.ɵɵelement(1, "span", 2);
    ɵngcc0.ɵɵelementStart(2, "span", 3);
    ɵngcc0.ɵɵtext(3, "Close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r0.safeIcon, ɵngcc0.ɵɵsanitizeHtml);
} }
function BreadcrumbComponent_ng_template_1_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵi18n(2, 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const breadcrumb_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("routerLink", breadcrumb_r1.url)("cHtmlAttr", breadcrumb_r1.attributes)("target", breadcrumb_r1.attributes == null ? null : breadcrumb_r1.attributes.target)("queryParams", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.queryParams)("fragment", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.fragment)("queryParamsHandling", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.queryParamsHandling)("preserveFragment", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.preserveFragment)("skipLocationChange", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.skipLocationChange)("replaceUrl", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.replaceUrl)("state", breadcrumb_r1.linkProps == null ? null : breadcrumb_r1.linkProps.state);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵi18nExp(breadcrumb_r1.label);
    ɵngcc0.ɵɵi18nApply(2);
} }
function BreadcrumbComponent_ng_template_1_ng_container_0_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.divider, " ");
} }
function BreadcrumbComponent_ng_template_1_ng_container_0_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵi18n(1, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const breadcrumb_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("cHtmlAttr", breadcrumb_r1.attributes);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵi18nExp(breadcrumb_r1.label);
    ɵngcc0.ɵɵi18nApply(1);
} }
function BreadcrumbComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, BreadcrumbComponent_ng_template_1_ng_container_0_div_1_Template, 3, 11, "div", 2);
    ɵngcc0.ɵɵtemplate(2, BreadcrumbComponent_ng_template_1_ng_container_0_span_2_Template, 2, 1, "span", 1);
    ɵngcc0.ɵɵtemplate(3, BreadcrumbComponent_ng_template_1_ng_container_0_span_3_Template, 2, 2, "span", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r2 = ɵngcc0.ɵɵnextContext().last;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2 && ctx_r3.divider);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", last_r2);
} }
function BreadcrumbComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, BreadcrumbComponent_ng_template_1_ng_container_0_Template, 4, 3, "ng-container", 1);
} if (rf & 2) {
    const breadcrumb_r1 = ctx.$implicit;
    const last_r2 = ctx.last;
    ɵngcc0.ɵɵproperty("ngIf", breadcrumb_r1.label && (breadcrumb_r1.url.slice(-1) == "/" || last_r2));
} }
const _c7 = ["content"];
function CarouselControlComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", null, 2);
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
} }
function CarouselControlComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span");
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r2.carouselControlIconClass);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.direction);
} }
const _c8 = function (a0) { return { active: a0 }; };
function CarouselIndicatorsComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "li", 2);
    ɵngcc0.ɵɵlistener("click", function CarouselIndicatorsComponent_ng_container_1_Template_li_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r4); const i_r2 = ctx.index; const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onClick(i_r2); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ɵngcc0.ɵɵpureFunction1(2, _c8, ctx_r0.active === i_r2));
} }
function CarouselItemComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "active"]);
} }
const _c9 = [[["iframe"]]];
const _c10 = ["iframe"];
const _c11 = "[_nghost-%COMP%]     .btn:not(:hover):not(:focus){box-shadow:none!important}";
function HeaderBrandComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function HeaderBrandComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
const _c12 = ["*", "*"];
const _c13 = ["modalHeader"];
const _c14 = ["modalBody"];
const _c15 = ["modalFooter"];
function ModalComponent_div_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 11);
} }
function ModalComponent_div_0_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ModalComponent_div_0_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function ModalComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵelementStart(3, "div", 5);
    ɵngcc0.ɵɵtemplate(4, ModalComponent_div_0_ng_container_4_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementStart(5, "button", 7);
    ɵngcc0.ɵɵlistener("click", function ModalComponent_div_0_Template_button_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.hide(); });
    ɵngcc0.ɵɵtext(6, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "div", 8);
    ɵngcc0.ɵɵtemplate(8, ModalComponent_div_0_ng_container_8_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 10);
    ɵngcc0.ɵɵtemplate(10, ModalComponent_div_0_ng_container_10_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("show", ctx_r0.visibleAnimate);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.modalClasses);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.dialogClasses);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.header);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.body);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.footer);
} }
function ModalComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 12);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.backdropClasses);
} }
function SidebarBrandComponent_ng_template_1_img_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 3);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("cHtmlAttr", ctx_r2.brandFull)("ngClass", "c-sidebar-brand-full");
} }
function SidebarBrandComponent_ng_template_1_img_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 3);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("cHtmlAttr", ctx_r3.brandMinimized)("ngClass", "c-sidebar-brand-minimized");
} }
function SidebarBrandComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, SidebarBrandComponent_ng_template_1_img_0_Template, 1, 2, "img", 2);
    ɵngcc0.ɵɵtemplate(1, SidebarBrandComponent_ng_template_1_img_1_Template, 1, 2, "img", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.brandFull);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.brandMinimized);
} }
function SidebarBrandComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 4);
    ɵngcc0.ɵɵelement(1, "div", 5);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.brandText.text, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.brandText.icon, ɵngcc0.ɵɵsanitizeHtml);
} }
function SidebarNavComponent_ng_container_0_c_sidebar_nav_dropdown_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-dropdown", 6);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, item_r1));
} }
function SidebarNavComponent_ng_container_0_c_sidebar_nav_divider_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-divider", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 3, item_r1))("cHtmlAttr", item_r1.attributes);
} }
function SidebarNavComponent_ng_container_0_c_sidebar_nav_title_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-title", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 3, item_r1))("cHtmlAttr", item_r1.attributes);
} }
function SidebarNavComponent_ng_container_0_c_sidebar_nav_label_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-label", 6);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, item_r1));
} }
function SidebarNavComponent_ng_container_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "c-sidebar-nav-link", 8);
    ɵngcc0.ɵɵlistener("linkClick", function SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template_c_sidebar_nav_link_linkClick_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.hideMobile(); });
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, item_r1));
} }
function SidebarNavComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainerStart(1, 1);
    ɵngcc0.ɵɵtemplate(2, SidebarNavComponent_ng_container_0_c_sidebar_nav_dropdown_2_Template, 2, 4, "c-sidebar-nav-dropdown", 2);
    ɵngcc0.ɵɵtemplate(3, SidebarNavComponent_ng_container_0_c_sidebar_nav_divider_3_Template, 2, 5, "c-sidebar-nav-divider", 3);
    ɵngcc0.ɵɵtemplate(4, SidebarNavComponent_ng_container_0_c_sidebar_nav_title_4_Template, 2, 5, "c-sidebar-nav-title", 3);
    ɵngcc0.ɵɵtemplate(5, SidebarNavComponent_ng_container_0_c_sidebar_nav_label_5_Template, 2, 4, "c-sidebar-nav-label", 2);
    ɵngcc0.ɵɵtemplate(6, SidebarNavComponent_ng_container_0_ng_container_6_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(7, SidebarNavComponent_ng_container_0_c_sidebar_nav_link_7_Template, 2, 4, "c-sidebar-nav-link", 5);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.helper.itemType(item_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "dropdown");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "divider");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "title");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "label");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "empty");
} }
function SidebarNavDropdownComponent_i_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 3);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r0.item));
} }
function SidebarNavDropdownComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavBadge");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r1.item));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.item.badge.text);
} }
function SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_dropdown_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-dropdown", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("c-show", ctx_r2.helper.isActive(ctx_r2.router, item_r1));
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 4, item_r1));
} }
function SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_divider_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-divider", 8);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 3, item_r1))("cHtmlAttr", item_r1.attributes);
} }
function SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_title_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-title", 8);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 3, item_r1))("cHtmlAttr", item_r1.attributes);
} }
function SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_label_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-label", 9);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, item_r1));
} }
function SidebarNavItemsComponent_ng_container_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_link_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "c-sidebar-nav-link", 9);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavItemClass");
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1)("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, item_r1));
} }
function SidebarNavItemsComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainerStart(1, 1);
    ɵngcc0.ɵɵtemplate(2, SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_dropdown_2_Template, 2, 6, "c-sidebar-nav-dropdown", 2);
    ɵngcc0.ɵɵtemplate(3, SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_divider_3_Template, 2, 5, "c-sidebar-nav-divider", 3);
    ɵngcc0.ɵɵtemplate(4, SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_title_4_Template, 2, 5, "c-sidebar-nav-title", 3);
    ɵngcc0.ɵɵtemplate(5, SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_label_5_Template, 2, 4, "c-sidebar-nav-label", 4);
    ɵngcc0.ɵɵtemplate(6, SidebarNavItemsComponent_ng_container_0_ng_container_6_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵtemplate(7, SidebarNavItemsComponent_ng_container_0_c_sidebar_nav_link_7_Template, 2, 4, "c-sidebar-nav-link", 6);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.helper.itemType(item_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "dropdown");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "divider");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "title");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "label");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "empty");
} }
function SidebarNavLinkContentComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainerStart(1);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.item.name);
} }
function SidebarNavLinkComponent_a_1_i_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r3.item));
} }
function SidebarNavLinkComponent_a_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r4.item));
} }
function SidebarNavLinkComponent_a_1_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavBadge");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r5.item));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.item.badge == null ? null : ctx_r5.item.badge.text);
} }
function SidebarNavLinkComponent_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavLink");
    ɵngcc0.ɵɵtemplate(2, SidebarNavLinkComponent_a_1_i_2_Template, 2, 3, "i", 5);
    ɵngcc0.ɵɵtemplate(3, SidebarNavLinkComponent_a_1_span_3_Template, 2, 3, "span", 5);
    ɵngcc0.ɵɵelement(4, "c-sidebar-nav-link-content", 6);
    ɵngcc0.ɵɵtemplate(5, SidebarNavLinkComponent_a_1_span_5_Template, 3, 4, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 6, ctx_r0.item))("cHtmlAttr", ctx_r0.item.attributes);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.item == null ? null : ctx_r0.item.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r0.item == null ? null : ctx_r0.item.icon));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("item", ctx_r0.item);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.item.badge);
} }
function SidebarNavLinkComponent_a_2_i_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r6.item));
} }
function SidebarNavLinkComponent_a_2_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r7.item));
} }
function SidebarNavLinkComponent_a_2_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavBadge");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r8.item));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r8.item.badge == null ? null : ctx_r8.item.badge.text);
} }
function SidebarNavLinkComponent_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵlistener("click", function SidebarNavLinkComponent_a_2_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.linkClicked(); });
    ɵngcc0.ɵɵpipe(1, "cSidebarNavLink");
    ɵngcc0.ɵɵtemplate(2, SidebarNavLinkComponent_a_2_i_2_Template, 2, 3, "i", 5);
    ɵngcc0.ɵɵtemplate(3, SidebarNavLinkComponent_a_2_span_3_Template, 2, 3, "span", 5);
    ɵngcc0.ɵɵelement(4, "c-sidebar-nav-link-content", 6);
    ɵngcc0.ɵɵtemplate(5, SidebarNavLinkComponent_a_2_span_5_Template, 3, 4, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 7, ctx_r1.item))("href", ctx_r1.href, ɵngcc0.ɵɵsanitizeUrl)("cHtmlAttr", ctx_r1.item.attributes);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.item == null ? null : ctx_r1.item.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r1.item == null ? null : ctx_r1.item.icon));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("item", ctx_r1.item);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.item.badge);
} }
function SidebarNavLinkComponent_a_3_i_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r11.item));
} }
function SidebarNavLinkComponent_a_3_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavIcon");
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r12.item));
} }
function SidebarNavLinkComponent_a_3_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavBadge");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r13.item));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r13.item.badge == null ? null : ctx_r13.item.badge.text);
} }
function SidebarNavLinkComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 9);
    ɵngcc0.ɵɵlistener("click", function SidebarNavLinkComponent_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.linkClicked(); });
    ɵngcc0.ɵɵpipe(1, "cSidebarNavLink");
    ɵngcc0.ɵɵtemplate(2, SidebarNavLinkComponent_a_3_i_2_Template, 2, 3, "i", 5);
    ɵngcc0.ɵɵtemplate(3, SidebarNavLinkComponent_a_3_span_3_Template, 2, 3, "span", 5);
    ɵngcc0.ɵɵelement(4, "c-sidebar-nav-link-content", 6);
    ɵngcc0.ɵɵtemplate(5, SidebarNavLinkComponent_a_3_span_5_Template, 3, 4, "span", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("c-active", ctx_r2.linkActive);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 17, ctx_r2.item))("cHtmlAttr", ctx_r2.item.attributes)("target", ctx_r2.item.attributes == null ? null : ctx_r2.item.attributes.target)("queryParams", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.queryParams)("fragment", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.fragment)("queryParamsHandling", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.queryParamsHandling)("preserveFragment", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.preserveFragment)("skipLocationChange", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.skipLocationChange)("replaceUrl", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.replaceUrl)("state", ctx_r2.item.linkProps == null ? null : ctx_r2.item.linkProps.state)("routerLink", ctx_r2.item.url);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.item == null ? null : ctx_r2.item.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r2.item == null ? null : ctx_r2.item.icon));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("item", ctx_r2.item);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.item.badge);
} }
function SidebarNavLabelComponent_i_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "i", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.getLabelIconClass());
} }
function SidebarNavLabelComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵpipe(1, "cSidebarNavBadge");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r1.item));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.item.badge.text);
} }
function SpinkitComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function SpinkitComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 3);
    ɵngcc0.ɵɵelement(2, "div", 3);
    ɵngcc0.ɵɵelement(3, "div", 3);
    ɵngcc0.ɵɵelement(4, "div", 3);
    ɵngcc0.ɵɵelement(5, "div", 3);
    ɵngcc0.ɵɵelement(6, "div", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 4);
    ɵngcc0.ɵɵelement(2, "div", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 5);
    ɵngcc0.ɵɵelement(2, "div", 5);
    ɵngcc0.ɵɵelement(3, "div", 5);
    ɵngcc0.ɵɵelement(4, "div", 5);
    ɵngcc0.ɵɵelement(5, "div", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function SpinkitComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 6);
    ɵngcc0.ɵɵelement(2, "div", 6);
    ɵngcc0.ɵɵelement(3, "div", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 7);
    ɵngcc0.ɵɵelement(2, "div", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 8);
    ɵngcc0.ɵɵelement(2, "div", 8);
    ɵngcc0.ɵɵelement(3, "div", 8);
    ɵngcc0.ɵɵelement(4, "div", 8);
    ɵngcc0.ɵɵelement(5, "div", 8);
    ɵngcc0.ɵɵelement(6, "div", 8);
    ɵngcc0.ɵɵelement(7, "div", 8);
    ɵngcc0.ɵɵelement(8, "div", 8);
    ɵngcc0.ɵɵelement(9, "div", 8);
    ɵngcc0.ɵɵelement(10, "div", 8);
    ɵngcc0.ɵɵelement(11, "div", 8);
    ɵngcc0.ɵɵelement(12, "div", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 9);
    ɵngcc0.ɵɵelement(2, "div", 9);
    ɵngcc0.ɵɵelement(3, "div", 9);
    ɵngcc0.ɵɵelement(4, "div", 9);
    ɵngcc0.ɵɵelement(5, "div", 9);
    ɵngcc0.ɵɵelement(6, "div", 9);
    ɵngcc0.ɵɵelement(7, "div", 9);
    ɵngcc0.ɵɵelement(8, "div", 9);
    ɵngcc0.ɵɵelement(9, "div", 9);
    ɵngcc0.ɵɵelement(10, "div", 9);
    ɵngcc0.ɵɵelement(11, "div", 9);
    ɵngcc0.ɵɵelement(12, "div", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 10);
    ɵngcc0.ɵɵelement(2, "div", 10);
    ɵngcc0.ɵɵelement(3, "div", 10);
    ɵngcc0.ɵɵelement(4, "div", 10);
    ɵngcc0.ɵɵelement(5, "div", 10);
    ɵngcc0.ɵɵelement(6, "div", 10);
    ɵngcc0.ɵɵelement(7, "div", 10);
    ɵngcc0.ɵɵelement(8, "div", 10);
    ɵngcc0.ɵɵelement(9, "div", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 11);
    ɵngcc0.ɵɵelement(2, "div", 11);
    ɵngcc0.ɵɵelement(3, "div", 11);
    ɵngcc0.ɵɵelement(4, "div", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 12);
    ɵngcc0.ɵɵelement(2, "div", 12);
    ɵngcc0.ɵɵelement(3, "div", 12);
    ɵngcc0.ɵɵelement(4, "div", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SpinkitComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c16 = ["link"];
function TabPaneComponent_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "active"]);
} }
const _c17 = function () { return { outline: 0 }; };
function ToastHeaderComponent_button_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵtext(1, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleMap(ɵngcc0.ɵɵpureFunction0(3, _c17));
    ɵngcc0.ɵɵproperty("cToastClose", ctx_r0.toast);
} }
function ToasterComponent_ng_template_0_Template(rf, ctx) { }
function TogglerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2, 3);
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
} }
function TogglerComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵelement(1, "span");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r2.buttonClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r2.iconClass);
} }
function WidgetSimpleComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.header, " ");
} }
function WidgetSimpleComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.text, " ");
} }
function WidgetBrandComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.rightHeader);
} }
function WidgetBrandComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.rightFooter);
} }
function WidgetBrandComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.leftHeader);
} }
function WidgetBrandComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.leftFooter);
} }
function WidgetIconComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r0.headerClasses);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.header, " ");
} }
function WidgetIconComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.text, " ");
} }
const _c18 = ["*", [["", "slot", "footer"]]];
const _c19 = ["*", "[slot=footer]"];
function WidgetProgressComponent_small_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.footer, " ");
} }
const _c20 = function (a2) { return { "my-3": true, "mb-0": true, "progress-white": a2 }; };
function WidgetProgressIconComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.header);
} }
function WidgetProgressIconComponent_small_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.text, " ");
} }
class AccordionComponent {
    constructor() {
        this.accordionClass = true;
        this.groups = [];
    }
    closeOtherGroups(openGroup) {
        this.groups.forEach((group) => {
            if (group !== openGroup) {
                group.isOpen = false;
            }
        });
    }
    addGroup(group) {
        this.groups.push(group);
    }
    removeGroup(group) {
        const index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    }
}
AccordionComponent.ɵfac = function AccordionComponent_Factory(t) { return new (t || AccordionComponent)(); };
AccordionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AccordionComponent, selectors: [["c-accordion"]], hostVars: 2, hostBindings: function AccordionComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("accordion", ctx.accordionClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function AccordionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
AccordionComponent.propDecorators = {
    accordionClass: [{ type: HostBinding, args: ['class.accordion',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AccordionComponent, [{
        type: Component,
        args: [{
                selector: 'c-accordion',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            }]
    }], function () { return []; }, { accordionClass: [{
            type: HostBinding,
            args: ['class.accordion']
        }] }); })();

class AccordionGroupComponent {
    constructor(accordion) {
        this.isOpen = false;
        this.groupClass = '';
        this.cardClass = true;
        this.accordion = accordion;
    }
    ngOnInit() {
        this.accordion.addGroup(this);
    }
    ngOnDestroy() {
        this.accordion.removeGroup(this);
    }
    toggleGroup() {
        this.isOpen = !this.isOpen;
        this.accordion.closeOtherGroups(this);
    }
}
AccordionGroupComponent.ɵfac = function AccordionGroupComponent_Factory(t) { return new (t || AccordionGroupComponent)(ɵngcc0.ɵɵdirectiveInject(AccordionComponent)); };
AccordionGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AccordionGroupComponent, selectors: [["c-accordion-group"]], hostVars: 2, hostBindings: function AccordionGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("card", ctx.cardClass);
    } }, inputs: { isOpen: "isOpen", groupClass: "groupClass" }, ngContentSelectors: _c2, decls: 4, vars: 1, consts: [[3, "click"], ["cCollapse", "", 3, "show"]], template: function AccordionGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵelementStart(0, "c-card-header", 0);
        ɵngcc0.ɵɵlistener("click", function AccordionGroupComponent_Template_c_card_header_click_0_listener() { return ctx.toggleGroup(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "c-card-body", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("show", !ctx.isOpen);
    } }, directives: function () { return [CardHeaderComponent, CardBodyComponent, CollapseDirective]; }, styles: ["[_nghost-%COMP%]{margin-bottom:0}"] });
AccordionGroupComponent.ctorParameters = () => [
    { type: AccordionComponent, decorators: [{ type: Inject, args: [AccordionComponent,] }] }
];
AccordionGroupComponent.propDecorators = {
    isOpen: [{ type: Input }],
    groupClass: [{ type: Input }],
    cardClass: [{ type: HostBinding, args: ['class.card',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AccordionGroupComponent, [{
        type: Component,
        args: [{
                selector: 'c-accordion-group',
                template: "<c-card-header (click)=\"toggleGroup()\">\n  <ng-content select=\"[c-accordion-header]\"></ng-content>\n</c-card-header>\n<c-card-body cCollapse [show]=\"!isOpen\">\n  <ng-content></ng-content>\n</c-card-body>\n",
                styles: [":host{margin-bottom:0}"]
            }]
    }], function () { return [{ type: AccordionComponent, decorators: [{
                type: Inject,
                args: [AccordionComponent]
            }] }]; }, { isOpen: [{
            type: Input
        }], groupClass: [{
            type: Input
        }], cardClass: [{
            type: HostBinding,
            args: ['class.card']
        }] }); })();

class CardComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            [`card-accent-${this.accentColor}`]: this.accentColor,
            [`text-${this.align}`]: this.align,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor
        });
        return classes;
    }
}
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["c-card"], ["", "c-card", ""]], hostVars: 2, hostBindings: function CardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { accentColor: "accentColor", align: "align", color: "color", borderColor: "borderColor", textColor: "textColor" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardComponent.propDecorators = {
    accentColor: [{ type: Input }],
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'c-card, [c-card]',
                template: `<ng-content></ng-content>`
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], accentColor: [{
            type: Input
        }], align: [{
            type: Input
        }], color: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }] }); })();

class CardBodyComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-body': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) { return new (t || CardBodyComponent)(); };
CardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardBodyComponent, selectors: [["c-card-body"], ["", "c-card-body", ""]], hostVars: 2, hostBindings: function CardBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { align: "align", color: "color", borderColor: "borderColor", textColor: "textColor" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardBodyComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-body, [c-card-body]',
                template: '<ng-content></ng-content>'
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], align: [{
            type: Input
        }], color: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }] }); })();

class CardFooterComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-footer': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) { return new (t || CardFooterComponent)(); };
CardFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardFooterComponent, selectors: [["c-card-footer"], ["", "c-card-footer", ""]], hostVars: 2, hostBindings: function CardFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { align: "align", color: "color", borderColor: "borderColor", textColor: "textColor" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardFooterComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-footer, [c-card-footer]',
                template: '<ng-content></ng-content>'
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], align: [{
            type: Input
        }], color: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }] }); })();

class CardGroupComponent {
    constructor() {
        this.deck = false;
        this.columns = false;
    }
    get hostClasses() {
        return this.getClasses();
    }
    getClasses() {
        return `card-${this.columns ? 'columns' : this.deck ? 'deck' : 'group'}`;
    }
}
CardGroupComponent.ɵfac = function CardGroupComponent_Factory(t) { return new (t || CardGroupComponent)(); };
CardGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardGroupComponent, selectors: [["c-card-group"], ["", "c-card-group", ""]], hostVars: 2, hostBindings: function CardGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { deck: "deck", columns: "columns" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardGroupComponent.propDecorators = {
    deck: [{ type: Input }],
    columns: [{ type: Input }],
    hostClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardGroupComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-group, [c-card-group]',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return []; }, { deck: [{
            type: Input
        }], columns: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class CardHeaderComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-header': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) { return new (t || CardHeaderComponent)(); };
CardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardHeaderComponent, selectors: [["c-card-header"], ["", "c-card-header", ""]], hostVars: 2, hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { align: "align", color: "color", borderColor: "borderColor", textColor: "textColor" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardHeaderComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-header, [c-card-header]',
                template: '<ng-content></ng-content>'
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], align: [{
            type: Input
        }], color: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }] }); })();

class CardHeaderActionsComponent {
    constructor() {
        this.cardHeaderActions = true;
    }
}
CardHeaderActionsComponent.ɵfac = function CardHeaderActionsComponent_Factory(t) { return new (t || CardHeaderActionsComponent)(); };
CardHeaderActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardHeaderActionsComponent, selectors: [["c-card-header-actions"], ["", "c-card-header-actions", ""]], hostVars: 2, hostBindings: function CardHeaderActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("card-header-actions", ctx.cardHeaderActions);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CardHeaderActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardHeaderActionsComponent.propDecorators = {
    cardHeaderActions: [{ type: HostBinding, args: ['class.card-header-actions',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardHeaderActionsComponent, [{
        type: Component,
        args: [{
                selector: 'c-card-header-actions, [c-card-header-actions]',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return []; }, { cardHeaderActions: [{
            type: HostBinding,
            args: ['class.card-header-actions']
        }] }); })();

class CardModule {
}
CardModule.ɵfac = function CardModule_Factory(t) { return new (t || CardModule)(); };
CardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CardModule });
CardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CardModule, { declarations: function () { return [CardComponent, CardBodyComponent, CardFooterComponent, CardGroupComponent, CardHeaderComponent, CardHeaderActionsComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CardComponent, CardBodyComponent, CardFooterComponent, CardGroupComponent, CardHeaderComponent, CardHeaderActionsComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CardComponent,
                    CardBodyComponent,
                    CardFooterComponent,
                    CardGroupComponent,
                    CardHeaderComponent,
                    CardHeaderActionsComponent
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    CardComponent,
                    CardBodyComponent,
                    CardFooterComponent,
                    CardGroupComponent,
                    CardHeaderComponent,
                    CardHeaderActionsComponent
                ]
            }]
    }], null, null); })();

const expandAnimation = animation([
    style({ height: 0, visibility: 'hidden', overflow: 'hidden', paddingTop: 0, paddingBottom: 0 }),
    animate('{{ time }} {{ easing }}', style({ height: '*', visibility: 'visible', paddingTop: '*', paddingBottom: '*', minHeight: '*' })),
    animate('{{ time }}', style({ opacity: '*', overflow: '*' })),
]);
const collapseAnimation = animation([
    style({ height: '*', visibility: 'visible', overflow: 'hidden', paddingTop: '*', paddingBottom: '*', minHeight: '*' }),
    animate('{{ time }} {{ easing }}', style({ height: 0, visibility: 'hidden', opacity: 0, overflow: 'hidden', paddingTop: 0, paddingBottom: 0, minHeight: 0 }))
]);

class CollapseDirective {
    constructor(hostElement, animationBuilder) {
        this.hostElement = hostElement;
        this.animationBuilder = animationBuilder;
        this.duration = '400ms';
        this.transition = 'ease-in-out';
        this.animate = true;
        this.collapseChange = new EventEmitter();
        this._show = false;
        this._animate = this.animate;
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'navbar-collapse': !!this.navbar,
            show: !!this.show,
        });
        return classes;
    }
    ngOnInit() {
        this._show = this.show;
    }
    ngOnDestroy() {
        this.destroyPlayer();
    }
    ngOnChanges(changes) {
        if (changes.show) {
            (!changes.show.firstChange || !changes.show.currentValue) && this.toggle(changes.show.currentValue);
        }
    }
    ngDoCheck() {
        if (this._show !== this.show) {
            this.toggle();
        }
    }
    toggle(show = this.show) {
        this._show = show;
        this.createPlayer(show);
        this.player.play();
    }
    destroyPlayer() {
        if (this.player) {
            this.player.destroy();
        }
    }
    createPlayer(show = this.show) {
        if (this.player) {
            this.destroyPlayer();
        }
        let animationFactory;
        const duration = this._animate ? this.duration : '0ms';
        animationFactory = this.animationBuilder.build(useAnimation(show ? expandAnimation : collapseAnimation, { params: { time: duration, easing: this.transition } }));
        this.player = animationFactory.create(this.host);
        this.player.onStart(() => { this.collapseChange.emit(show ? 'opening' : 'collapsing'); });
        this.player.onDone(() => { this.collapseChange.emit(show ? 'open' : 'collapsed'); });
    }
}
CollapseDirective.ɵfac = function CollapseDirective_Factory(t) { return new (t || CollapseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder)); };
CollapseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CollapseDirective, selectors: [["", "cCollapse", ""]], hostVars: 2, hostBindings: function CollapseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { duration: "duration", transition: "transition", animate: "animate", navbar: "navbar", show: "show" }, outputs: { collapseChange: "collapseChange" }, exportAs: ["cCollapse"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
CollapseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder }
];
CollapseDirective.propDecorators = {
    navbar: [{ type: Input }],
    duration: [{ type: Input }],
    transition: [{ type: Input }],
    show: [{ type: Input }],
    animate: [{ type: Input }],
    collapseChange: [{ type: Output }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CollapseDirective, [{
        type: Directive,
        args: [{
                selector: '[cCollapse]',
                exportAs: 'cCollapse'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.AnimationBuilder }]; }, { duration: [{
            type: Input
        }], transition: [{
            type: Input
        }], animate: [{
            type: Input
        }], collapseChange: [{
            type: Output
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], navbar: [{
            type: Input
        }], show: [{
            type: Input
        }] }); })();

class CollapseModule {
    static forRoot() {
        return { ngModule: CollapseModule, providers: [] };
    }
}
CollapseModule.ɵfac = function CollapseModule_Factory(t) { return new (t || CollapseModule)(); };
CollapseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CollapseModule });
CollapseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CollapseModule, { declarations: function () { return [CollapseDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CollapseDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CollapseModule, [{
        type: NgModule,
        args: [{
                declarations: [CollapseDirective],
                exports: [CollapseDirective],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class AccordionModule {
}
AccordionModule.ɵfac = function AccordionModule_Factory(t) { return new (t || AccordionModule)(); };
AccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AccordionModule });
AccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            CardModule,
            CollapseModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AccordionModule, { declarations: function () { return [AccordionComponent, AccordionGroupComponent]; }, imports: function () { return [CommonModule, CardModule, CollapseModule]; }, exports: function () { return [AccordionComponent, AccordionGroupComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AccordionModule, [{
        type: NgModule,
        args: [{
                declarations: [AccordionComponent, AccordionGroupComponent],
                exports: [
                    AccordionComponent,
                    AccordionGroupComponent
                ],
                imports: [
                    CommonModule,
                    CardModule,
                    CollapseModule
                ]
            }]
    }], null, null); })();

class AlertComponent {
    constructor(sanitizer, hostElement, renderer) {
        this.sanitizer = sanitizer;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.color = 'info';
        this.closeButton = false;
        this.show = true;
        this.fade = false;
        this.iconHtml = '<span>&times;</span>';
        this.timeout = 0;
        this.dismissed = new EventEmitter();
        this.timer = new EventEmitter();
    }
    get clock() {
        const time = this._clock;
        this.timer.emit(time);
        return time;
    }
    get animationDisabled() {
        return !this.fade;
    }
    get animateType() {
        return this.show ? 'show' : 'hide';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            alert: true,
            'alert-dismissible': !!this.closeButton,
            [`alert-${this.color}`]: !!this.color
        });
        return classes;
    }
    ngOnInit() {
        this.safeIcon = this.sanitizer.sanitize(SecurityContext.HTML, this.iconHtml);
        if (this.show && this.timeout) {
            this.setTimer();
        }
    }
    ngOnDestroy() {
        this.clearTimer();
        this.clearClock();
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.hostElement.nativeElement, `alert-${changes.color.previousValue}`);
        }
        if (changes.timeout) {
            this.setTimer();
        }
    }
    setTimer() {
        this.clearTimer();
        this.timerId = this.timeout > 0 ? setTimeout(() => this.onClose(), this.timeout) : null;
        this.setClock();
    }
    clearTimer() {
        clearTimeout(this.timerId);
        this.timerId = null;
    }
    onClose() {
        this.clearTimer();
        if (this.show) {
            this.show = false;
            this.hide = true;
            this.dismissed.emit(this);
        }
    }
    setClock() {
        this.clearClock();
        this._clock = 0;
        this.clockId = setInterval(() => {
            this._clock += 1;
        }, 1000);
        setTimeout(() => {
            this.clearClock();
        }, this.timeout);
    }
    clearClock() {
        clearInterval(this.clockId);
        this.clockId = null;
    }
    onAnimationEvent(event) {
        console.warn(event);
        if (event.phaseName === 'done' && event.toState === 'hide') {
        }
        if (event.phaseName === 'start' && event.toState === 'show') {
        }
    }
}
AlertComponent.ɵfac = function AlertComponent_Factory(t) { return new (t || AlertComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AlertComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AlertComponent, selectors: [["c-alert"]], hostVars: 4, hostBindings: function AlertComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@.disabled", ctx.animationDisabled)("@fadeInOut", ctx.animateType);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { color: "color", closeButton: "closeButton", show: "show", fade: "fade", iconHtml: "iconHtml", timeout: "timeout" }, outputs: { dismissed: "dismissed", timer: "timer" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 1, consts: [[3, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true", 3, "innerHTML"], [1, "sr-only"]], template: function AlertComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵtemplate(1, AlertComponent_ng_template_1_Template, 4, 1, "ng-template", 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.closeButton);
    } }, directives: [ɵngcc3.NgIf], styles: ["[_nghost-%COMP%]{display:block}"], data: { animation: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1 })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => hide', [
                    animate('.3s ease-out', style({ opacity: 0 })),
                    animate('.3s ease-out', style({ height: 0, padding: 0, border: 0, margin: 0 }))
                ]),
                transition('hide => show', [
                    animate('.3s ease-in', style({ height: '*', padding: '*', border: '*', margin: '*' })),
                    animate('.3s ease-in', style({ opacity: '*' }))
                ])
            ])
        ] } });
AlertComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ElementRef },
    { type: Renderer2 }
];
AlertComponent.propDecorators = {
    color: [{ type: Input }],
    closeButton: [{ type: Input }],
    show: [{ type: Input }],
    fade: [{ type: Input }],
    iconHtml: [{ type: Input }],
    timeout: [{ type: Input }],
    dismissed: [{ type: Output }],
    timer: [{ type: Output }],
    animationDisabled: [{ type: HostBinding, args: ['@.disabled',] }],
    animateType: [{ type: HostBinding, args: ['@fadeInOut',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AlertComponent, [{
        type: Component,
        args: [{
                selector: 'c-alert',
                template: "<!--<div [@fadeInOut]=\"show ? 'show' : 'hide'\" [class]=\"alertClasses\">-->\n<ng-container>\n  <ng-template [ngIf]=\"closeButton\">\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"onClose()\">\n      <span aria-hidden=\"true\" [innerHTML]=\"safeIcon\"></span>\n      <span class=\"sr-only\">Close</span>\n    </button>\n  </ng-template>\n  <ng-content></ng-content>\n</ng-container>\n",
                animations: [
                    trigger('fadeInOut', [
                        state('show', style({ opacity: 1 })),
                        state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        transition('show => hide', [
                            animate('.3s ease-out', style({ opacity: 0 })),
                            animate('.3s ease-out', style({ height: 0, padding: 0, border: 0, margin: 0 }))
                        ]),
                        transition('hide => show', [
                            animate('.3s ease-in', style({ height: '*', padding: '*', border: '*', margin: '*' })),
                            animate('.3s ease-in', style({ opacity: '*' }))
                        ])
                    ])
                ],
                styles: [":host{display:block}"]
            }]
    }], function () { return [{ type: ɵngcc2.DomSanitizer }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { color: [{
            type: Input
        }], closeButton: [{
            type: Input
        }], show: [{
            type: Input
        }], fade: [{
            type: Input
        }], iconHtml: [{
            type: Input
        }], timeout: [{
            type: Input
        }], dismissed: [{
            type: Output
        }], timer: [{
            type: Output
        }], animationDisabled: [{
            type: HostBinding,
            args: ['@.disabled']
        }], animateType: [{
            type: HostBinding,
            args: ['@fadeInOut']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class AlertModule {
}
AlertModule.ɵfac = function AlertModule_Factory(t) { return new (t || AlertModule)(); };
AlertModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AlertModule });
AlertModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AlertModule, { declarations: function () { return [AlertComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AlertComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AlertModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    AlertComponent
                ],
                declarations: [
                    AlertComponent
                ]
            }]
    }], null, null); })();

class BadgeComponent {
    constructor(hostElement, renderer) {
        this.hostElement = hostElement;
        this.renderer = renderer;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            badge: true,
            [`badge-${this.color}`]: !!this.color,
            [`badge-${this.shape}`]: !!this.shape
        });
        return classes;
    }
    ngOnChanges(changes) {
        if (changes.color) {
            const classOff = `badge-${changes.color.previousValue}`;
            this.renderer.removeClass(this.hostElement.nativeElement, classOff);
        }
        if (changes.shape) {
            const classOff = `badge-${changes.shape.previousValue}`;
            this.renderer.removeClass(this.hostElement.nativeElement, classOff);
        }
    }
}
BadgeComponent.ɵfac = function BadgeComponent_Factory(t) { return new (t || BadgeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
BadgeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BadgeComponent, selectors: [["c-badge"]], hostVars: 2, hostBindings: function BadgeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { shape: "shape", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function BadgeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
BadgeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
BadgeComponent.propDecorators = {
    shape: [{ type: Input }],
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BadgeComponent, [{
        type: Component,
        args: [{
                selector: 'c-badge',
                template: '<ng-content></ng-content>',
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], shape: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class BadgeModule {
}
BadgeModule.ɵfac = function BadgeModule_Factory(t) { return new (t || BadgeModule)(); };
BadgeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BadgeModule });
BadgeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BadgeModule, { declarations: function () { return [BadgeComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [BadgeComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BadgeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    BadgeComponent
                ],
                declarations: [
                    BadgeComponent
                ]
            }]
    }], null, null); })();

class BreadcrumbService {
    constructor(router, route) {
        this.router = router;
        this.route = route;
        this.outlet = 'primary';
        this.breadcrumbsBehaviorSubject = new BehaviorSubject(new Array());
        this.breadcrumbs$ = this.breadcrumbsBehaviorSubject.asObservable();
        this.router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe((event) => {
            const breadcrumbs = [];
            let currentRoute = this.route.root;
            let url = '';
            do {
                const childrenRoutes = currentRoute.children;
                currentRoute = null;
                childrenRoutes.forEach(route => {
                    if (route.outlet === this.outlet) {
                        const routeSnapshot = route.snapshot;
                        url += '/' + routeSnapshot.url.map(segment => segment.path).join('/');
                        breadcrumbs.push({
                            label: route.snapshot.data.title || '',
                            url,
                            queryParams: routeSnapshot.queryParams
                        });
                        currentRoute = route;
                    }
                });
            } while (currentRoute);
            this.breadcrumbsBehaviorSubject.next(Object.assign([], breadcrumbs));
            return breadcrumbs;
        });
    }
}
BreadcrumbService.ɵfac = function BreadcrumbService_Factory(t) { return new (t || BreadcrumbService)(ɵngcc0.ɵɵinject(ɵngcc4.Router), ɵngcc0.ɵɵinject(ɵngcc4.ActivatedRoute)); };
BreadcrumbService.ɵprov = ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(ɵɵinject(Router), ɵɵinject(ActivatedRoute)); }, token: BreadcrumbService, providedIn: "root" });
BreadcrumbService.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadcrumbService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc4.Router }, { type: ɵngcc4.ActivatedRoute }]; }, null); })();

class BreadcrumbComponent {
    constructor() {
        this.divider = false;
        this.breadcrumbClass = true;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes.items) {
            this.setup();
        }
    }
    setup() {
        if (this.items && this.items.length > 0) {
            this.breadcrumbs = new Observable((observer) => {
                if (this.items) {
                    observer.next(this.items);
                }
            });
        }
    }
    ngOnDestroy() {
        this.breadcrumbs = null;
    }
}
BreadcrumbComponent.ɵfac = function BreadcrumbComponent_Factory(t) { return new (t || BreadcrumbComponent)(); };
BreadcrumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BreadcrumbComponent, selectors: [["c-breadcrumb"]], hostVars: 2, hostBindings: function BreadcrumbComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("breadcrumb", ctx.breadcrumbClass);
    } }, inputs: { divider: "divider", items: "items" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 4, vars: 3, consts: function () { let i18n_3; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_EXTERNAL_1573340103535294293$$FESM2015_COREUI_ANGULAR_JS____4 = goog.getMsg("{$interpolation} ", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_3 = MSG_EXTERNAL_1573340103535294293$$FESM2015_COREUI_ANGULAR_JS____4;
    }
    else {
        i18n_3 = $localize `:␟615f5863f83a316b692cb88dc36570691be4d586␟1573340103535294293:${"\uFFFD0\uFFFD"}:INTERPOLATION: `;
    } let i18n_5; if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_EXTERNAL_2790673009523224325$$FESM2015_COREUI_ANGULAR_JS____6 = goog.getMsg("{$interpolation}", { "interpolation": "\uFFFD0\uFFFD" });
        i18n_5 = MSG_EXTERNAL_2790673009523224325$$FESM2015_COREUI_ANGULAR_JS____6;
    }
    else {
        i18n_5 = $localize `:␟8d663c4b400232e6d8c54ffd3c710c82f206cebb␟2790673009523224325:${"\uFFFD0\uFFFD"}:INTERPOLATION:`;
    } return [["ngFor", "", 3, "ngForOf"], [4, "ngIf"], ["class", "breadcrumb-item", 4, "ngIf"], ["class", "breadcrumb-item active", 3, "cHtmlAttr", 4, "ngIf"], [1, "breadcrumb-item"], [3, "routerLink", "cHtmlAttr", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state"], i18n_3, [1, "breadcrumb-item", "active", 3, "cHtmlAttr"], i18n_5]; }, template: function BreadcrumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵtemplate(1, BreadcrumbComponent_ng_template_1_Template, 1, 1, "ng-template", 0);
        ɵngcc0.ɵɵpipe(2, "async");
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx.breadcrumbs));
    } }, directives: function () { return [ɵngcc3.NgForOf, ɵngcc3.NgIf, ɵngcc4.RouterLinkWithHref, HtmlAttributesDirective]; }, pipes: function () { return [ɵngcc3.AsyncPipe]; }, styles: [""] });
BreadcrumbComponent.ctorParameters = () => [];
BreadcrumbComponent.propDecorators = {
    items: [{ type: Input }],
    divider: [{ type: Input }],
    breadcrumbClass: [{ type: HostBinding, args: ['class.breadcrumb',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadcrumbComponent, [{
        type: Component,
        args: [{
                selector: 'c-breadcrumb',
                template: "<ng-container>\n  <ng-template ngFor let-breadcrumb [ngForOf]=\"breadcrumbs | async\" let-last = last>\n    <ng-container *ngIf=\"breadcrumb.label && (breadcrumb.url.slice(-1) == '/' || last)\">\n      <div *ngIf=\"!last\" class=\"breadcrumb-item\">\n        <a [routerLink]=\"breadcrumb.url\"\n           [cHtmlAttr]=\"breadcrumb.attributes\"\n           [target]=\"breadcrumb.attributes?.target\"\n           [queryParams]=\"breadcrumb.linkProps?.queryParams\"\n           [fragment]=\"breadcrumb.linkProps?.fragment\"\n           [queryParamsHandling]=\"breadcrumb.linkProps?.queryParamsHandling\"\n           [preserveFragment]=\"breadcrumb.linkProps?.preserveFragment\"\n           [skipLocationChange]=\"breadcrumb.linkProps?.skipLocationChange\"\n           [replaceUrl]=\"breadcrumb.linkProps?.replaceUrl\"\n           [state]=\"breadcrumb.linkProps?.state\"\n           i18n>{{breadcrumb.label}}\n        </a>\n      </div>\n      <span *ngIf=\"!last && divider\" ngPreserveWhitespaces=\"true\"> {{divider}} </span>\n      <span class=\"breadcrumb-item active\" *ngIf=\"last\" [cHtmlAttr]=\"breadcrumb.attributes\" i18n>{{breadcrumb.label}}</span>\n    </ng-container>\n  </ng-template>\n  <ng-content></ng-content>\n</ng-container>\n",
                styles: [""]
            }]
    }], function () { return []; }, { divider: [{
            type: Input
        }], breadcrumbClass: [{
            type: HostBinding,
            args: ['class.breadcrumb']
        }], items: [{
            type: Input
        }] }); })();

class BreadcrumbDirective {
    constructor(breadcrumbComponent, service) {
        this.breadcrumbComponent = breadcrumbComponent;
        this.service = service;
    }
    ngOnInit() {
        this.breadcrumbComponent.breadcrumbs = this.service.breadcrumbs$;
    }
}
BreadcrumbDirective.ɵfac = function BreadcrumbDirective_Factory(t) { return new (t || BreadcrumbDirective)(ɵngcc0.ɵɵdirectiveInject(BreadcrumbComponent, 1), ɵngcc0.ɵɵdirectiveInject(BreadcrumbService)); };
BreadcrumbDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BreadcrumbDirective, selectors: [["", "cBreadcrumbRouter", ""]], exportAs: ["cBreadcrumbRouter"] });
BreadcrumbDirective.ctorParameters = () => [
    { type: BreadcrumbComponent, decorators: [{ type: Host }] },
    { type: BreadcrumbService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadcrumbDirective, [{
        type: Directive,
        args: [{
                selector: '[cBreadcrumbRouter]',
                exportAs: 'cBreadcrumbRouter'
            }]
    }], function () { return [{ type: BreadcrumbComponent, decorators: [{
                type: Host
            }] }, { type: BreadcrumbService }]; }, null); })();

class OutClickService {
    constructor() {
        this.outClick = new BehaviorSubject({ event: undefined });
        this.outClick$ = this.outClick.asObservable();
    }
    onClick(message) {
        this.outClick.next(message);
    }
}
OutClickService.ɵfac = function OutClickService_Factory(t) { return new (t || OutClickService)(); };
OutClickService.ɵprov = ɵɵdefineInjectable({ factory: function OutClickService_Factory() { return new OutClickService(); }, token: OutClickService, providedIn: "root" });
OutClickService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OutClickService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class OutClickDirective {
    constructor(elementRef, outClickService) {
        this.elementRef = elementRef;
        this.outClickService = outClickService;
    }
    onDocumentClick($event) {
        const targetElement = $event.target;
        if (targetElement && !this.elementRef.nativeElement.contains(targetElement)) {
            this.outClickService.onClick({ event: $event });
        }
    }
    ngOnInit() {
        this.outClickSubscription = this.outClickService.outClick$.subscribe((message) => {
        });
    }
    ngOnDestroy() {
        this.outClickSubscription.unsubscribe();
    }
}
OutClickDirective.ɵfac = function OutClickDirective_Factory(t) { return new (t || OutClickDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(OutClickService)); };
OutClickDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OutClickDirective, selectors: [["", "cOutClick", ""]], hostBindings: function OutClickDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function OutClickDirective_click_HostBindingHandler($event) { return ctx.onDocumentClick($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, exportAs: ["cOutClick"] });
OutClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: OutClickService }
];
OutClickDirective.propDecorators = {
    onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OutClickDirective, [{
        type: Directive,
        args: [{
                selector: '[cOutClick]',
                exportAs: 'cOutClick'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: OutClickService }]; }, { onDocumentClick: [{
            type: HostListener,
            args: ['document:click', ['$event']]
        }] }); })();

class HtmlAttributesDirective {
    constructor(renderer, el) {
        this.renderer = renderer;
        this.el = el;
    }
    ngOnInit() {
        const attribs = this.cHtmlAttr;
        for (const attr in attribs) {
            if (attr === 'style' && typeof (attribs[attr]) === 'object') {
                this.setStyle(attribs[attr]);
            }
            else if (attr === 'class') {
                this.addClass(attribs[attr]);
            }
            else {
                this.setAttrib(attr, attribs[attr]);
            }
        }
    }
    setStyle(styles) {
        for (const style in styles) {
            if (style) {
                this.renderer.setStyle(this.el.nativeElement, style, styles[style]);
            }
        }
    }
    addClass(classes) {
        const classArray = (Array.isArray(classes) ? classes : classes.split(' '));
        classArray.filter((element) => element.length > 0).forEach(element => {
            this.renderer.addClass(this.el.nativeElement, element);
        });
    }
    setAttrib(key, value) {
        value !== null ?
            this.renderer.setAttribute(this.el.nativeElement, key, value) :
            this.renderer.removeAttribute(this.el.nativeElement, key);
    }
}
HtmlAttributesDirective.ɵfac = function HtmlAttributesDirective_Factory(t) { return new (t || HtmlAttributesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
HtmlAttributesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HtmlAttributesDirective, selectors: [["", "cHtmlAttr", ""]], inputs: { cHtmlAttr: "cHtmlAttr" }, exportAs: ["cHtmlAttr"] });
HtmlAttributesDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
HtmlAttributesDirective.propDecorators = {
    cHtmlAttr: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HtmlAttributesDirective, [{
        type: Directive,
        args: [{
                selector: '[cHtmlAttr]',
                exportAs: 'cHtmlAttr'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { cHtmlAttr: [{
            type: Input
        }] }); })();

class SharedModule {
    static forRoot() {
        return {
            ngModule: SharedModule,
            providers: [
                { provide: OutClickService }
            ]
        };
    }
}
SharedModule.ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [OutClickDirective, HtmlAttributesDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [OutClickDirective, HtmlAttributesDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    OutClickDirective,
                    HtmlAttributesDirective
                ],
                exports: [
                    OutClickDirective,
                    HtmlAttributesDirective
                ],
                providers: []
            }]
    }], null, null); })();

const sidebarCssClasses = [
    'c-sidebar-show',
    'c-sidebar-sm-show',
    'c-sidebar-md-show',
    'c-sidebar-lg-show',
    'c-sidebar-xl-show'
];
const validBreakpoints = ['sm', 'md', 'lg', 'xl'];
function checkBreakpoint(breakpoint, list) {
    return list.indexOf(breakpoint) > -1;
}

class BreadcrumbModule {
}
BreadcrumbModule.ɵfac = function BreadcrumbModule_Factory(t) { return new (t || BreadcrumbModule)(); };
BreadcrumbModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BreadcrumbModule });
BreadcrumbModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [BreadcrumbService], imports: [[CommonModule, RouterModule, SharedModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BreadcrumbModule, { declarations: function () { return [BreadcrumbComponent, BreadcrumbDirective]; }, imports: function () { return [CommonModule, RouterModule, SharedModule]; }, exports: function () { return [BreadcrumbComponent, BreadcrumbDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadcrumbModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, RouterModule, SharedModule],
                exports: [BreadcrumbComponent, BreadcrumbDirective],
                declarations: [BreadcrumbComponent, BreadcrumbDirective],
                providers: [BreadcrumbService]
            }]
    }], null, null); })();

class ButtonComponent {
    constructor() {
        this.block = null;
        this.size = '';
        this.type = 'button';
        this.tabindex = null;
        this.disabled = null;
        this.pressed = null;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const outlineSuffix = this.variant === 'outline' ? 'outline-' : '';
        const classes = classNames({
            btn: true,
            [`btn-${outlineSuffix}${this.color}`]: this.color,
            [`btn-${this.size}`]: this.size,
            [`btn-ghost-${this.color}`]: this.variant === 'ghost',
            'btn-block': this.block != null,
            'btn-pill': this.shape === 'pill',
            'btn-square': this.shape === 'square',
            disabled: !!this.disabled,
            focus: !this.variant && this.pressed != null,
            active: this.variant && this.pressed != null
        });
        return classes;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get hostType() {
        return this.type;
    }
    get hostRole() {
        return 'button';
    }
    ngOnInit() {
    }
}
ButtonComponent.ɵfac = function ButtonComponent_Factory(t) { return new (t || ButtonComponent)(); };
ButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ButtonComponent, selectors: [["c-button"], ["", "c-button", ""]], hostVars: 7, hostBindings: function ButtonComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.pressed)("disabled", ctx.isDisabled)("tabindex", ctx.getTabindex)("type", ctx.hostType)("role", ctx.hostRole);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { block: "block", size: "size", type: "type", tabindex: "tabindex", disabled: "disabled", pressed: "pressed", shape: "shape", variant: "variant", color: "color" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [".disabled[_nghost-%COMP%], [_nghost-%COMP%]:disabled{cursor:default}"] });
ButtonComponent.ctorParameters = () => [];
ButtonComponent.propDecorators = {
    block: [{ type: Input }],
    shape: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    disabled: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
    pressed: [{ type: HostBinding, args: ['attr.aria-pressed',] }, { type: Input }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostType: [{ type: HostBinding, args: ['attr.type',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonComponent, [{
        type: Component,
        args: [{
                selector: 'c-button, [c-button]',
                template: '<ng-content></ng-content>',
                styles: [":host.disabled,:host:disabled{cursor:default}"]
            }]
    }], function () { return []; }, { block: [{
            type: Input
        }], size: [{
            type: Input
        }], type: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disabled: [{
            type: Input
        }], pressed: [{
            type: HostBinding,
            args: ['attr.aria-pressed']
        }, {
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], isDisabled: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], getTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostType: [{
            type: HostBinding,
            args: ['attr.type']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], shape: [{
            type: Input
        }], variant: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class ButtonDirective {
    constructor() {
        this.block = null;
        this.size = '';
        this.type = 'button';
        this.tabindex = null;
        this.disabled = null;
        this.pressed = null;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const outlineSuffix = this.variant === 'outline' ? 'outline-' : '';
        const classes = classNames({
            btn: true,
            [`btn-${outlineSuffix}${this.color}`]: this.color,
            [`btn-${this.size}`]: this.size,
            [`btn-ghost-${this.color}`]: this.variant === 'ghost',
            'btn-block': this.block != null,
            'btn-pill': this.shape === 'pill',
            'btn-square': this.shape === 'square',
            disabled: !!this.disabled,
            focus: !this.variant && this.pressed != null,
            active: this.variant && this.pressed != null
        });
        return classes;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get hostType() {
        return this.type;
    }
    get hostRole() {
        return 'button';
    }
    ngOnInit() {
    }
}
ButtonDirective.ɵfac = function ButtonDirective_Factory(t) { return new (t || ButtonDirective)(); };
ButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ButtonDirective, selectors: [["", "cButton", ""]], hostVars: 7, hostBindings: function ButtonDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.pressed)("disabled", ctx.isDisabled)("tabindex", ctx.getTabindex)("type", ctx.hostType)("role", ctx.hostRole);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { block: "block", size: "size", type: "type", tabindex: "tabindex", disabled: "disabled", pressed: "pressed", shape: "shape", variant: "variant", color: "color" }, exportAs: ["cButton"] });
ButtonDirective.ctorParameters = () => [];
ButtonDirective.propDecorators = {
    block: [{ type: Input }],
    shape: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    disabled: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
    pressed: [{ type: HostBinding, args: ['attr.aria-pressed',] }, { type: Input }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostType: [{ type: HostBinding, args: ['attr.type',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[cButton]',
                exportAs: 'cButton'
            }]
    }], function () { return []; }, { block: [{
            type: Input
        }], size: [{
            type: Input
        }], type: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disabled: [{
            type: Input
        }], pressed: [{
            type: HostBinding,
            args: ['attr.aria-pressed']
        }, {
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], isDisabled: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], getTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostType: [{
            type: HostBinding,
            args: ['attr.type']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], shape: [{
            type: Input
        }], variant: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class ButtonGroupComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.size = '';
        this.vertical = null;
        this.classes = Object.create(null);
        this.aria = 'Button group';
        this.host = this.hostElement.nativeElement;
    }
    get hostRole() {
        return 'group';
    }
    ngOnInit() {
        this.addClasses();
    }
    addClasses() {
        this.setClasses();
        for (const [key, value] of Object.entries(this.classes)) {
            if (value) {
                this.renderer.addClass(this.host, key);
            }
        }
    }
    setClasses() {
        this.classes['btn-group-vertical'] = Boolean(this.vertical) || this.vertical != null;
        this.classes['btn-group'] = !this.classes['btn-group-vertical'];
        this.classes[`btn-group-${this.size}`] = Boolean(this.size);
    }
}
ButtonGroupComponent.ɵfac = function ButtonGroupComponent_Factory(t) { return new (t || ButtonGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ButtonGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ButtonGroupComponent, selectors: [["c-button-group"]], hostVars: 2, hostBindings: function ButtonGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.aria)("role", ctx.hostRole);
    } }, inputs: { size: "size", vertical: "vertical" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ButtonGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
ButtonGroupComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ButtonGroupComponent.propDecorators = {
    size: [{ type: Input }],
    vertical: [{ type: Input }],
    aria: [{ type: HostBinding, args: ['attr.aria-label',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonGroupComponent, [{
        type: Component,
        args: [{
                selector: 'c-button-group',
                template: '<ng-content></ng-content>',
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { size: [{
            type: Input
        }], vertical: [{
            type: Input
        }], aria: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }] }); })();

class ButtonToolbarComponent {
    constructor() {
        this.justify = '';
        this.class = '';
        this.classes = Object.create(null);
        this.aria = 'Button toolbar';
    }
    get hostRole() {
        return 'toolbar';
    }
    get hostClasses() {
        return this.getClasses();
    }
    ngOnInit() {
    }
    getClasses() {
        this.classes['btn-toolbar'] = true;
        this.classes[`justify-content-start`] = this.justify === 'start';
        this.classes[`justify-content-end`] = this.justify === 'end';
        this.classes[`justify-content-center}`] = this.justify === 'center';
        this.classes[`justify-content-between`] = this.justify === 'between';
        return classNames(this.classes, this.class, this.ngClass);
    }
}
ButtonToolbarComponent.ɵfac = function ButtonToolbarComponent_Factory(t) { return new (t || ButtonToolbarComponent)(); };
ButtonToolbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ButtonToolbarComponent, selectors: [["c-button-toolbar"]], hostVars: 4, hostBindings: function ButtonToolbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.aria)("role", ctx.hostRole);
        ɵngcc0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { justify: "justify", class: "class", ngClass: "ngClass" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ButtonToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex}"] });
ButtonToolbarComponent.ctorParameters = () => [];
ButtonToolbarComponent.propDecorators = {
    justify: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    aria: [{ type: HostBinding, args: ['attr.aria-label',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    hostClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'c-button-toolbar',
                template: '<ng-content></ng-content>',
                styles: [":host{display:flex}"]
            }]
    }], function () { return []; }, { justify: [{
            type: Input
        }], class: [{
            type: Input
        }], aria: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], ngClass: [{
            type: Input
        }] }); })();

const RADIO_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ButtonRadioGroupDirective),
    multi: true
};
class ButtonRadioGroupDirective {
    constructor(cdr) {
        this.cdr = cdr;
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    writeValue(value) {
        this._value = value;
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
ButtonRadioGroupDirective.ɵfac = function ButtonRadioGroupDirective_Factory(t) { return new (t || ButtonRadioGroupDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ButtonRadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ButtonRadioGroupDirective, selectors: [["", "cButtonRadioGroup", ""]], features: [ɵngcc0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR])] });
ButtonRadioGroupDirective.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonRadioGroupDirective, [{
        type: Directive,
        args: [{
                selector: '[cButtonRadioGroup]',
                providers: [RADIO_CONTROL_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

const RADIO_CONTROL_VALUE_ACCESSOR$1 = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ButtonRadioDirective),
    multi: true
};
class ButtonRadioDirective {
    constructor(el, cdr, group, renderer) {
        this.el = el;
        this.cdr = cdr;
        this.group = group;
        this.renderer = renderer;
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
    }
    get value() {
        return this.group ? this.group.value : this._value;
    }
    set value(value) {
        if (this.group) {
            this.group.value = value;
            return;
        }
        this._value = value;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        this._disabled = disabled;
        this.setDisabledState(disabled);
    }
    get isActive() {
        return this.btnRadio === this.value;
    }
    onClick() {
        if (this.el.nativeElement.attributes.disabled || !this.uncheckable && this.btnRadio === this.value) {
            return;
        }
        this.value = this.uncheckable && this.btnRadio === this.value ? undefined : this.btnRadio;
        this._onChange(this.value);
    }
    ngOnInit() {
        this.uncheckable = typeof this.uncheckable !== 'undefined';
    }
    onBlur() {
        this.onTouched();
    }
    _onChange(value) {
        if (this.group) {
            this.group.onTouched();
            this.group.onChange(value);
            return;
        }
        this.onTouched();
        this.onChange(value);
    }
    writeValue(value) {
        this.value = value;
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(disabled) {
        if (disabled) {
            this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');
            return;
        }
        this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
    }
}
ButtonRadioDirective.ɵfac = function ButtonRadioDirective_Factory(t) { return new (t || ButtonRadioDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ButtonRadioGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ButtonRadioDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ButtonRadioDirective, selectors: [["", "cBtnRadio", ""]], hostVars: 3, hostBindings: function ButtonRadioDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ButtonRadioDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.isActive);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
    } }, inputs: { value: "value", disabled: "disabled", uncheckable: "uncheckable", btnRadio: "btnRadio" }, exportAs: ["cBtnRadio"], features: [ɵngcc0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR$1])] });
ButtonRadioDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ButtonRadioGroupDirective, decorators: [{ type: Optional }] },
    { type: Renderer2 }
];
ButtonRadioDirective.propDecorators = {
    btnRadio: [{ type: Input }],
    uncheckable: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    isActive: [{ type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['attr.aria-pressed',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonRadioDirective, [{
        type: Directive,
        args: [{
                selector: '[cBtnRadio]',
                exportAs: 'cBtnRadio',
                providers: [RADIO_CONTROL_VALUE_ACCESSOR$1]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ButtonRadioGroupDirective, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }]; }, { value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isActive: [{
            type: HostBinding,
            args: ['class.active']
        }, {
            type: HostBinding,
            args: ['attr.aria-pressed']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], uncheckable: [{
            type: Input
        }], btnRadio: [{
            type: Input
        }] }); })();

class ButtonModule {
}
ButtonModule.ɵfac = function ButtonModule_Factory(t) { return new (t || ButtonModule)(); };
ButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ButtonModule });
ButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ButtonModule, { declarations: function () { return [ButtonComponent, ButtonDirective, ButtonGroupComponent, ButtonToolbarComponent, ButtonRadioDirective, ButtonRadioGroupDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ButtonComponent, ButtonDirective, ButtonGroupComponent, ButtonToolbarComponent, ButtonRadioDirective, ButtonRadioGroupDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ButtonComponent,
                    ButtonDirective,
                    ButtonGroupComponent,
                    ButtonToolbarComponent,
                    ButtonRadioDirective,
                    ButtonRadioGroupDirective
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    ButtonComponent,
                    ButtonDirective,
                    ButtonGroupComponent,
                    ButtonToolbarComponent,
                    ButtonRadioDirective,
                    ButtonRadioGroupDirective
                ]
            }]
    }], null, null); })();

class CalloutComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'c-callout': true,
            [`c-callout-${this.color}`]: !!this.color
        });
        return classes;
    }
}
CalloutComponent.ɵfac = function CalloutComponent_Factory(t) { return new (t || CalloutComponent)(); };
CalloutComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CalloutComponent, selectors: [["c-callout"], ["", "c-callout", ""]], hostVars: 2, hostBindings: function CalloutComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { color: "color" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CalloutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
CalloutComponent.ctorParameters = () => [];
CalloutComponent.propDecorators = {
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalloutComponent, [{
        type: Component,
        args: [{
                selector: 'c-callout, [c-callout]',
                template: `<ng-content></ng-content>`,
                styles: [":host{display:block}"]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }] }); })();

class CalloutModule {
}
CalloutModule.ɵfac = function CalloutModule_Factory(t) { return new (t || CalloutModule)(); };
CalloutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CalloutModule });
CalloutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CalloutModule, { declarations: function () { return [CalloutComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CalloutComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalloutModule, [{
        type: NgModule,
        args: [{
                declarations: [CalloutComponent],
                exports: [CalloutComponent],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class NoZoneBaseChartDirective extends BaseChartDirective {
    constructor(element, themeService, zone) {
        super(element, themeService);
        this.zone = zone;
        const refresh = this.refresh;
        this.refresh = () => {
            this.zone.runOutsideAngular(refresh.bind(this));
        };
    }
}
NoZoneBaseChartDirective.ɵfac = function NoZoneBaseChartDirective_Factory(t) { return new (t || NoZoneBaseChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
NoZoneBaseChartDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NoZoneBaseChartDirective, selectors: [["canvas", "cNoZoneBaseChart", ""]], exportAs: ["base-chart"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NoZoneBaseChartDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThemeService },
    { type: NgZone }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NoZoneBaseChartDirective, [{
        type: Directive,
        args: [{
                selector: 'canvas[cNoZoneBaseChart]',
                exportAs: 'base-chart'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc5.ThemeService }, { type: ɵngcc0.NgZone }]; }, null); })();

class ChartModule {
}
ChartModule.ɵfac = function ChartModule_Factory(t) { return new (t || ChartModule)(); };
ChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartModule });
ChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartModule, { declarations: function () { return [NoZoneBaseChartDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NoZoneBaseChartDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    NoZoneBaseChartDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    NoZoneBaseChartDirective
                ]
            }]
    }], null, null); })();

class CarouselService {
    constructor() {
        this.carouselIndex = new BehaviorSubject({});
        this.carouselIndex$ = this.carouselIndex.asObservable();
    }
    setIndex(index) {
        this.carouselIndex.next(index);
    }
}
CarouselService.ɵfac = function CarouselService_Factory(t) { return new (t || CarouselService)(); };
CarouselService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselService, factory: CarouselService.ɵfac });
CarouselService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class CarouselState {
    constructor(carouselService) {
        this.carouselService = carouselService;
        this._state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
        };
    }
    get state() {
        return this._state;
    }
    set state(state) {
        const prevState = Object.assign({}, this._state);
        const nextState = Object.assign(Object.assign({}, this._state), state);
        this._state = nextState;
        if (prevState.activeItemIndex !== nextState.activeItemIndex) {
            this.carouselService.setIndex({ active: nextState.activeItemIndex });
        }
    }
    setItems(newItems) {
        if (newItems.length) {
            const itemsArray = newItems.toArray();
            itemsArray.forEach((item, i) => {
                item.index = i;
            });
            this.state = {
                items: itemsArray,
            };
        }
        else {
            this.reset();
        }
    }
    setNextIndex(nextIndex) {
        this.carouselService.setIndex(nextIndex);
    }
    direction(direction = 'next') {
        this.state = { direction };
        const { activeItemIndex, items } = this.state;
        const itemsCount = items.length;
        return direction === 'next' ?
            (activeItemIndex === itemsCount - 1 ? 0 : activeItemIndex + 1) :
            (activeItemIndex === 0 ? itemsCount - 1 : activeItemIndex - 1);
    }
    reset() {
        this.state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
        };
    }
}
CarouselState.ɵfac = function CarouselState_Factory(t) { return new (t || CarouselState)(ɵngcc0.ɵɵinject(CarouselService)); };
CarouselState.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselState, factory: CarouselState.ɵfac });
CarouselState.ctorParameters = () => [
    { type: CarouselService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselState, [{
        type: Injectable
    }], function () { return [{ type: CarouselService }]; }, null); })();

class CarouselConfig {
    constructor() {
        this.activeIndex = 0;
        this.animate = true;
        this.direction = 'next';
        this.interval = 3000;
    }
}
CarouselConfig.ɵfac = function CarouselConfig_Factory(t) { return new (t || CarouselConfig)(); };
CarouselConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselConfig, factory: CarouselConfig.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{
        type: Injectable
    }], function () { return []; }, null); })();

class CarouselComponent {
    constructor(config, carouselService, carouselState) {
        this.config = config;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.activeIndex = 0;
        this.animate = true;
        this.direction = 'next';
        this.interval = 0;
        this.itemChange = new EventEmitter();
        this.carouselClass = true;
        this.carouselSlideClass = true;
        Object.assign(this, config);
    }
    onMouseenter($event) {
        this.resetTimer();
    }
    onMouseleave($event) {
        this.setTimer();
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    ngAfterContentInit() {
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setTimer();
    }
    setTimer() {
        this.resetTimer();
        if (this.interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, this.interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                if ('active' in nextIndex) {
                    this.setTimer();
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselComponent.ɵfac = function CarouselComponent_Factory(t) { return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(CarouselService), ɵngcc0.ɵɵdirectiveInject(CarouselState)); };
CarouselComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselComponent, selectors: [["c-carousel"]], hostVars: 4, hostBindings: function CarouselComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function CarouselComponent_mouseenter_HostBindingHandler($event) { return ctx.onMouseenter($event); })("mousedown", function CarouselComponent_mousedown_HostBindingHandler($event) { return ctx.onMouseenter($event); })("mouseleave", function CarouselComponent_mouseleave_HostBindingHandler($event) { return ctx.onMouseleave($event); })("mouseup", function CarouselComponent_mouseup_HostBindingHandler($event) { return ctx.onMouseleave($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("carousel", ctx.carouselClass)("slide", ctx.carouselSlideClass);
    } }, inputs: { activeIndex: "activeIndex", animate: "animate", direction: "direction", interval: "interval" }, outputs: { itemChange: "itemChange" }, features: [ɵngcc0.ɵɵProvidersFeature([CarouselService, CarouselState, CarouselConfig])], ngContentSelectors: _c0, decls: 1, vars: 0, template: function CarouselComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
CarouselComponent.ctorParameters = () => [
    { type: CarouselConfig, decorators: [{ type: Inject, args: [CarouselConfig,] }] },
    { type: CarouselService },
    { type: CarouselState }
];
CarouselComponent.propDecorators = {
    activeIndex: [{ type: Input }],
    animate: [{ type: Input }],
    direction: [{ type: Input }],
    interval: [{ type: Input }],
    itemChange: [{ type: Output }],
    carouselClass: [{ type: HostBinding, args: ['class.carousel',] }],
    carouselSlideClass: [{ type: HostBinding, args: ['class.slide',] }],
    onMouseenter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] }],
    onMouseleave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel',
                template: "<ng-content></ng-content>\n",
                providers: [CarouselService, CarouselState, CarouselConfig],
                styles: [":host{display:block}"]
            }]
    }], function () { return [{ type: CarouselConfig, decorators: [{
                type: Inject,
                args: [CarouselConfig]
            }] }, { type: CarouselService }, { type: CarouselState }]; }, { activeIndex: [{
            type: Input
        }], animate: [{
            type: Input
        }], direction: [{
            type: Input
        }], interval: [{
            type: Input
        }], itemChange: [{
            type: Output
        }], carouselClass: [{
            type: HostBinding,
            args: ['class.carousel']
        }], carouselSlideClass: [{
            type: HostBinding,
            args: ['class.slide']
        }], onMouseenter: [{
            type: HostListener,
            args: ['mouseenter', ['$event']]
        }, {
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], onMouseleave: [{
            type: HostListener,
            args: ['mouseleave', ['$event']]
        }, {
            type: HostListener,
            args: ['mouseup', ['$event']]
        }] }); })();

class CarouselCaptionComponent {
    constructor() {
        this.carouselCaptionClass = true;
    }
    ngOnInit() {
    }
}
CarouselCaptionComponent.ɵfac = function CarouselCaptionComponent_Factory(t) { return new (t || CarouselCaptionComponent)(); };
CarouselCaptionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselCaptionComponent, selectors: [["c-carousel-caption"]], hostVars: 2, hostBindings: function CarouselCaptionComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("carousel-caption", ctx.carouselCaptionClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CarouselCaptionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
CarouselCaptionComponent.ctorParameters = () => [];
CarouselCaptionComponent.propDecorators = {
    carouselCaptionClass: [{ type: HostBinding, args: ['class.carousel-caption',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselCaptionComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel-caption',
                template: "<ng-content></ng-content>\n\n",
                styles: [""]
            }]
    }], function () { return []; }, { carouselCaptionClass: [{
            type: HostBinding,
            args: ['class.carousel-caption']
        }] }); })();

class CarouselControlComponent {
    constructor(changeDetector, carouselState) {
        this.changeDetector = changeDetector;
        this.carouselState = carouselState;
        this.direction = 'next';
        this.hasContent = true;
    }
    get hostRole() {
        return 'button';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get carouselControlClass() {
        return `carousel-control-${this.direction}`;
    }
    get carouselControlIconClass() {
        return `carousel-control-${this.direction}-icon`;
    }
    get hostClasses() {
        const classes = classNames(this.carouselControlClass);
        return classes;
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.play();
        }
        if ($event.key === 'ArrowLeft') {
            this.play('prev');
        }
        if ($event.key === 'ArrowRight') {
            this.play('next');
        }
    }
    onClick($event) {
        this.play();
    }
    ngOnInit() { }
    ngAfterViewInit() {
        this.hasContent = this.content.nativeElement.childNodes.length;
        this.changeDetector.detectChanges();
    }
    play(direction = this.direction) {
        const nextIndex = this.carouselState.direction(direction);
        this.carouselState.state = { activeItemIndex: nextIndex };
    }
}
CarouselControlComponent.ɵfac = function CarouselControlComponent_Factory(t) { return new (t || CarouselControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(CarouselState)); };
CarouselControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselControlComponent, selectors: [["c-carousel-control"]], viewQuery: function CarouselControlComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c7, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, hostVars: 3, hostBindings: function CarouselControlComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup", function CarouselControlComponent_keyup_HostBindingHandler($event) { return ctx.onKeyUp($event); })("click", function CarouselControlComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { direction: "direction" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["default", ""], ["content", ""]], template: function CarouselControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CarouselControlComponent_div_0_Template, 3, 0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, CarouselControlComponent_ng_template_1_Template, 1, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasContent)("ngIfElse", _r1);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
CarouselControlComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: CarouselState }
];
CarouselControlComponent.propDecorators = {
    direction: [{ type: Input }],
    content: [{ type: ViewChild, args: ['content',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselControlComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel-control',
                template: "<div #content *ngIf = \"hasContent; else default\"><ng-content></ng-content></div>\n<ng-template #default>\n  <span [class]=\"carouselControlIconClass\" [attr.aria-label]=\"direction\"></span>\n</ng-template>\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: CarouselState }]; }, { direction: [{
            type: Input
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], onKeyUp: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], content: [{
            type: ViewChild,
            args: ['content']
        }] }); })();

class CarouselIndicatorsComponent {
    constructor(carouselService, carouselState) {
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.items = [];
        this.active = 0;
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    onClick(index) {
        if (index !== this.active) {
            const direction = index < this.active ? 'prev' : 'next';
            this.carouselState.state = { direction, activeItemIndex: index };
        }
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                var _a, _b, _c;
                this.items = (_c = (_b = (_a = this.carouselState) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.map(item => item.index);
                if ('active' in nextIndex) {
                    this.active = nextIndex.active;
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselIndicatorsComponent.ɵfac = function CarouselIndicatorsComponent_Factory(t) { return new (t || CarouselIndicatorsComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselService), ɵngcc0.ɵɵdirectiveInject(CarouselState)); };
CarouselIndicatorsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselIndicatorsComponent, selectors: [["c-carousel-indicators"]], decls: 2, vars: 1, consts: [[1, "carousel-indicators"], [4, "ngFor", "ngForOf"], [3, "click"]], template: function CarouselIndicatorsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ol", 0);
        ɵngcc0.ɵɵtemplate(1, CarouselIndicatorsComponent_ng_container_1_Template, 2, 4, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc3.NgForOf], styles: [""] });
CarouselIndicatorsComponent.ctorParameters = () => [
    { type: CarouselService },
    { type: CarouselState }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselIndicatorsComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel-indicators',
                template: "<ol class=\"carousel-indicators\">\n  <ng-container *ngFor=\"let item of items; let i=index\">\n    <li (click)=\"onClick(i)\" [class]=\"{active: active === i}\"></li>\n  </ng-container>\n</ol>\n",
                styles: [""]
            }]
    }], function () { return [{ type: CarouselService }, { type: CarouselState }]; }, null); })();

function toLeft(fromState, toState) {
    return toState.left === true;
}
function toRight(fromState, toState) {
    return toState.left === false;
}
const slideAnimation = trigger('slideAnimation', [
    state('*', style({ transform: 'translateX(0)', display: 'block', opacity: 1 })),
    transition(toLeft, group([
        query(':leave', [
            animate('0.6s ease-in-out', style({
                transform: 'translateX(-100%)',
            })),
        ], { optional: true }),
        query(':enter', [
            style({
                transform: 'translateX(100%)',
            }),
            animate('0.6s ease-in-out', style('*')),
        ], { optional: true }),
    ])),
    transition(toRight, group([
        query(':enter', [
            style({
                transform: 'translateX(-100%)',
            }),
            animate('0.6s ease-in-out', style('*')),
        ], { optional: true }),
        query(':leave', [
            animate('0.6s ease-in-out', style({
                transform: 'translateX(100%)',
            })),
        ], { optional: true }),
    ])),
]);

class CarouselItemComponent {
    constructor(carouselService) {
        this.carouselService = carouselService;
    }
    set active(active) {
        this._active = active;
    }
    get active() {
        return this._active;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'carousel-item': true,
            active: this.active,
        });
        return classes;
    }
    ngOnInit() { }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.carouselStateSubscribe();
        });
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                if ('active' in nextIndex) {
                    this.active = nextIndex.active === this.index;
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselItemComponent.ɵfac = function CarouselItemComponent_Factory(t) { return new (t || CarouselItemComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselService)); };
CarouselItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselItemComponent, selectors: [["c-carousel-item"]], hostVars: 2, hostBindings: function CarouselItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { active: "active" }, ngContentSelectors: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function CarouselItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CarouselItemComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.active);
    } }, directives: [ɵngcc3.NgIf], styles: ["[_nghost-%COMP%]{display:block}"] });
CarouselItemComponent.ctorParameters = () => [
    { type: CarouselService }
];
CarouselItemComponent.propDecorators = {
    active: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselItemComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel-item',
                template: "<ng-content *ngIf=\"active\"></ng-content>\n",
                styles: [":host{display:block}"]
            }]
    }], function () { return [{ type: CarouselService }]; }, { active: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class CarouselInnerComponent {
    constructor(carouselState) {
        this.carouselState = carouselState;
        this.carouselInnerClass = true;
        this.slide = { left: true };
    }
    ngOnInit() { }
    ngAfterContentInit() {
        this.setItems();
    }
    ngAfterContentChecked() {
        var _a;
        this.setItems();
        const state = (_a = this.carouselState) === null || _a === void 0 ? void 0 : _a.state;
        const nextIndex = state === null || state === void 0 ? void 0 : state.activeItemIndex;
        const nextDirection = state === null || state === void 0 ? void 0 : state.direction;
        if (this.activeIndex !== nextIndex) {
            this.animate = state === null || state === void 0 ? void 0 : state.animate;
            this.slide = { left: nextDirection === 'next' };
            this.activeIndex = state === null || state === void 0 ? void 0 : state.activeItemIndex;
        }
    }
    setItems() {
        if (this.prevContentItems !== this.contentItems) {
            this.prevContentItems = this.contentItems;
            this.carouselState.setItems(this.contentItems);
        }
    }
}
CarouselInnerComponent.ɵfac = function CarouselInnerComponent_Factory(t) { return new (t || CarouselInnerComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselState)); };
CarouselInnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselInnerComponent, selectors: [["c-carousel-inner"]], contentQueries: function CarouselInnerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CarouselItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
    } }, hostVars: 2, hostBindings: function CarouselInnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("carousel-inner", ctx.carouselInnerClass);
    } }, ngContentSelectors: _c0, decls: 2, vars: 2, template: function CarouselInnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@slideAnimation", ctx.slide)("@.disabled", !ctx.animate);
    } }, styles: ["[_nghost-%COMP%]{display:block}"], data: { animation: [slideAnimation] } });
CarouselInnerComponent.ctorParameters = () => [
    { type: CarouselState }
];
CarouselInnerComponent.propDecorators = {
    carouselInnerClass: [{ type: HostBinding, args: ['class.carousel-inner',] }],
    contentItems: [{ type: ContentChildren, args: [CarouselItemComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselInnerComponent, [{
        type: Component,
        args: [{
                selector: 'c-carousel-inner',
                template: "<div [@slideAnimation]=\"slide\" [@.disabled]=\"!animate\">\n  <ng-content></ng-content>\n</div>\n",
                animations: [slideAnimation],
                styles: [":host{display:block}"]
            }]
    }], function () { return [{ type: CarouselState }]; }, { carouselInnerClass: [{
            type: HostBinding,
            args: ['class.carousel-inner']
        }], contentItems: [{
            type: ContentChildren,
            args: [CarouselItemComponent]
        }] }); })();

class CarouselModule {
    static forRoot() {
        return { ngModule: CarouselModule, providers: [] };
    }
}
CarouselModule.ɵfac = function CarouselModule_Factory(t) { return new (t || CarouselModule)(); };
CarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CarouselModule });
CarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [CarouselService, CarouselState, CarouselConfig], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, { declarations: function () { return [CarouselComponent, CarouselCaptionComponent, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CarouselComponent, CarouselCaptionComponent, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CarouselComponent,
                    CarouselCaptionComponent,
                    CarouselControlComponent,
                    CarouselIndicatorsComponent,
                    CarouselInnerComponent,
                    CarouselItemComponent,
                ],
                imports: [CommonModule],
                providers: [CarouselService, CarouselState, CarouselConfig],
                exports: [
                    CarouselComponent,
                    CarouselCaptionComponent,
                    CarouselControlComponent,
                    CarouselIndicatorsComponent,
                    CarouselInnerComponent,
                    CarouselItemComponent,
                ]
            }]
    }], null, null); })();

class DropdownService {
    constructor() {
        this.dropdownState = new BehaviorSubject({});
        this.dropdownState$ = this.dropdownState.asObservable();
    }
    toggle(state) {
        this.dropdownState.next(state);
    }
}
DropdownService.ɵfac = function DropdownService_Factory(t) { return new (t || DropdownService)(); };
DropdownService.ɵprov = ɵɵdefineInjectable({ factory: function DropdownService_Factory() { return new DropdownService(); }, token: DropdownService, providedIn: "root" });
DropdownService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class DropdownState {
    constructor() {
        this.state = {
            align: '',
            caret: 'caret',
            direction: 'down',
            show: false,
        };
    }
    getState() {
        return Object.assign(Object.create(null), this.state);
    }
    setState(state) {
        this.state = Object.assign(this.state, state);
        return this.getState();
    }
}
DropdownState.ɵfac = function DropdownState_Factory(t) { return new (t || DropdownState)(); };
DropdownState.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DropdownState, factory: DropdownState.ɵfac });
DropdownState.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownState, [{
        type: Injectable
    }], function () { return []; }, null); })();

class DropdownDirective {
    constructor(renderer, hostElement, outClickService, dropdownService, dropdownState) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.outClickService = outClickService;
        this.dropdownService = dropdownService;
        this.dropdownState = dropdownState;
        this.direction = 'down';
        this.cDropdownAlign = '';
    }
    ngOnInit() {
        const state = { show: this.cDropdownShow, align: this.cDropdownAlign, direction: this.direction };
        this.state = this.dropdownState.setState(state);
        const dropdownClass = `drop${this.direction || 'down'}`;
        this.renderer.addClass(this.hostElement.nativeElement, dropdownClass);
        this.stateToggleSubscribe();
        this.outClickSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.outClickSubscribe(false);
    }
    ngOnChanges(changes) {
        if (changes.direction) {
            this.renderer.removeClass(this.hostElement.nativeElement, `drop${changes.direction.previousValue || 'down'}`);
            this.renderer.addClass(this.hostElement.nativeElement, `drop${changes.direction.currentValue || 'down'}`);
        }
        if (changes.cDropdownShow) {
            const state = { show: changes.cDropdownShow.currentValue };
            this.state = this.dropdownState.setState(state);
            this.dropdownService.toggle(this.state);
        }
    }
    ngAfterViewInit() {
        this.cDropdownShow = this.state.show;
        this.dropdownService.toggle(this.state);
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.dropdownService.dropdownState$.subscribe((state) => {
                if ('show' in state) {
                    this.show(state.show);
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
    show(show) {
        this.cDropdownShow = show;
        this.state = this.dropdownState.setState({ show });
        show ?
            this.renderer.addClass(this.hostElement.nativeElement, 'show') :
            this.renderer.removeClass(this.hostElement.nativeElement, 'show');
    }
    toggle() {
        this.show(!this.state.show);
    }
    outClickSubscribe(subscribe = true) {
        if (subscribe) {
            this.outClickSubscription = this.outClickService.outClick$.subscribe(message => {
                if (message.event) {
                    this.autoClose(message.event);
                }
            });
        }
        else {
            this.outClickSubscription.unsubscribe();
        }
    }
    autoClose(e) {
        const state = this.dropdownState.getState();
        if (state.show) {
            if (!this.hostElement.nativeElement.contains(e.target.closest('[cDropdownToggle]'))) {
                this.cDropdownShow = false;
                this.dropdownService.toggle({ show: false });
            }
        }
    }
}
DropdownDirective.ɵfac = function DropdownDirective_Factory(t) { return new (t || DropdownDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(OutClickService), ɵngcc0.ɵɵdirectiveInject(DropdownService), ɵngcc0.ɵɵdirectiveInject(DropdownState)); };
DropdownDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownDirective, selectors: [["", "cDropdown", ""], ["c-dropdown"]], hostVars: 1, hostBindings: function DropdownDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.cDropdownShow);
    } }, inputs: { direction: ["cDropdown", "direction"], cDropdownAlign: "cDropdownAlign", cDropdownShow: "cDropdownShow" }, exportAs: ["cDropdown"], features: [ɵngcc0.ɵɵProvidersFeature([DropdownService, DropdownState]), ɵngcc0.ɵɵNgOnChangesFeature] });
DropdownDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: OutClickService },
    { type: DropdownService },
    { type: DropdownState }
];
DropdownDirective.propDecorators = {
    direction: [{ type: Input, args: ['cDropdown',] }],
    cDropdownAlign: [{ type: Input }],
    cDropdownShow: [{ type: Input }, { type: HostBinding, args: ['attr.aria-expanded',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdown], c-dropdown',
                exportAs: 'cDropdown',
                providers: [DropdownService, DropdownState]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: OutClickService }, { type: DropdownService }, { type: DropdownState }]; }, { direction: [{
            type: Input,
            args: ['cDropdown']
        }], cDropdownAlign: [{
            type: Input
        }], cDropdownShow: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-expanded']
        }] }); })();

class DropdownMenuDirective {
    constructor(renderer, hostElement, dropdownState, dropdownService) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.dropdownState = dropdownState;
        this.dropdownService = dropdownService;
        this.role = 'menu';
        this.dropdownMenu = true;
        this.host = this.hostElement.nativeElement;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
    }
    show(show) {
        const className = 'show';
        show ?
            this.renderer.addClass(this.host, className) :
            this.renderer.removeClass(this.host, className);
    }
    align(align) {
        if (align) {
            const className = `dropdown-menu-${align}`;
            this.renderer.addClass(this.host, className);
        }
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.dropdownService.dropdownState$.subscribe((state) => {
                if ('show' in state) {
                    this.show(state.show);
                }
                if ('align' in state) {
                    this.align(state.align);
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
}
DropdownMenuDirective.ɵfac = function DropdownMenuDirective_Factory(t) { return new (t || DropdownMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DropdownState), ɵngcc0.ɵɵdirectiveInject(DropdownService)); };
DropdownMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownMenuDirective, selectors: [["", "cDropdownMenu", ""], ["c-dropdown-menu"]], hostVars: 3, hostBindings: function DropdownMenuDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("dropdown-menu", ctx.dropdownMenu);
    } }, exportAs: ["cDropdownMenu"] });
DropdownMenuDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DropdownState },
    { type: DropdownService }
];
DropdownMenuDirective.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    dropdownMenu: [{ type: HostBinding, args: ['class.dropdown-menu',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownMenuDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdownMenu], c-dropdown-menu',
                exportAs: 'cDropdownMenu'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: DropdownState }, { type: DropdownService }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], dropdownMenu: [{
            type: HostBinding,
            args: ['class.dropdown-menu']
        }] }); })();

class DropdownToggleDirective {
    constructor(renderer, hostElement, dropdown, dropdownService, dropdownState) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.dropdown = dropdown;
        this.dropdownService = dropdownService;
        this.dropdownState = dropdownState;
        this.cDropdownCaret = 'caret';
        this.host = this.hostElement.nativeElement;
    }
    ngOnInit() {
        this.state = this.dropdownState.setState({ caret: this.cDropdownCaret });
        const toggleClass = 'dropdown-toggle';
        if (this.state.caret === 'none') {
            this.renderer.removeClass(this.host, toggleClass);
        }
        else {
            this.renderer.addClass(this.host, toggleClass);
            if (this.state.caret === 'split') {
                this.renderer.addClass(this.host, `${toggleClass}-split`);
            }
        }
    }
    toggleShow($event) {
        $event.preventDefault();
        this.state = this.dropdownState.getState();
        this.dropdownService.toggle({ show: !this.state.show });
    }
}
DropdownToggleDirective.ɵfac = function DropdownToggleDirective_Factory(t) { return new (t || DropdownToggleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DropdownDirective), ɵngcc0.ɵɵdirectiveInject(DropdownService), ɵngcc0.ɵɵdirectiveInject(DropdownState)); };
DropdownToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownToggleDirective, selectors: [["", "cDropdownToggle", ""], ["c-dropdown-toggle"]], hostBindings: function DropdownToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function DropdownToggleDirective_click_HostBindingHandler($event) { return ctx.toggleShow($event); });
    } }, inputs: { cDropdownCaret: "cDropdownCaret" }, exportAs: ["cDropdownToggle"] });
DropdownToggleDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DropdownDirective },
    { type: DropdownService },
    { type: DropdownState }
];
DropdownToggleDirective.propDecorators = {
    cDropdownCaret: [{ type: Input }],
    toggleShow: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdownToggle], c-dropdown-toggle',
                exportAs: 'cDropdownToggle'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: DropdownDirective }, { type: DropdownService }, { type: DropdownState }]; }, { cDropdownCaret: [{
            type: Input
        }], toggleShow: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

class DropdownHeaderDirective {
    constructor() {
        this.dropdownHeader = true;
    }
}
DropdownHeaderDirective.ɵfac = function DropdownHeaderDirective_Factory(t) { return new (t || DropdownHeaderDirective)(); };
DropdownHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownHeaderDirective, selectors: [["", "cDropdownHeader", ""], ["c-dropdown-header"]], hostVars: 2, hostBindings: function DropdownHeaderDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("dropdown-header", ctx.dropdownHeader);
    } }, exportAs: ["cDropdownHeader"] });
DropdownHeaderDirective.propDecorators = {
    dropdownHeader: [{ type: HostBinding, args: ['class.dropdown-header',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdownHeader], c-dropdown-header',
                exportAs: 'cDropdownHeader'
            }]
    }], function () { return []; }, { dropdownHeader: [{
            type: HostBinding,
            args: ['class.dropdown-header']
        }] }); })();

class DropdownDividerDirective {
    constructor() {
        this.dropdownDivider = true;
    }
}
DropdownDividerDirective.ɵfac = function DropdownDividerDirective_Factory(t) { return new (t || DropdownDividerDirective)(); };
DropdownDividerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownDividerDirective, selectors: [["", "cDropdownDivider", ""], ["c-dropdown-divider"]], hostVars: 2, hostBindings: function DropdownDividerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("dropdown-divider", ctx.dropdownDivider);
    } }, exportAs: ["cDropdownDivider"] });
DropdownDividerDirective.propDecorators = {
    dropdownDivider: [{ type: HostBinding, args: ['class.dropdown-divider',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownDividerDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdownDivider], c-dropdown-divider',
                exportAs: 'cDropdownDivider'
            }]
    }], function () { return []; }, { dropdownDivider: [{
            type: HostBinding,
            args: ['class.dropdown-divider']
        }] }); })();

class DropdownItemDirective {
    constructor() {
        this.dropdownItem = true;
    }
}
DropdownItemDirective.ɵfac = function DropdownItemDirective_Factory(t) { return new (t || DropdownItemDirective)(); };
DropdownItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropdownItemDirective, selectors: [["", "cDropdownItem", ""], ["c-dropdown-item"]], hostVars: 2, hostBindings: function DropdownItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("dropdown-item", ctx.dropdownItem);
    } }, exportAs: ["cDropdownItem"] });
DropdownItemDirective.propDecorators = {
    dropdownItem: [{ type: HostBinding, args: ['class.dropdown-item',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownItemDirective, [{
        type: Directive,
        args: [{
                selector: '[cDropdownItem], c-dropdown-item',
                exportAs: 'cDropdownItem'
            }]
    }], function () { return []; }, { dropdownItem: [{
            type: HostBinding,
            args: ['class.dropdown-item']
        }] }); })();

class DropdownDividerComponent {
}
DropdownDividerComponent.ɵfac = function DropdownDividerComponent_Factory(t) { return new (t || DropdownDividerComponent)(); };
DropdownDividerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DropdownDividerComponent, selectors: [["c-dropdown-divider"]], decls: 1, vars: 0, consts: [[1, "dropdown-divider"]], template: function DropdownDividerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } }, styles: [""] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownDividerComponent, [{
        type: Component,
        args: [{
                selector: 'c-dropdown-divider',
                template: '<div class="dropdown-divider"></div>',
                styles: [""]
            }]
    }], null, null); })();

class DropdownModule {
    static forRoot(config) {
        return {
            ngModule: DropdownModule,
            providers: []
        };
    }
}
DropdownModule.ɵfac = function DropdownModule_Factory(t) { return new (t || DropdownModule)(); };
DropdownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DropdownModule });
DropdownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        DropdownService,
        DropdownState
    ], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DropdownModule, { declarations: function () { return [DropdownDirective, DropdownToggleDirective, DropdownMenuDirective, DropdownHeaderDirective, DropdownDividerDirective, DropdownItemDirective, DropdownDividerComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DropdownDirective, DropdownToggleDirective, DropdownMenuDirective, DropdownItemDirective, DropdownDividerDirective, DropdownHeaderDirective, DropdownDividerComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DropdownModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DropdownDirective,
                    DropdownToggleDirective,
                    DropdownMenuDirective,
                    DropdownHeaderDirective,
                    DropdownDividerDirective,
                    DropdownItemDirective,
                    DropdownDividerComponent
                ],
                exports: [
                    DropdownDirective,
                    DropdownToggleDirective,
                    DropdownMenuDirective,
                    DropdownItemDirective,
                    DropdownDividerDirective,
                    DropdownHeaderDirective,
                    DropdownDividerComponent
                ],
                imports: [
                    CommonModule
                ],
                providers: [
                    DropdownService,
                    DropdownState
                ]
            }]
    }], null, null); })();

class EmbedItemDirective {
    constructor() {
        this.embedItemClass = true;
    }
}
EmbedItemDirective.ɵfac = function EmbedItemDirective_Factory(t) { return new (t || EmbedItemDirective)(); };
EmbedItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EmbedItemDirective, selectors: [["", "cEmbedItem", ""]], hostVars: 2, hostBindings: function EmbedItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("embed-responsive-item", ctx.embedItemClass);
    } } });
EmbedItemDirective.ctorParameters = () => [];
EmbedItemDirective.propDecorators = {
    embedItemClass: [{ type: HostBinding, args: ['class.embed-responsive-item',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EmbedItemDirective, [{
        type: Directive,
        args: [{
                selector: '[cEmbedItem]'
            }]
    }], function () { return []; }, { embedItemClass: [{
            type: HostBinding,
            args: ['class.embed-responsive-item']
        }] }); })();

class EmbedComponent {
    constructor() {
        this.ratio = '16by9';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'embed-responsive': true,
            [`embed-responsive-${this.ratio}`]: !!this.ratio,
        });
        return classes;
    }
    ngOnInit() { }
    ngAfterContentInit() {
    }
}
EmbedComponent.ɵfac = function EmbedComponent_Factory(t) { return new (t || EmbedComponent)(); };
EmbedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EmbedComponent, selectors: [["c-embed"]], contentQueries: function EmbedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, EmbedItemDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.embedItem = _t.first);
    } }, hostVars: 2, hostBindings: function EmbedComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { ratio: "ratio" }, ngContentSelectors: _c10, decls: 1, vars: 0, template: function EmbedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c9);
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
EmbedComponent.ctorParameters = () => [];
EmbedComponent.propDecorators = {
    ratio: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    embedItem: [{ type: ContentChild, args: [EmbedItemDirective,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EmbedComponent, [{
        type: Component,
        args: [{
                selector: 'c-embed',
                template: "<ng-content select=\"iframe\"></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { ratio: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], embedItem: [{
            type: ContentChild,
            args: [EmbedItemDirective]
        }] }); })();

class EmbedModule {
}
EmbedModule.ɵfac = function EmbedModule_Factory(t) { return new (t || EmbedModule)(); };
EmbedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EmbedModule });
EmbedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EmbedModule, { declarations: function () { return [EmbedComponent, EmbedItemDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [EmbedComponent, EmbedItemDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EmbedModule, [{
        type: NgModule,
        args: [{
                declarations: [EmbedComponent, EmbedItemDirective],
                imports: [CommonModule],
                exports: [EmbedComponent, EmbedItemDirective]
            }]
    }], null, null); })();

function chkBoolProp(prop) {
    return Boolean(prop != null && prop !== false);
}

class FormDirective {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-inline': chkBoolProp(this.inline),
            'was-validated': chkBoolProp(this.wasValidated),
        };
        return classes;
    }
}
FormDirective.ɵfac = function FormDirective_Factory(t) { return new (t || FormDirective)(); };
FormDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FormDirective, selectors: [["", "cForm", ""]], hostVars: 2, hostBindings: function FormDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { inline: "inline", wasValidated: "wasValidated" } });
FormDirective.ctorParameters = () => [];
FormDirective.propDecorators = {
    inline: [{ type: Input }],
    wasValidated: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormDirective, [{
        type: Directive,
        args: [{
                selector: '[cForm]'
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], inline: [{
            type: Input
        }], wasValidated: [{
            type: Input
        }] }); })();

class FormGroupComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-group': true,
            disabled: chkBoolProp(this.disabled)
        };
        return classes;
    }
    ngOnInit() {
    }
}
FormGroupComponent.ɵfac = function FormGroupComponent_Factory(t) { return new (t || FormGroupComponent)(); };
FormGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FormGroupComponent, selectors: [["c-form-group"]], hostVars: 2, hostBindings: function FormGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { inline: "inline", disabled: "disabled" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FormGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]:not(.row):not(.form-check-inline):not(.custom-control-inline){display:block}"] });
FormGroupComponent.ctorParameters = () => [];
FormGroupComponent.propDecorators = {
    inline: [{ type: Input }],
    disabled: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormGroupComponent, [{
        type: Component,
        args: [{
                selector: 'c-form-group',
                template: "<ng-content></ng-content>\n",
                styles: [":host:not(.row):not(.form-check-inline):not(.custom-control-inline){display:block}"]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], inline: [{
            type: Input
        }], disabled: [{
            type: Input
        }] }); })();

class FormFeedbackComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const validMode = this.tooltip ? 'tooltip' : 'feedback';
        const classes = {
            [`valid-${validMode}`]: this.valid === true,
            [`invalid-${validMode}`]: this.valid !== true,
        };
        return classes;
    }
}
FormFeedbackComponent.ɵfac = function FormFeedbackComponent_Factory(t) { return new (t || FormFeedbackComponent)(); };
FormFeedbackComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FormFeedbackComponent, selectors: [["c-form-feedback"]], hostVars: 2, hostBindings: function FormFeedbackComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { valid: "valid", tooltip: "tooltip" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FormFeedbackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
FormFeedbackComponent.ctorParameters = () => [];
FormFeedbackComponent.propDecorators = {
    valid: [{ type: Input }],
    tooltip: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormFeedbackComponent, [{
        type: Component,
        args: [{
                selector: 'c-form-feedback',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], valid: [{
            type: Input
        }], tooltip: [{
            type: Input
        }] }); })();

class FormTextComponent {
    constructor() {
        this.tag = 'small';
        this.color = 'muted';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-text': true,
            [`${this.tag}`]: true,
            [`text-${this.color}`]: !!this.color,
        };
        return classes;
    }
}
FormTextComponent.ɵfac = function FormTextComponent_Factory(t) { return new (t || FormTextComponent)(); };
FormTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FormTextComponent, selectors: [["c-form-text"]], hostVars: 2, hostBindings: function FormTextComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { tag: "tag", color: "color" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FormTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
FormTextComponent.ctorParameters = () => [];
FormTextComponent.propDecorators = {
    tag: [{ type: Input }],
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormTextComponent, [{
        type: Component,
        args: [{
                selector: 'c-form-text',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { tag: [{
            type: Input
        }], color: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class InputDirective {
    constructor(hostElement) {
        this.hostElement = hostElement;
        this.sizing = '';
        this.type = 'text';
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isPlainText = this.isPlainText;
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'form-control': !isPlainText && this.isFormControl,
            'form-control-plaintext': isPlainText,
            'form-control-range': this.type === 'range',
            'form-control-file': this.type === 'file' && !isCustom,
            'custom-file-input': this.type === 'file' && isCustom,
            'form-check-input': this.isFormCheck && !isCustom,
            'custom-control-input': this.isFormCheck && isCustom,
            [`form-control-${this.sizing}`]: !!this.sizing,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
    get isPlainText() {
        return chkBoolProp(this.plaintext);
    }
    get isFormControl() {
        const nonTextControls = ['range', 'checkbox', 'radio', 'file'];
        return !nonTextControls.includes(this.type);
    }
    get isFormCheck() {
        const formCheck = ['checkbox', 'radio'];
        return formCheck.includes(this.type);
    }
    ngOnInit() { }
    get attributes() {
        return this.host.getAttributeNames();
    }
    get isReadonly() {
        return this.host.getAttribute('readonly') != null;
    }
    get isDisabled() {
        return this.host.getAttribute('disabled') != null;
    }
}
InputDirective.ɵfac = function InputDirective_Factory(t) { return new (t || InputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
InputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: InputDirective, selectors: [["", "cInput", ""]], hostVars: 3, hostBindings: function InputDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("type", ctx.type);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { sizing: "sizing", type: "type", valid: "valid", plaintext: "plaintext", custom: "custom" } });
InputDirective.ctorParameters = () => [
    { type: ElementRef }
];
InputDirective.propDecorators = {
    valid: [{ type: Input }],
    plaintext: [{ type: Input }],
    sizing: [{ type: Input }],
    custom: [{ type: Input }],
    type: [{ type: HostBinding, args: ['type',] }, { type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputDirective, [{
        type: Directive,
        args: [{
                selector: '[cInput]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { sizing: [{
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['type']
        }, {
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], valid: [{
            type: Input
        }], plaintext: [{
            type: Input
        }], custom: [{
            type: Input
        }] }); })();

class InputGroupComponent {
    constructor() {
        this.size = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'input-group': true,
            [`input-group-${this.size}`]: !!this.size,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupComponent.ɵfac = function InputGroupComponent_Factory(t) { return new (t || InputGroupComponent)(); };
InputGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InputGroupComponent, selectors: [["c-input-group"]], hostVars: 2, hostBindings: function InputGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { size: "size" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function InputGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
InputGroupComponent.ctorParameters = () => [];
InputGroupComponent.propDecorators = {
    size: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputGroupComponent, [{
        type: Component,
        args: [{
                selector: 'c-input-group',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class InputGroupTextComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'input-group-text': true,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupTextComponent.ɵfac = function InputGroupTextComponent_Factory(t) { return new (t || InputGroupTextComponent)(); };
InputGroupTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InputGroupTextComponent, selectors: [["c-input-group-text"]], hostVars: 2, hostBindings: function InputGroupTextComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function InputGroupTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
InputGroupTextComponent.ctorParameters = () => [];
InputGroupTextComponent.propDecorators = {
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputGroupTextComponent, [{
        type: Component,
        args: [{
                selector: 'c-input-group-text',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class InputGroupAddonComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const addon = chkBoolProp(this.prepend) ? 'prepend' : 'append';
        const classes = {
            [`input-group-${addon}`]: true,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupAddonComponent.ɵfac = function InputGroupAddonComponent_Factory(t) { return new (t || InputGroupAddonComponent)(); };
InputGroupAddonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InputGroupAddonComponent, selectors: [["ng-component"]], hostVars: 2, hostBindings: function InputGroupAddonComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { prepend: "prepend" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function InputGroupAddonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [_c11] });
InputGroupAddonComponent.ctorParameters = () => [];
InputGroupAddonComponent.propDecorators = {
    prepend: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputGroupAddonComponent, [{
        type: Component,
        args: [{
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], prepend: [{
            type: Input
        }] }); })();
class InputGroupPrependComponent extends InputGroupAddonComponent {
    constructor() {
        super(...arguments);
        this.prepend = true;
    }
}
InputGroupPrependComponent.ɵfac = function InputGroupPrependComponent_Factory(t) { return ɵInputGroupPrependComponent_BaseFactory(t || InputGroupPrependComponent); };
InputGroupPrependComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InputGroupPrependComponent, selectors: [["c-input-group-prepend"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function InputGroupPrependComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [_c11] });
const ɵInputGroupPrependComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(InputGroupPrependComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputGroupPrependComponent, [{
        type: Component,
        args: [{
                selector: 'c-input-group-prepend',
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            }]
    }], null, null); })();
class InputGroupAppendComponent extends InputGroupAddonComponent {
    constructor() {
        super(...arguments);
        this.prepend = false;
    }
}
InputGroupAppendComponent.ɵfac = function InputGroupAppendComponent_Factory(t) { return ɵInputGroupAppendComponent_BaseFactory(t || InputGroupAppendComponent); };
InputGroupAppendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InputGroupAppendComponent, selectors: [["c-input-group-append"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function InputGroupAppendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [_c11] });
const ɵInputGroupAppendComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(InputGroupAppendComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputGroupAppendComponent, [{
        type: Component,
        args: [{
                selector: 'c-input-group-append',
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            }]
    }], null, null); })();

class TextareaDirective {
    constructor() {
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isPlainText = this.isPlainText;
        const classes = classNames({
            'form-control': !isPlainText,
            'form-control-plaintext': isPlainText,
            [`form-control-${this.sizing}`]: !!this.sizing,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
    get isPlainText() {
        return chkBoolProp(this.plaintext);
    }
}
TextareaDirective.ɵfac = function TextareaDirective_Factory(t) { return new (t || TextareaDirective)(); };
TextareaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextareaDirective, selectors: [["", "cTextarea", ""]], hostVars: 2, hostBindings: function TextareaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { sizing: "sizing", valid: "valid", plaintext: "plaintext" } });
TextareaDirective.propDecorators = {
    valid: [{ type: Input }],
    plaintext: [{ type: Input }],
    sizing: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextareaDirective, [{
        type: Directive,
        args: [{
                selector: '[cTextarea]'
            }]
    }], function () { return []; }, { sizing: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], valid: [{
            type: Input
        }], plaintext: [{
            type: Input
        }] }); })();

class SelectDirective {
    constructor() {
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'form-control': !isCustom,
            [`form-control-${this.sizing}`]: !!this.sizing && !isCustom,
            'custom-select': isCustom,
            [`custom-select-${this.sizing}`]: !!this.sizing && isCustom,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
}
SelectDirective.ɵfac = function SelectDirective_Factory(t) { return new (t || SelectDirective)(); };
SelectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SelectDirective, selectors: [["", "cSelect", ""]], hostVars: 2, hostBindings: function SelectDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { sizing: "sizing", valid: "valid", custom: "custom" } });
SelectDirective.ctorParameters = () => [];
SelectDirective.propDecorators = {
    valid: [{ type: Input }],
    custom: [{ type: Input }],
    sizing: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectDirective, [{
        type: Directive,
        args: [{
                selector: '[cSelect]'
            }]
    }], function () { return []; }, { sizing: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], valid: [{
            type: Input
        }], custom: [{
            type: Input
        }] }); })();

class LabelDirective {
    constructor() {
        this.col = '';
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'custom-control-label': isCustom,
            'custom-file-label': isCustom && this.variant === 'file',
            'form-check-label': !isCustom && ['checkbox', 'radio', 'switch'].includes(this.variant),
            'sr-only': chkBoolProp(this.hidden),
            'visually-hidden': chkBoolProp(this.hidden),
            'col-form-label': this.col === 'col',
            [`col-form-label-${this.sizing}`]: !!this.sizing && this.col === 'col',
        });
        return classes;
    }
}
LabelDirective.ɵfac = function LabelDirective_Factory(t) { return new (t || LabelDirective)(); };
LabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LabelDirective, selectors: [["", "cLabel", ""]], hostVars: 2, hostBindings: function LabelDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { col: ["cLabel", "col"], sizing: "sizing", hidden: "hidden", variant: "variant", custom: "custom" } });
LabelDirective.ctorParameters = () => [];
LabelDirective.propDecorators = {
    col: [{ type: Input, args: ['cLabel',] }],
    hidden: [{ type: Input }],
    variant: [{ type: Input }],
    sizing: [{ type: Input }],
    custom: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LabelDirective, [{
        type: Directive,
        args: [{
                selector: '[cLabel]'
            }]
    }], function () { return []; }, { col: [{
            type: Input,
            args: ['cLabel']
        }], sizing: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], hidden: [{
            type: Input
        }], variant: [{
            type: Input
        }], custom: [{
            type: Input
        }] }); })();

class FormCheckComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        if (this.variant === 'switch') {
            this.custom = true;
        }
        const variantClass = this.custom ? 'custom-control' : 'form-check';
        const isCustom = chkBoolProp(this.custom);
        const classes = {
            'form-check': !isCustom,
            'custom-control': isCustom,
            [`custom-${this.variant}`]: !!this.variant,
            [`${variantClass}-inline`]: chkBoolProp(this.inline),
            disabled: chkBoolProp(this.disabled)
        };
        return classes;
    }
    ngOnInit() {
    }
}
FormCheckComponent.ɵfac = function FormCheckComponent_Factory(t) { return new (t || FormCheckComponent)(); };
FormCheckComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FormCheckComponent, selectors: [["c-form-check"]], hostVars: 2, hostBindings: function FormCheckComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { custom: "custom", disabled: "disabled", inline: "inline", variant: "variant" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FormCheckComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
FormCheckComponent.ctorParameters = () => [];
FormCheckComponent.propDecorators = {
    custom: [{ type: Input }],
    disabled: [{ type: Input }],
    inline: [{ type: Input }],
    variant: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormCheckComponent, [{
        type: Component,
        args: [{
                selector: 'c-form-check',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], custom: [{
            type: Input
        }], disabled: [{
            type: Input
        }], inline: [{
            type: Input
        }], variant: [{
            type: Input
        }] }); })();

class FormModule {
}
FormModule.ɵfac = function FormModule_Factory(t) { return new (t || FormModule)(); };
FormModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FormModule });
FormModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormModule, { declarations: function () { return [FormDirective, FormCheckComponent, FormFeedbackComponent, FormGroupComponent, FormTextComponent, InputDirective, InputGroupComponent, InputGroupTextComponent, InputGroupAddonComponent, InputGroupPrependComponent, InputGroupAppendComponent, TextareaDirective, SelectDirective, LabelDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FormDirective, FormCheckComponent, FormFeedbackComponent, FormGroupComponent, FormTextComponent, InputDirective, InputGroupComponent, InputGroupTextComponent, InputGroupPrependComponent, InputGroupAppendComponent, TextareaDirective, SelectDirective, LabelDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    FormDirective,
                    FormCheckComponent,
                    FormFeedbackComponent,
                    FormGroupComponent,
                    FormTextComponent,
                    InputDirective,
                    InputGroupComponent,
                    InputGroupTextComponent,
                    InputGroupAddonComponent,
                    InputGroupPrependComponent,
                    InputGroupAppendComponent,
                    TextareaDirective,
                    SelectDirective,
                    LabelDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    FormDirective,
                    FormCheckComponent,
                    FormFeedbackComponent,
                    FormGroupComponent,
                    FormTextComponent,
                    InputDirective,
                    InputGroupComponent,
                    InputGroupTextComponent,
                    InputGroupPrependComponent,
                    InputGroupAppendComponent,
                    TextareaDirective,
                    SelectDirective,
                    LabelDirective
                ]
            }]
    }], null, null); })();

class ContainerComponent {
    constructor() {
        this.fluid = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            container: !this.fluid,
            'container-fluid': !!this.fluid
        });
        return classes;
    }
}
ContainerComponent.ɵfac = function ContainerComponent_Factory(t) { return new (t || ContainerComponent)(); };
ContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContainerComponent, selectors: [["c-container"], ["", "cContainer", ""]], hostVars: 2, hostBindings: function ContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { fluid: "fluid" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
ContainerComponent.propDecorators = {
    fluid: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContainerComponent, [{
        type: Component,
        args: [{
                selector: 'c-container, [cContainer]',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            }]
    }], function () { return []; }, { fluid: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class RowDirective {
    constructor() {
        this.noGutters = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const alignV = `align-items-${this.alignV}`;
        const alignH = `justify-content-${this.alignH}`;
        const classes = { row: true };
        classes['no-gutters'] = !!this.noGutters;
        classes[alignV] = !!this.alignV;
        classes[alignH] = !!this.alignH;
        return classNames(classes);
    }
}
RowDirective.ɵfac = function RowDirective_Factory(t) { return new (t || RowDirective)(); };
RowDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RowDirective, selectors: [["", "cRow", ""]], hostVars: 2, hostBindings: function RowDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { noGutters: "noGutters", alignV: "alignV", alignH: "alignH" } });
RowDirective.propDecorators = {
    noGutters: [{ type: Input }],
    alignV: [{ type: Input }],
    alignH: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RowDirective, [{
        type: Directive,
        args: [{
                selector: '[cRow]'
            }]
    }], function () { return []; }, { noGutters: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], alignV: [{
            type: Input
        }], alignH: [{
            type: Input
        }] }); })();

class RowComponent extends RowDirective {
}
RowComponent.ɵfac = function RowComponent_Factory(t) { return ɵRowComponent_BaseFactory(t || RowComponent); };
RowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RowComponent, selectors: [["c-row"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function RowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
const ɵRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(RowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RowComponent, [{
        type: Component,
        args: [{
                selector: 'c-row',
                template: '<ng-content></ng-content>',
                styles: [""]
            }]
    }], null, null); })();

class ColDirective {
    constructor() {
        this.suffix = {
            xs: '-xs',
            sm: '-sm',
            md: '-md',
            lg: '-lg',
            xl: '-xl',
            xxl: '-xxl',
            col: ''
        };
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        let classes = Object.create(null);
        const suffix = this.suffix;
        let addColClass = false;
        Object.keys(suffix).forEach((key) => {
            const prop = this[key];
            const breakpoint = suffix[key];
            classes[`col${breakpoint}`] = prop === true;
            classes[`col${breakpoint}-${prop}`] = (typeof prop === 'number') || (typeof prop === 'string');
            if (typeof prop === 'object') {
                classes[`col${breakpoint}-${prop.size}`] = !!prop.size;
                classes[`offset${breakpoint}-${prop.offset}`] = !!prop.offset;
                classes[`order${breakpoint}-${prop.order}`] = !!prop.order;
                addColClass = addColClass || !!prop.offset || !!prop.order;
            }
        });
        classes = classNames(addColClass ? 'col' : '', classes);
        return classes || 'col';
    }
}
ColDirective.ɵfac = function ColDirective_Factory(t) { return new (t || ColDirective)(); };
ColDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColDirective, selectors: [["", "cCol", ""]], hostVars: 2, hostBindings: function ColDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { xs: "xs", sm: "sm", md: "md", lg: "lg", xl: "xl", xxl: "xxl", col: "col" } });
ColDirective.propDecorators = {
    xs: [{ type: Input }],
    sm: [{ type: Input }],
    md: [{ type: Input }],
    lg: [{ type: Input }],
    xl: [{ type: Input }],
    xxl: [{ type: Input }],
    col: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColDirective, [{
        type: Directive,
        args: [{
                selector: '[cCol]'
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], xs: [{
            type: Input
        }], sm: [{
            type: Input
        }], md: [{
            type: Input
        }], lg: [{
            type: Input
        }], xl: [{
            type: Input
        }], xxl: [{
            type: Input
        }], col: [{
            type: Input
        }] }); })();

class ColComponent extends ColDirective {
}
ColComponent.ɵfac = function ColComponent_Factory(t) { return ɵColComponent_BaseFactory(t || ColComponent); };
ColComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColComponent, selectors: [["c-col"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ColComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
const ɵColComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(ColComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColComponent, [{
        type: Component,
        args: [{
                selector: 'c-col',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            }]
    }], null, null); })();

class GridModule {
}
GridModule.ɵfac = function GridModule_Factory(t) { return new (t || GridModule)(); };
GridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: GridModule });
GridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GridModule, { declarations: function () { return [ContainerComponent, RowComponent, ColComponent, RowDirective, ColDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ContainerComponent, RowComponent, ColComponent, RowDirective, ColDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [
                    ContainerComponent,
                    RowComponent,
                    ColComponent,
                    RowDirective,
                    ColDirective,
                ],
                declarations: [
                    ContainerComponent,
                    RowComponent,
                    ColComponent,
                    RowDirective,
                    ColDirective,
                ],
                providers: []
            }]
    }], null, null); })();

class ImgDirective {
    constructor() {
        this.align = '';
        this.placeholderColor = 'transparent';
    }
    get getStyles() {
        return { backgroundColor: this.placeholderColor };
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.alignClass, {
            'img-thumbnail': this.thumbnail,
            'img-fluid': this.fluid || this.fluidGrow,
            'w-100': this.fluidGrow,
            'd-block': this.block,
            [`${this.shape}`]: this.shape,
        });
        return classes;
    }
    get alignClass() {
        return this.align === 'center' ? 'mx-auto' :
            this.align === 'right' ? 'float-right' :
                this.align === 'left' ? 'float-left' : '';
    }
    ngOnInit() { }
}
ImgDirective.ɵfac = function ImgDirective_Factory(t) { return new (t || ImgDirective)(); };
ImgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ImgDirective, selectors: [["", "cImg", ""]], hostVars: 4, hostBindings: function ImgDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleMap(ctx.getStyles);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { align: "align", placeholderColor: "placeholderColor", block: "block", fluid: "fluid", fluidGrow: "fluidGrow", shape: "shape", thumbnail: "thumbnail" } });
ImgDirective.ctorParameters = () => [];
ImgDirective.propDecorators = {
    block: [{ type: Input }],
    fluid: [{ type: Input }],
    fluidGrow: [{ type: Input }],
    shape: [{ type: Input }],
    thumbnail: [{ type: Input }],
    align: [{ type: Input }],
    placeholderColor: [{ type: Input }],
    getStyles: [{ type: HostBinding, args: ['style',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ImgDirective, [{
        type: Directive,
        args: [{
                selector: '[cImg]'
            }]
    }], function () { return []; }, { align: [{
            type: Input
        }], placeholderColor: [{
            type: Input
        }], getStyles: [{
            type: HostBinding,
            args: ['style']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], block: [{
            type: Input
        }], fluid: [{
            type: Input
        }], fluidGrow: [{
            type: Input
        }], shape: [{
            type: Input
        }], thumbnail: [{
            type: Input
        }] }); })();

class ImgModule {
}
ImgModule.ɵfac = function ImgModule_Factory(t) { return new (t || ImgModule)(); };
ImgModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ImgModule });
ImgModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ImgModule, { declarations: function () { return [ImgDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ImgDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ImgModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    ImgDirective
                ],
                declarations: [
                    ImgDirective
                ]
            }]
    }], null, null); })();

class BodyComponent {
    constructor() {
        this.bodyClass = true;
    }
}
BodyComponent.ɵfac = function BodyComponent_Factory(t) { return new (t || BodyComponent)(); };
BodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BodyComponent, selectors: [["c-body"], ["", "c-body", ""]], hostVars: 2, hostBindings: function BodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("c-body", ctx.bodyClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function BodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}"] });
BodyComponent.propDecorators = {
    bodyClass: [{ type: HostBinding, args: ['class.c-body',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BodyComponent, [{
        type: Component,
        args: [{
                selector: 'c-body, [c-body]',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:flex;flex-direction:column}"]
            }]
    }], function () { return []; }, { bodyClass: [{
            type: HostBinding,
            args: ['class.c-body']
        }] }); })();

class FooterComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.fixedClass = 'c-footer-fixed';
        renderer.addClass(hostElement.nativeElement, 'c-footer');
    }
    ngOnInit() {
        this.isFixed(this.fixed);
    }
    ngOnDestroy() {
        this.renderer.removeClass(this.hostElement.nativeElement, this.fixedClass);
    }
    isFixed(fixed = this.fixed) {
        if (fixed) {
            this.renderer.addClass(this.hostElement.nativeElement, this.fixedClass);
        }
    }
}
FooterComponent.ɵfac = function FooterComponent_Factory(t) { return new (t || FooterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FooterComponent, selectors: [["c-footer"], ["", "c-footer", ""]], inputs: { fixed: "fixed" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
FooterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FooterComponent.propDecorators = {
    fixed: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterComponent, [{
        type: Component,
        args: [{
                selector: 'c-footer, [c-footer]',
                template: `<ng-content></ng-content>`,
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { fixed: [{
            type: Input
        }] }); })();

class HeaderComponent {
    constructor() {
        this.colorScheme = 'light';
        this.fixed = true;
        this.role = 'header';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-header': true,
            'c-header-fixed': this.fixed,
        }, `c-header-${this.colorScheme}`);
        return classes;
    }
}
HeaderComponent.ɵfac = function HeaderComponent_Factory(t) { return new (t || HeaderComponent)(); };
HeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeaderComponent, selectors: [["c-header"], ["", "c-header", ""]], hostVars: 3, hostBindings: function HeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { colorScheme: "colorScheme", fixed: "fixed", class: "class", ngClass: "ngClass" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function HeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
HeaderComponent.ctorParameters = () => [];
HeaderComponent.propDecorators = {
    colorScheme: [{ type: Input }],
    fixed: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderComponent, [{
        type: Component,
        args: [{
                selector: 'c-header, [c-header]',
                template: `<ng-content></ng-content>`,
                styles: [""]
            }]
    }], function () { return []; }, { colorScheme: [{
            type: Input
        }], fixed: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], class: [{
            type: Input
        }], ngClass: [{
            type: Input
        }] }); })();

class SidebarService {
    constructor() {
        this.sidebarState = new BehaviorSubject({});
        this.sidebarState$ = this.sidebarState.asObservable();
    }
    toggle(action) {
        this.sidebarState.next(action);
    }
}
SidebarService.ɵfac = function SidebarService_Factory(t) { return new (t || SidebarService)(); };
SidebarService.ɵprov = ɵɵdefineInjectable({ factory: function SidebarService_Factory() { return new SidebarService(); }, token: SidebarService, providedIn: "root" });
SidebarService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class HeaderBrandComponent {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
        this.routerLink = '';
        this.minimized = false;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
    }
    minimize(force) {
        this.minimized = (force === 'toggle') ? !this.minimized : force;
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.sidebarService.sidebarState$.subscribe((state) => {
                if (!state.id) {
                    if ('minimize' in state) {
                        this.minimize(state.minimize);
                    }
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
}
HeaderBrandComponent.ɵfac = function HeaderBrandComponent_Factory(t) { return new (t || HeaderBrandComponent)(ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
HeaderBrandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeaderBrandComponent, selectors: [["c-header-brand"]], inputs: { routerLink: "routerLink", minimized: "minimized" }, ngContentSelectors: _c12, decls: 3, vars: 3, consts: [["role", "button", 1, "c-header-brand", 3, "routerLink"], [3, "ngIf"]], template: function HeaderBrandComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c12);
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtemplate(1, HeaderBrandComponent_ng_template_1_Template, 1, 0, "ng-template", 1);
        ɵngcc0.ɵɵtemplate(2, HeaderBrandComponent_ng_template_2_Template, 1, 0, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("routerLink", ctx.routerLink);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.minimized);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.minimized);
    } }, directives: [ɵngcc4.RouterLinkWithHref, ɵngcc3.NgIf], encapsulation: 2 });
HeaderBrandComponent.ctorParameters = () => [
    { type: SidebarService }
];
HeaderBrandComponent.propDecorators = {
    routerLink: [{ type: Input }],
    minimized: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeaderBrandComponent, [{
        type: Component,
        args: [{
                selector: 'c-header-brand',
                template: "<a class=\"c-header-brand\" [routerLink]=\"routerLink\" role=\"button\">\r\n  <ng-template [ngIf]=\"minimized\">\r\n    <ng-content></ng-content>\r\n  </ng-template>\r\n  <ng-template [ngIf]=\"!minimized\">\r\n    <ng-content></ng-content>\r\n  </ng-template>\r\n</a>\r\n\r\n"
            }]
    }], function () { return [{ type: SidebarService }]; }, { routerLink: [{
            type: Input
        }], minimized: [{
            type: Input
        }] }); })();

class SubheaderComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-subheader': true,
        });
        return classes;
    }
    ngOnInit() {
    }
}
SubheaderComponent.ɵfac = function SubheaderComponent_Factory(t) { return new (t || SubheaderComponent)(); };
SubheaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SubheaderComponent, selectors: [["c-subheader"], ["", "c-subheader", ""]], hostVars: 2, hostBindings: function SubheaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { class: "class", ngClass: "ngClass" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function SubheaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
SubheaderComponent.ctorParameters = () => [];
SubheaderComponent.propDecorators = {
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SubheaderComponent, [{
        type: Component,
        args: [{
                selector: 'c-subheader, [c-subheader]',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], class: [{
            type: Input
        }], ngClass: [{
            type: Input
        }] }); })();

class WrapperComponent {
    constructor() {
        this.fluid = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'c-wrapper': true,
            'c-wrapper-fluid': !!this.fluid
        });
        return classes;
    }
}
WrapperComponent.ɵfac = function WrapperComponent_Factory(t) { return new (t || WrapperComponent)(); };
WrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WrapperComponent, selectors: [["c-wrapper"], ["", "c-wrapper", ""]], hostVars: 2, hostBindings: function WrapperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { fluid: "fluid" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function WrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
WrapperComponent.propDecorators = {
    fluid: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WrapperComponent, [{
        type: Component,
        args: [{
                selector: 'c-wrapper, [c-wrapper]',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { fluid: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class LayoutModule {
}
LayoutModule.ɵfac = function LayoutModule_Factory(t) { return new (t || LayoutModule)(); };
LayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LayoutModule });
LayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[
            CommonModule,
            RouterModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LayoutModule, { declarations: function () { return [FooterComponent, HeaderComponent, HeaderBrandComponent, SubheaderComponent, WrapperComponent, BodyComponent]; }, imports: function () { return [CommonModule,
        RouterModule]; }, exports: function () { return [BodyComponent, FooterComponent, HeaderComponent, HeaderBrandComponent, SubheaderComponent, WrapperComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LayoutModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                ],
                exports: [
                    BodyComponent,
                    FooterComponent,
                    HeaderComponent,
                    HeaderBrandComponent,
                    SubheaderComponent,
                    WrapperComponent
                ],
                declarations: [
                    FooterComponent,
                    HeaderComponent,
                    HeaderBrandComponent,
                    SubheaderComponent,
                    WrapperComponent,
                    BodyComponent,
                ],
                providers: []
            }]
    }], null, null); })();

class ListGroupDirective {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'list-group': true,
            'list-group-horizontal': this.horizontal === true || this.horizontal === '',
            [`list-group-horizontal-${this.horizontal}`]: this.horizontal && this.horizontal !== true,
            'list-group-flush': !!this.flush,
            'list-group-accent': !!this.accent,
        });
        return classes;
    }
}
ListGroupDirective.ɵfac = function ListGroupDirective_Factory(t) { return new (t || ListGroupDirective)(); };
ListGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ListGroupDirective, selectors: [["", "cListGroup", ""], ["c-list-group"]], hostVars: 2, hostBindings: function ListGroupDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { horizontal: "horizontal", accent: "accent", flush: "flush" } });
ListGroupDirective.ctorParameters = () => [];
ListGroupDirective.propDecorators = {
    horizontal: [{ type: Input }],
    accent: [{ type: Input }],
    flush: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListGroupDirective, [{
        type: Directive,
        args: [{
                selector: '[cListGroup], c-list-group'
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], horizontal: [{
            type: Input
        }], accent: [{
            type: Input
        }], flush: [{
            type: Input
        }] }); })();

class ListGroupItemDirective {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'list-group-item': true,
            'list-group-item-action': this.action,
            'list-group-item-divider': this.divider,
            active: this.active,
            disabled: this.disabled,
            [`list-group-item-${this.color}`]: !!this.color,
            [`list-group-item-accent-${this.accent}`]: !!this.accent
        });
        return classes;
    }
    ngOnInit() { }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.addClass(this.host, `list-group-item-${changes.color.currentValue}`);
            this.renderer.removeClass(this.host, `list-group-item-${changes.color.previousValue}`);
        }
        if (changes.accent) {
            this.renderer.addClass(this.host, `list-group-item-accent-${changes.accent.currentValue}`);
            this.renderer.removeClass(this.host, `list-group-item-accent-${changes.accent.previousValue}`);
        }
    }
}
ListGroupItemDirective.ɵfac = function ListGroupItemDirective_Factory(t) { return new (t || ListGroupItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ListGroupItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ListGroupItemDirective, selectors: [["", "cListGroupItem", ""], ["c-list-group-item"]], hostVars: 3, hostBindings: function ListGroupItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.disabled);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { accent: "accent", action: "action", active: "active", color: "color", divider: "divider", disabled: "disabled" }, exportAs: ["cListGroupItem"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ListGroupItemDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ListGroupItemDirective.propDecorators = {
    accent: [{ type: Input }],
    action: [{ type: Input }],
    active: [{ type: Input }],
    color: [{ type: Input }],
    divider: [{ type: Input }],
    disabled: [{ type: HostBinding, args: ['attr.disabled',] }, { type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListGroupItemDirective, [{
        type: Directive,
        args: [{
                selector: '[cListGroupItem], c-list-group-item',
                exportAs: 'cListGroupItem'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], accent: [{
            type: Input
        }], action: [{
            type: Input
        }], active: [{
            type: Input
        }], color: [{
            type: Input
        }], divider: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['attr.disabled']
        }, {
            type: Input
        }] }); })();

class ListGroupModule {
}
ListGroupModule.ɵfac = function ListGroupModule_Factory(t) { return new (t || ListGroupModule)(); };
ListGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ListGroupModule });
ListGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ListGroupModule, { declarations: function () { return [ListGroupDirective, ListGroupItemDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ListGroupDirective, ListGroupItemDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [ListGroupDirective, ListGroupItemDirective],
                exports: [
                    ListGroupDirective,
                    ListGroupItemDirective
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class MediaDirective {
    constructor() {
        this.madiaClass = true;
    }
}
MediaDirective.ɵfac = function MediaDirective_Factory(t) { return new (t || MediaDirective)(); };
MediaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MediaDirective, selectors: [["", "cMedia", ""]], hostVars: 2, hostBindings: function MediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("media", ctx.madiaClass);
    } } });
MediaDirective.propDecorators = {
    madiaClass: [{ type: HostBinding, args: ['class.media',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaDirective, [{
        type: Directive,
        args: [{
                selector: '[cMedia]'
            }]
    }], function () { return []; }, { madiaClass: [{
            type: HostBinding,
            args: ['class.media']
        }] }); })();

class MediaComponent extends MediaDirective {
    constructor() {
        super();
    }
}
MediaComponent.ɵfac = function MediaComponent_Factory(t) { return new (t || MediaComponent)(); };
MediaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MediaComponent, selectors: [["c-media"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MediaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
MediaComponent.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaComponent, [{
        type: Component,
        args: [{
                selector: 'c-media',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, null); })();

class MediaBodyComponent {
    constructor() {
        this.mediaBodyClass = true;
    }
}
MediaBodyComponent.ɵfac = function MediaBodyComponent_Factory(t) { return new (t || MediaBodyComponent)(); };
MediaBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MediaBodyComponent, selectors: [["c-media-body"]], hostVars: 2, hostBindings: function MediaBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("media-body", ctx.mediaBodyClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MediaBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
MediaBodyComponent.propDecorators = {
    mediaBodyClass: [{ type: HostBinding, args: ['class.media-body',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaBodyComponent, [{
        type: Component,
        args: [{
                selector: 'c-media-body',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { mediaBodyClass: [{
            type: HostBinding,
            args: ['class.media-body']
        }] }); })();

class MediaModule {
}
MediaModule.ɵfac = function MediaModule_Factory(t) { return new (t || MediaModule)(); };
MediaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MediaModule });
MediaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MediaModule, { declarations: function () { return [MediaComponent, MediaBodyComponent, MediaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [MediaDirective, MediaComponent, MediaBodyComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaModule, [{
        type: NgModule,
        args: [{
                declarations: [MediaComponent, MediaBodyComponent, MediaDirective],
                imports: [CommonModule],
                exports: [MediaDirective, MediaComponent, MediaBodyComponent]
            }]
    }], null, null); })();

class ModalComponent {
    constructor(document, renderer, elementRef, changeDetectorRef) {
        this.document = document;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.closeOnBackdrop = true;
        this.size = '';
        this.color = '';
        this.modalClasses = {
            modal: true,
            fade: true
        };
        this.dialogClasses = {
            'modal-dialog': true
        };
        this.backdropClasses = {
            'modal-backdrop': true,
            fade: true,
            show: true
        };
        this.visible = false;
        this.visibleAnimate = false;
    }
    ngOnInit() {
        this.setClasses();
    }
    ngOnDestroy() {
        this.hide();
    }
    setClasses() {
        this.dialogClasses[`modal-${this.size}`] = !!this.size;
        this.dialogClasses[`modal-${this.color}`] = !!this.color;
    }
    show() {
        this.renderer.addClass(this.document.body, 'modal-open');
        this.visible = true;
        this.modalClasses[`d-block`] = true;
        setTimeout(() => {
            this.visibleAnimate = true;
        });
    }
    hide() {
        this.renderer.removeClass(this.document.body, 'modal-open');
        this.visibleAnimate = false;
        setTimeout(() => {
            this.visible = false;
            this.modalClasses[`d-block`] = false;
            this.changeDetectorRef.markForCheck();
        }, 200);
    }
    onContainerClicked(event) {
        if (event.target.classList.contains('modal') && this.isTopmost() && this.closeOnBackdrop) {
            this.hide();
        }
    }
    onKeyDownHandler(event) {
        if (event.key === 'Escape' && this.isTopmost()) {
            this.hide();
        }
    }
    isTopmost() {
        const isTopmost = !this.elementRef.nativeElement.querySelector(':scope c-modal > .modal');
        return isTopmost;
    }
}
ModalComponent.ɵfac = function ModalComponent_Factory(t) { return new (t || ModalComponent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ModalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ModalComponent, selectors: [["c-modal"]], contentQueries: function ModalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c13, 3);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c14, 3);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c15, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.body = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
    } }, hostBindings: function ModalComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ModalComponent_click_HostBindingHandler($event) { return ctx.onContainerClicked($event); })("keydown", function ModalComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDownHandler($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { closeOnBackdrop: "closeOnBackdrop", size: "size", color: "color" }, decls: 2, vars: 2, consts: [["role", "dialog", "tabindex", "-1", 3, "show", "ngClass", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["role", "dialog", "tabindex", "-1", 3, "ngClass"], ["role", "document", 3, "ngClass"], [1, "modal-content"], [1, "modal-header"], ["class", "modal-title", 4, "ngTemplateOutlet"], ["data-dismiss", "modal", "type", "button", "aria-label", "Close", 1, "close", 3, "click"], [1, "modal-body"], [4, "ngTemplateOutlet"], [1, "modal-footer"], [1, "modal-title"], [3, "ngClass"]], template: function ModalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ModalComponent_div_0_Template, 11, 7, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ModalComponent_div_1_Template, 1, 1, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.visible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.visibleAnimate);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgClass, ɵngcc3.NgTemplateOutlet], styles: [""] });
ModalComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
ModalComponent.propDecorators = {
    header: [{ type: ContentChild, args: ['modalHeader', { static: true },] }],
    body: [{ type: ContentChild, args: ['modalBody', { static: true },] }],
    footer: [{ type: ContentChild, args: ['modalFooter', { static: true },] }],
    closeOnBackdrop: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    onContainerClicked: [{ type: HostListener, args: ['click', ['$event'],] }],
    onKeyDownHandler: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalComponent, [{
        type: Component,
        args: [{
                selector: 'c-modal',
                template: "<div\n  role=\"dialog\"\n  tabindex=\"-1\"\n  [class.show]=\"visibleAnimate\"\n  [ngClass]=\"modalClasses\"\n  *ngIf=\"visible\">\n  <div [ngClass]=\"dialogClasses\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <ng-container *ngTemplateOutlet=\"header\" class=\"modal-title\"></ng-container>\n        <button class=\"close\" data-dismiss=\"modal\" type=\"button\" aria-label=\"Close\" (click)=\"hide()\">\u00D7</button>\n      </div>\n      <div class=\"modal-body\">\n        <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n      </div>\n      <div class=\"modal-footer\">\n        <ng-container *ngTemplateOutlet=\"footer\"></ng-container>\n      </div>\n    </div>\n  </div>\n</div>\n<div\n  *ngIf=\"visibleAnimate\"\n  [ngClass]=\"backdropClasses\">\n</div>\n",
                styles: [""]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { closeOnBackdrop: [{
            type: Input
        }], size: [{
            type: Input
        }], color: [{
            type: Input
        }], onContainerClicked: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onKeyDownHandler: [{
            type: HostListener,
            args: ['document:keydown', ['$event']]
        }], header: [{
            type: ContentChild,
            args: ['modalHeader', { static: true }]
        }], body: [{
            type: ContentChild,
            args: ['modalBody', { static: true }]
        }], footer: [{
            type: ContentChild,
            args: ['modalFooter', { static: true }]
        }] }); })();

class ModalModule {
}
ModalModule.ɵfac = function ModalModule_Factory(t) { return new (t || ModalModule)(); };
ModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ModalModule });
ModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ModalModule, { declarations: function () { return [ModalComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ModalComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalModule, [{
        type: NgModule,
        args: [{
                declarations: [ModalComponent],
                exports: [ModalComponent],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class NavComponent {
    constructor() {
        this.variant = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const verticalSuffix = this.vertical === true ? '' : `-${this.vertical}`;
        const classes = classNames({
            nav: true,
            [`nav-${this.variant}`]: this.variant,
            [`flex${verticalSuffix}-column`]: this.vertical,
            'nav-fill': this.fill,
            'nav-justified': this.justified,
            [`card-header-${this.variant}`]: this.inCard && this.variant
        });
        return classes;
    }
    ngOnInit() { }
}
NavComponent.ɵfac = function NavComponent_Factory(t) { return new (t || NavComponent)(); };
NavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavComponent, selectors: [["c-nav"]], hostVars: 2, hostBindings: function NavComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { variant: "variant", fill: "fill", justified: "justified", vertical: "vertical", inCard: "inCard" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] > .nav-link[_ngcontent-%COMP%]:focus{outline:0}"] });
NavComponent.ctorParameters = () => [];
NavComponent.propDecorators = {
    variant: [{ type: Input }],
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    vertical: [{ type: Input }],
    inCard: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavComponent, [{
        type: Component,
        args: [{
                selector: 'c-nav',
                template: "<ng-content></ng-content>\n",
                styles: [":host>.nav-link:focus{outline:0}"]
            }]
    }], function () { return []; }, { variant: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], fill: [{
            type: Input
        }], justified: [{
            type: Input
        }], vertical: [{
            type: Input
        }], inCard: [{
            type: Input
        }] }); })();

class NavItemComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'nav-item': true,
        });
        return classes;
    }
    ngOnInit() {
    }
}
NavItemComponent.ɵfac = function NavItemComponent_Factory(t) { return new (t || NavItemComponent)(); };
NavItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavItemComponent, selectors: [["c-nav-item"]], hostVars: 2, hostBindings: function NavItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:list-item;text-align:match-parent}"] });
NavItemComponent.ctorParameters = () => [];
NavItemComponent.propDecorators = {
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavItemComponent, [{
        type: Component,
        args: [{
                selector: 'c-nav-item',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:list-item;text-align:match-parent}"]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class NavLinkDirective {
    constructor() {
        this.disabled = null;
        this.tabindex = null;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'nav-link': true,
            disabled: this.disabled,
            active: this.active
        });
        return classes;
    }
}
NavLinkDirective.ɵfac = function NavLinkDirective_Factory(t) { return new (t || NavLinkDirective)(); };
NavLinkDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavLinkDirective, selectors: [["", "cNavLink", ""]], hostVars: 4, hostBindings: function NavLinkDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isDisabled)("tabindex", ctx.getTabindex);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { disabled: "disabled", tabindex: "tabindex", active: "active" } });
NavLinkDirective.ctorParameters = () => [];
NavLinkDirective.propDecorators = {
    disabled: [{ type: Input }],
    tabindex: [{ type: Input }],
    active: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavLinkDirective, [{
        type: Directive,
        args: [{
                selector: '[cNavLink]'
            }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], isDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], getTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], active: [{
            type: Input
        }] }); })();

class NavModule {
}
NavModule.ɵfac = function NavModule_Factory(t) { return new (t || NavModule)(); };
NavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NavModule });
NavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NavModule, { declarations: function () { return [NavComponent, NavItemComponent, NavLinkDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NavComponent, NavItemComponent, NavLinkDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavModule, [{
        type: NgModule,
        args: [{
                declarations: [NavComponent, NavItemComponent, NavLinkDirective],
                imports: [
                    CommonModule
                ],
                exports: [NavComponent, NavItemComponent, NavLinkDirective]
            }]
    }], null, null); })();

class NavbarComponent {
    constructor(hostElement, breakpointObserver) {
        this.hostElement = hostElement;
        this.breakpointObserver = breakpointObserver;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const expandClassSuffix = this.expandable === true ? '' : `-${this.expandable}`;
        const classes = classNames({
            navbar: true,
            'navbar-light': this.light,
            'navbar-dark': !this.light,
            [`navbar-expand${expandClassSuffix}`]: !!this.expandable,
            [`bg-${this.color}`]: !!this.color,
            [`fixed-${this.fixed}`]: !!this.fixed,
            'sticky-top': this.sticky,
        });
        return classes;
    }
    get breakpoint() {
        if (typeof this.expandable === 'string') {
            return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.expandable}`);
        }
    }
    ngOnInit() { }
    ngAfterContentInit() {
        if (this.breakpoint) {
            const onBreakpoint = `(min-width: ${this.breakpoint})`;
            this.breakpointObserver.observe([onBreakpoint]).subscribe(result => {
                const { animate } = Object.assign({}, this.collapse);
                this.collapse._animate = false;
                this.collapse.show = false;
                setTimeout(() => {
                    this.collapse.show = result.matches;
                }, 0);
                setTimeout(() => {
                    this.collapse._animate = animate;
                });
            });
        }
    }
}
NavbarComponent.ɵfac = function NavbarComponent_Factory(t) { return new (t || NavbarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.BreakpointObserver)); };
NavbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavbarComponent, selectors: [["c-navbar"]], contentQueries: function NavbarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CollapseDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.collapse = _t.first);
    } }, hostVars: 2, hostBindings: function NavbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { light: "light", color: "color", fixed: "fixed", sticky: "sticky", expandable: "expandable" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
NavbarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: BreakpointObserver }
];
NavbarComponent.propDecorators = {
    light: [{ type: Input }],
    color: [{ type: Input }],
    fixed: [{ type: Input }],
    sticky: [{ type: Input }],
    expandable: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    collapse: [{ type: ContentChild, args: [CollapseDirective,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavbarComponent, [{
        type: Component,
        args: [{
                selector: 'c-navbar',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc6.BreakpointObserver }]; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], light: [{
            type: Input
        }], color: [{
            type: Input
        }], fixed: [{
            type: Input
        }], sticky: [{
            type: Input
        }], expandable: [{
            type: Input
        }], collapse: [{
            type: ContentChild,
            args: [CollapseDirective]
        }] }); })();

class NavbarBrandComponent {
    constructor() {
        this.navbarBrand = true;
        this.role = 'button';
    }
    ngOnInit() { }
}
NavbarBrandComponent.ɵfac = function NavbarBrandComponent_Factory(t) { return new (t || NavbarBrandComponent)(); };
NavbarBrandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavbarBrandComponent, selectors: [["c-navbar-brand"]], hostVars: 3, hostBindings: function NavbarBrandComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("navbar-brand", ctx.navbarBrand);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavbarBrandComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{outline:inherit}"] });
NavbarBrandComponent.ctorParameters = () => [];
NavbarBrandComponent.propDecorators = {
    navbarBrand: [{ type: HostBinding, args: ['class.navbar-brand',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavbarBrandComponent, [{
        type: Component,
        args: [{
                selector: 'c-navbar-brand',
                template: "<ng-content></ng-content>\n",
                styles: [":host{outline:inherit}"]
            }]
    }], function () { return []; }, { navbarBrand: [{
            type: HostBinding,
            args: ['class.navbar-brand']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }] }); })();

class NavbarNavComponent {
    constructor() {
        this.navbarNav = true;
    }
    ngOnInit() { }
}
NavbarNavComponent.ɵfac = function NavbarNavComponent_Factory(t) { return new (t || NavbarNavComponent)(); };
NavbarNavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavbarNavComponent, selectors: [["c-navbar-nav"]], hostVars: 2, hostBindings: function NavbarNavComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("navbar-nav", ctx.navbarNav);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavbarNavComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
NavbarNavComponent.ctorParameters = () => [];
NavbarNavComponent.propDecorators = {
    navbarNav: [{ type: HostBinding, args: ['class.navbar-nav',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavbarNavComponent, [{
        type: Component,
        args: [{
                selector: 'c-navbar-nav',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { navbarNav: [{
            type: HostBinding,
            args: ['class.navbar-nav']
        }] }); })();

class NavbarTextComponent {
    constructor() {
        this.navbarTextClass = true;
    }
    ngOnInit() { }
}
NavbarTextComponent.ɵfac = function NavbarTextComponent_Factory(t) { return new (t || NavbarTextComponent)(); };
NavbarTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavbarTextComponent, selectors: [["c-navbar-text"]], hostVars: 2, hostBindings: function NavbarTextComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("navbar-text", ctx.navbarTextClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NavbarTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
NavbarTextComponent.ctorParameters = () => [];
NavbarTextComponent.propDecorators = {
    navbarTextClass: [{ type: HostBinding, args: ['class.navbar-text',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavbarTextComponent, [{
        type: Component,
        args: [{
                selector: 'c-navbar-text',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return []; }, { navbarTextClass: [{
            type: HostBinding,
            args: ['class.navbar-text']
        }] }); })();

class NavbarModule {
}
NavbarModule.ɵfac = function NavbarModule_Factory(t) { return new (t || NavbarModule)(); };
NavbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NavbarModule });
NavbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            RouterModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NavbarModule, { declarations: function () { return [NavbarComponent, NavbarBrandComponent, NavbarNavComponent, NavbarTextComponent]; }, imports: function () { return [CommonModule,
        RouterModule]; }, exports: function () { return [NavbarComponent, NavbarBrandComponent, NavbarNavComponent, NavbarTextComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavbarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    NavbarComponent,
                    NavbarBrandComponent,
                    NavbarNavComponent,
                    NavbarTextComponent
                ],
                exports: [
                    NavbarComponent,
                    NavbarBrandComponent,
                    NavbarNavComponent,
                    NavbarTextComponent
                ],
                imports: [
                    CommonModule,
                    RouterModule
                ]
            }]
    }], null, null); })();

class ProgressComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            progress: true,
            [`progress-${this.size}`]: !!this.size
        });
        return classes;
    }
}
ProgressComponent.ɵfac = function ProgressComponent_Factory(t) { return new (t || ProgressComponent)(); };
ProgressComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressComponent, selectors: [["c-progress"]], hostVars: 2, hostBindings: function ProgressComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { size: "size" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ProgressComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{width:100%;display:flex}"] });
ProgressComponent.propDecorators = {
    size: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressComponent, [{
        type: Component,
        args: [{
                selector: 'c-progress',
                template: "<ng-content></ng-content>\n<!--<ng-template [ngIf]=\"stacked.length>0\">-->\n<!--  <c-progress-bar *ngFor=\"let item of stacked\"-->\n<!--                    [value]=\"item.value\"-->\n<!--                    [variant]=\"item.variant\"-->\n<!--                    [animate]=\"item.animate\"-->\n<!--                    [striped]=\"item.striped\"-->\n<!--                    [min]=\"item.min || min || 0\"-->\n<!--                    [max]=\"item.max || max || 100\">-->\n<!--    {{item.label || (item.value/100 | percent)}}-->\n<!--  </c-progress-bar>-->\n<!--</ng-template>-->\n",
                styles: [":host{width:100%;display:flex}"]
            }]
    }], null, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], size: [{
            type: Input
        }] }); })();

class ProgressBarComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.state = {
            percent: 0,
            min: 0,
            max: 100
        };
        this.animated = false;
        this.striped = false;
        this.precision = 0;
        this.value = 0;
        this.role = 'progressbar';
        this.host = this.hostElement.nativeElement;
    }
    set min(value) {
        this.state.min = isNaN(value) ? 0 : value;
    }
    get min() {
        return this.state.min;
    }
    set max(value) {
        this.state.max = isNaN(value) || value <= 0 || value === this.min ? 100 : value;
    }
    get max() {
        return this.state.max;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'progress-bar': true,
            'progress-bar-animated': this.animated,
            'progress-bar-striped': this.striped || this.animated,
            [`bg-${this.color}`]: !!this.color
        });
        return classes;
    }
    ngOnInit() {
        this.setValues();
    }
    setPercent() {
        this.state.percent = +((this.value / (this.max - this.min)) * 100).toFixed(this.precision);
    }
    setValues() {
        this.setPercent();
        this.renderer.setStyle(this.host, 'width', `${this.state.percent}%`);
        this.renderer.setAttribute(this.host, 'aria-valuenow', String(this.value));
        this.renderer.setAttribute(this.host, 'aria-valuemin', String(this.min));
        this.renderer.setAttribute(this.host, 'aria-valuemax', String(this.max));
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.host, `bg-${changes.color.previousValue}`);
        }
        this.setValues();
    }
}
ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) { return new (t || ProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressBarComponent, selectors: [["c-progress-bar"]], hostVars: 3, hostBindings: function ProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { animated: "animated", striped: "striped", precision: "precision", value: "value", role: "role", min: "min", max: "max", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
ProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ProgressBarComponent.propDecorators = {
    color: [{ type: Input }],
    animated: [{ type: Input }],
    striped: [{ type: Input }],
    precision: [{ type: Input }],
    value: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'c-progress-bar',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { animated: [{
            type: Input
        }], striped: [{
            type: Input
        }], precision: [{
            type: Input
        }], value: [{
            type: Input
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }] }); })();

class ProgressModule {
}
ProgressModule.ɵfac = function ProgressModule_Factory(t) { return new (t || ProgressModule)(); };
ProgressModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ProgressModule });
ProgressModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ProgressModule, { declarations: function () { return [ProgressComponent, ProgressBarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ProgressComponent, ProgressBarComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressModule, [{
        type: NgModule,
        args: [{
                declarations: [ProgressComponent, ProgressBarComponent],
                exports: [
                    ProgressComponent,
                    ProgressBarComponent
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class ClassToggleService {
    constructor(document, rendererFactory) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    toggle(selector, className) {
        const element = document.querySelector(selector);
        if (element) {
            element.classList.contains(className) ?
                this.renderer.removeClass(element, className) :
                this.renderer.addClass(element, className);
        }
    }
}
ClassToggleService.ɵfac = function ClassToggleService_Factory(t) { return new (t || ClassToggleService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)); };
ClassToggleService.ɵprov = ɵɵdefineInjectable({ factory: function ClassToggleService_Factory() { return new ClassToggleService(ɵɵinject(DOCUMENT), ɵɵinject(RendererFactory2)); }, token: ClassToggleService, providedIn: "root" });
ClassToggleService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: RendererFactory2 }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClassToggleService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.RendererFactory2 }]; }, null); })();

class SidebarBackdropComponent {
    constructor(elementRef, sidebarService) {
        this.elementRef = elementRef;
        this.sidebarService = sidebarService;
        this._sidebarBackdrop = true;
    }
    onClick($event) {
        const targetElement = $event.target;
        if (targetElement && !this.elementRef.nativeElement.contains(targetElement)) {
            this.sidebarService.toggle({ open: false });
        }
    }
    ngOnInit() {
    }
}
SidebarBackdropComponent.ɵfac = function SidebarBackdropComponent_Factory(t) { return new (t || SidebarBackdropComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarBackdropComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarBackdropComponent, selectors: [["c-sidebar-backdrop"]], hostVars: 2, hostBindings: function SidebarBackdropComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SidebarBackdropComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("c-sidebar-backdrop", ctx._sidebarBackdrop);
    } }, decls: 0, vars: 0, template: function SidebarBackdropComponent_Template(rf, ctx) { }, styles: [""] });
SidebarBackdropComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SidebarService }
];
SidebarBackdropComponent.propDecorators = {
    _sidebarBackdrop: [{ type: HostBinding, args: ['class.c-sidebar-backdrop',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarBackdropComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-backdrop',
                template: "",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SidebarService }]; }, { _sidebarBackdrop: [{
            type: HostBinding,
            args: ['class.c-sidebar-backdrop']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

class SidebarBrandComponent {
    constructor() {
        this.brandText = { icon: '🅲', text: '🅲 CoreUI' };
        this.routerLink = '';
        this._sidebarBrand = true;
    }
    ngOnInit() {
        this.brandImg = Boolean(this.brand || this.brandFull || this.brandMinimized);
    }
}
SidebarBrandComponent.ɵfac = function SidebarBrandComponent_Factory(t) { return new (t || SidebarBrandComponent)(); };
SidebarBrandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarBrandComponent, selectors: [["c-sidebar-brand"]], hostVars: 2, hostBindings: function SidebarBrandComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("c-sidebar-brand", ctx._sidebarBrand);
    } }, inputs: { brandText: "brandText", routerLink: "routerLink", brand: "brand", brandFull: "brandFull", brandMinimized: "brandMinimized" }, decls: 3, vars: 3, consts: [[3, "routerLink"], [3, "ngIf"], [3, "cHtmlAttr", "ngClass", 4, "ngIf"], [3, "cHtmlAttr", "ngClass"], [1, "c-sidebar-brand-full", 3, "innerHTML"], [1, "c-sidebar-brand-minimized", 3, "innerHTML"]], template: function SidebarBrandComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtemplate(1, SidebarBrandComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
        ɵngcc0.ɵɵtemplate(2, SidebarBrandComponent_ng_template_2_Template, 2, 2, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("routerLink", ctx.routerLink);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.brandImg);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.brandImg);
    } }, directives: [ɵngcc4.RouterLinkWithHref, ɵngcc3.NgIf, HtmlAttributesDirective, ɵngcc3.NgClass], encapsulation: 2 });
SidebarBrandComponent.ctorParameters = () => [];
SidebarBrandComponent.propDecorators = {
    brand: [{ type: Input }],
    brandFull: [{ type: Input }],
    brandMinimized: [{ type: Input }],
    brandText: [{ type: Input }],
    routerLink: [{ type: Input }],
    _sidebarBrand: [{ type: HostBinding, args: ['class.c-sidebar-brand',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarBrandComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-brand',
                template: "<a [routerLink]=\"routerLink\">\r\n  <ng-template [ngIf]=\"brandImg\">\r\n<!--    <img *ngIf=\"brand\"-->\r\n<!--         [cHtmlAttr]=\"brand\"-->\r\n<!--         [ngClass]=\"'c-sidebar-brand'\">-->\r\n    <img *ngIf=\"brandFull\"\r\n         [cHtmlAttr]=\"brandFull\"\r\n         [ngClass]=\"'c-sidebar-brand-full'\">\r\n    <img *ngIf=\"brandMinimized\"\r\n         [cHtmlAttr]=\"brandMinimized\"\r\n         [ngClass]=\"'c-sidebar-brand-minimized'\">\r\n  </ng-template>\r\n  <ng-template [ngIf]=\"!brandImg\">\r\n    <div class=\"c-sidebar-brand-full\" [innerHTML]=\"brandText.text\"></div>\r\n    <div class=\"c-sidebar-brand-minimized\" [innerHTML]=\"brandText.icon\"></div>\r\n  </ng-template>\r\n</a>\r\n"
            }]
    }], function () { return []; }, { brandText: [{
            type: Input
        }], routerLink: [{
            type: Input
        }], _sidebarBrand: [{
            type: HostBinding,
            args: ['class.c-sidebar-brand']
        }], brand: [{
            type: Input
        }], brandFull: [{
            type: Input
        }], brandMinimized: [{
            type: Input
        }] }); })();

class SidebarFooterComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-footer');
    }
    ngOnInit() { }
}
SidebarFooterComponent.ɵfac = function SidebarFooterComponent_Factory(t) { return new (t || SidebarFooterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SidebarFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarFooterComponent, selectors: [["c-sidebar-footer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function SidebarFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
SidebarFooterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarFooterComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-footer',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();

class SidebarFormComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-form');
    }
    ngOnInit() { }
}
SidebarFormComponent.ɵfac = function SidebarFormComponent_Factory(t) { return new (t || SidebarFormComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SidebarFormComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarFormComponent, selectors: [["c-sidebar-form"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function SidebarFormComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
SidebarFormComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarFormComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-form',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();

class SidebarHeaderComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-header');
    }
    ngOnInit() { }
}
SidebarHeaderComponent.ɵfac = function SidebarHeaderComponent_Factory(t) { return new (t || SidebarHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SidebarHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarHeaderComponent, selectors: [["c-sidebar-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function SidebarHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
SidebarHeaderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-header',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, null); })();

class SidebarMinimizerComponent {
    constructor() {
        this.role = 'button';
        this._sidebarMinimizerClass = true;
    }
}
SidebarMinimizerComponent.ɵfac = function SidebarMinimizerComponent_Factory(t) { return new (t || SidebarMinimizerComponent)(); };
SidebarMinimizerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarMinimizerComponent, selectors: [["c-sidebar-minimizer"]], hostVars: 3, hostBindings: function SidebarMinimizerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("c-sidebar-minimizer", ctx._sidebarMinimizerClass);
    } }, decls: 0, vars: 0, template: function SidebarMinimizerComponent_Template(rf, ctx) { }, encapsulation: 2 });
SidebarMinimizerComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    _sidebarMinimizerClass: [{ type: HostBinding, args: ['class.c-sidebar-minimizer',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarMinimizerComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-minimizer',
                template: ``
            }]
    }], function () { return []; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], _sidebarMinimizerClass: [{
            type: HostBinding,
            args: ['class.c-sidebar-minimizer']
        }] }); })();

class SidebarMinimizeDirective {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
    }
    toggleMinimize($event) {
        $event.preventDefault();
        this.sidebarService.toggle({ minimize: 'toggle', id: this.id });
    }
}
SidebarMinimizeDirective.ɵfac = function SidebarMinimizeDirective_Factory(t) { return new (t || SidebarMinimizeDirective)(ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarMinimizeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SidebarMinimizeDirective, selectors: [["", "cSidebarMinimize", ""]], hostBindings: function SidebarMinimizeDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SidebarMinimizeDirective_click_HostBindingHandler($event) { return ctx.toggleMinimize($event); });
    } }, inputs: { id: ["cSidebarMinimize", "id"] }, exportAs: ["cSidebarMinimize"] });
SidebarMinimizeDirective.ctorParameters = () => [
    { type: SidebarService }
];
SidebarMinimizeDirective.propDecorators = {
    id: [{ type: Input, args: ['cSidebarMinimize',] }],
    toggleMinimize: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarMinimizeDirective, [{
        type: Directive,
        args: [{
                selector: '[cSidebarMinimize]',
                exportAs: 'cSidebarMinimize'
            }]
    }], function () { return [{ type: SidebarService }]; }, { toggleMinimize: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], id: [{
            type: Input,
            args: ['cSidebarMinimize']
        }] }); })();

class SidebarToggleDirective {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.sidebarService.toggle({ open: 'toggle', id: this.id });
    }
}
SidebarToggleDirective.ɵfac = function SidebarToggleDirective_Factory(t) { return new (t || SidebarToggleDirective)(ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SidebarToggleDirective, selectors: [["", "cSidebarToggle", ""]], hostBindings: function SidebarToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SidebarToggleDirective_click_HostBindingHandler($event) { return ctx.toggleOpen($event); });
    } }, inputs: { id: ["cSidebarToggle", "id"] }, exportAs: ["cSidebarToggle"] });
SidebarToggleDirective.ctorParameters = () => [
    { type: SidebarService }
];
SidebarToggleDirective.propDecorators = {
    id: [{ type: Input, args: ['cSidebarToggle',] }],
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[cSidebarToggle]',
                exportAs: 'cSidebarToggle'
            }]
    }], function () { return [{ type: SidebarService }]; }, { toggleOpen: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], id: [{
            type: Input,
            args: ['cSidebarToggle']
        }] }); })();

class SidebarComponent {
    constructor(document, renderer, hostElement, breakpointObserver, sidebarService) {
        this.document = document;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.breakpointObserver = breakpointObserver;
        this.sidebarService = sidebarService;
        this.fixed = true;
        this.unfoldable = false;
        this.overlaid = false;
        this.minimize = false;
        this.breakpoint = 'lg';
        this.mobile = 'lg';
        this.size = '';
        this.hideOnMobileClick = true;
        this.colorScheme = 'dark';
        this.minimized = this.minimize;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get getDesktopBreakpoint() {
        return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.breakpoint}`);
    }
    get hasBreakpoint() {
        return !!this.breakpoint;
    }
    get getMobileBreakpoint() {
        return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.mobile}`);
    }
    set isOnMobile(value) {
        this._isOnMobile = value;
    }
    get isOnMobile() {
        const isMobile = Boolean(this._isOnMobile);
        return isMobile;
    }
    set isOnDesktop(value) {
        this._isOnDesktop = this.hasBreakpoint ? value : false;
    }
    get isOnDesktop() {
        return this._isOnDesktop;
    }
    get isOpen() {
        let opened;
        if (this.isOnDesktop) {
            opened = this.openDesktop;
        }
        else {
            opened = (this.openMobile === true);
        }
        return opened;
    }
    get hostClasses() {
        const classes = classNames({
            'c-sidebar': true,
            'c-sidebar-fixed': this.fixed && !this.overlaid,
            'c-sidebar-right': this.aside,
            'c-sidebar-minimized': this.minimize && !this.unfoldable,
            'c-sidebar-unfoldable': this.minimize && this.unfoldable,
            'c-sidebar-overlaid': this.overlaid,
            'c-sidebar-show': this.openMobile === true,
            [`c-sidebar-${this.breakpoint}-show`]: (!!this.breakpoint) && this.openDesktop,
            [`c-sidebar-${this.colorScheme}`]: !!this.colorScheme,
            [`c-sidebar-${this.size}`]: !!this.size,
        });
        return classes;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
        this.layoutChangeSubscribe();
        this.setInitialState();
    }
    layoutChangeSubscribe(subscribe = true) {
        const onDesktop = `(min-width: ${this.getDesktopBreakpoint})`;
        const onMobile = this.breakpoint === false ? `(max-width: ${this.getMobileBreakpoint})` : `(max-width: ${this.getDesktopBreakpoint})`;
        if (subscribe) {
            const layoutChanges = this.breakpointObserver.observe([
                onDesktop,
                onMobile,
            ]);
            this.layoutChangesSubscription = layoutChanges.subscribe(result => {
                this.isOnMobile = result.breakpoints[onMobile];
                this.isOnDesktop = result.breakpoints[onDesktop];
                const openMobile = this.isOnMobile ? false : this.isOpen ? this.isOpen : this.show;
                this.sidebarService.toggle({ open: openMobile, sidebar: this });
            });
        }
        else {
            this.layoutChangesSubscription.unsubscribe();
        }
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.layoutChangeSubscribe(false);
    }
    setInitialState() {
        this.openMobile = this.isOnDesktop ? false : this.isOnMobile ? false : this.show;
        this.openDesktop = this.hasBreakpoint;
        this.sidebarService.toggle({ minimize: this.minimize, open: this.isOpen, sidebar: this });
    }
    getState() {
        return { opened: this.isOpen, minimized: this.minimized, id: this.id };
    }
    open(state) {
        const toggle = (state.open === 'toggle');
        if (this.isOnDesktop) {
            this.openDesktop = toggle ? !this.openDesktop : state.open;
            this.openMobile = false;
        }
        else {
            this.openMobile = toggle ? !this.openMobile : state.open;
            if (this.openMobile && this.isOnMobile) {
                this.setBackdrop();
            }
            else {
                this.clearBackdrop();
            }
        }
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.sidebarService.sidebarState$.subscribe((state) => {
                if (this === state.sidebar || this.id === state.id) {
                    if ('minimize' in state) {
                        this.minimizeSidebar(state);
                    }
                    if ('open' in state) {
                        this.open(state);
                    }
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
    hideMobile(e) {
        if (this.isOpen) {
            if (!e.target.closest('[cSidebarNavDropdownToggle]')) {
                this.sidebarService.toggle({ open: false, sidebar: this });
            }
        }
    }
    setBackdrop() {
        const backdrop = this.document.getElementsByClassName('c-sidebar-backdrop');
        if (backdrop.length === 0) {
            this.backdrop = this.renderer.createElement('div');
            this.renderer.addClass(this.backdrop, 'c-sidebar-backdrop');
            this.renderer.appendChild(this.document.body, this.backdrop);
            this.renderer.listen(this.backdrop, 'click', (e) => {
                this.hideMobile(e);
            });
        }
        if (this.backdrop && this.isOnMobile && this.isOpen) {
            this.renderer.addClass(this.backdrop, 'c-show');
            this.renderer.removeClass(this.backdrop, 'd-none');
        }
        else {
            this.renderer.addClass(this.backdrop, 'd-none');
            this.renderer.removeClass(this.backdrop, 'c-show');
        }
    }
    clearBackdrop() {
        if (this.backdrop) {
            this.renderer.listen(this.backdrop, 'click', (e) => { });
            this.renderer.removeChild(this.document.body, this.backdrop);
        }
    }
    minimizeSidebar(state) {
        const toggle = (state.minimize === 'toggle');
        this.minimize = toggle ? !this.minimize : !!state.minimize;
    }
    ngOnChanges(changes) {
        if (changes.breakpoint) {
            const { previousValue, currentValue } = Object.assign({}, changes.breakpoint);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}-show`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}-show`);
        }
        if (changes.size) {
            const { previousValue, currentValue } = Object.assign({}, changes.size);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}`);
        }
        if (changes.colorScheme) {
            const { previousValue, currentValue } = Object.assign({}, changes.colorScheme);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}`);
        }
    }
}
SidebarComponent.ɵfac = function SidebarComponent_Factory(t) { return new (t || SidebarComponent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.BreakpointObserver), ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarComponent, selectors: [["c-sidebar"]], hostVars: 2, hostBindings: function SidebarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { fixed: "fixed", unfoldable: "unfoldable", overlaid: "overlaid", minimize: "minimize", breakpoint: "breakpoint", mobile: "mobile", size: "size", hideOnMobileClick: "hideOnMobileClick", colorScheme: "colorScheme", show: "show", aside: "aside", id: "id" }, exportAs: ["cSidebar"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function SidebarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
SidebarComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: BreakpointObserver },
    { type: SidebarService }
];
SidebarComponent.propDecorators = {
    fixed: [{ type: Input }],
    unfoldable: [{ type: Input }],
    overlaid: [{ type: Input }],
    minimize: [{ type: Input }],
    breakpoint: [{ type: Input }],
    mobile: [{ type: Input }],
    show: [{ type: Input }],
    size: [{ type: Input }],
    aside: [{ type: Input }],
    hideOnMobileClick: [{ type: Input }],
    colorScheme: [{ type: Input }],
    id: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar',
                exportAs: 'cSidebar',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc6.BreakpointObserver }, { type: SidebarService }]; }, { fixed: [{
            type: Input
        }], unfoldable: [{
            type: Input
        }], overlaid: [{
            type: Input
        }], minimize: [{
            type: Input
        }], breakpoint: [{
            type: Input
        }], mobile: [{
            type: Input
        }], size: [{
            type: Input
        }], hideOnMobileClick: [{
            type: Input
        }], colorScheme: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], show: [{
            type: Input
        }], aside: [{
            type: Input
        }], id: [{
            type: Input
        }] }); })();

class SidebarNavService {
}
SidebarNavService.ɵfac = function SidebarNavService_Factory(t) { return new (t || SidebarNavService)(); };
SidebarNavService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SidebarNavService, factory: SidebarNavService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavService, [{
        type: Injectable
    }], null, null); })();
class SidebarNavHelper {
    constructor() {
        this.hasBadge = (item) => Boolean(item.badge);
        this.hasIcon = (item) => Boolean(item.icon) || item.icon === '';
    }
    itemType(item) {
        if (item.divider) {
            return 'divider';
        }
        else if (item.title) {
            return 'title';
        }
        else if (item.children && item.children.length > 0) {
            return 'dropdown';
        }
        else if (item.label) {
            return 'label';
        }
        else if (!Object.keys(item).length) {
            return 'empty';
        }
        else {
            return 'link';
        }
    }
    isActive(router, item) {
        return router.isActive(item.url, false);
    }
    getIconClass(item) {
        const classes = {
            'c-sidebar-nav-icon': true
        };
        const icon = item.icon;
        classes[icon] = this.hasIcon(item);
        return classes;
    }
}
SidebarNavHelper.ɵfac = function SidebarNavHelper_Factory(t) { return new (t || SidebarNavHelper)(); };
SidebarNavHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SidebarNavHelper, factory: SidebarNavHelper.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavHelper, [{
        type: Injectable
    }], function () { return []; }, null); })();

class SidebarNavComponent {
    constructor(sidebar, helper, router, renderer, hostElement, sidebarService) {
        this.sidebar = sidebar;
        this.helper = helper;
        this.router = router;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.sidebarService = sidebarService;
        this.navItems = [];
        this.dropdownMode = 'closeInactive';
        this.role = 'nav';
        this.navItemsArray = [];
    }
    get sidebarNavClass() {
        return !this.dropdownItems;
    }
    get sidebarNavDropdownItemsClass() {
        return this.dropdownItems;
    }
    ngOnChanges(changes) {
        this.navItemsArray = Array.isArray(this.navItems) ? this.navItems.slice() : [];
    }
    hideMobile() {
        if (this.sidebar && this.sidebar.hideOnMobileClick && this.sidebar.isOnMobile) {
            this.sidebarService.toggle({ open: false, sidebar: this.sidebar });
        }
    }
}
SidebarNavComponent.ɵfac = function SidebarNavComponent_Factory(t) { return new (t || SidebarNavComponent)(ɵngcc0.ɵɵdirectiveInject(SidebarComponent, 8), ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarNavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavComponent, selectors: [["c-sidebar-nav"]], hostVars: 5, hostBindings: function SidebarNavComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("c-sidebar-nav", ctx.sidebarNavClass)("c-sidebar-nav-dropdown-items", ctx.sidebarNavDropdownItemsClass);
    } }, inputs: { navItems: "navItems", dropdownMode: "dropdownMode", dropdownItems: "dropdownItems" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], [3, "ngSwitch"], [3, "item", "ngClass", 4, "ngSwitchCase"], [3, "item", "ngClass", "cHtmlAttr", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [3, "item", "ngClass", "linkClick", 4, "ngSwitchDefault"], [3, "item", "ngClass"], [3, "item", "ngClass", "cHtmlAttr"], [3, "item", "ngClass", "linkClick"]], template: function SidebarNavComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SidebarNavComponent_ng_container_0_Template, 8, 6, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.navItemsArray);
    } }, directives: function () { return [ɵngcc3.NgForOf, ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgSwitchDefault, SidebarNavDropdownComponent, ɵngcc3.NgClass, SidebarNavDividerComponent, HtmlAttributesDirective, SidebarNavTitleComponent, SidebarNavLabelComponent, SidebarNavLinkComponent]; }, pipes: function () { return [SidebarNavItemClassPipe]; }, styles: ["[_nghost-%COMP%] {flex: 1;}", ".c-sidebar-minimized   [_nghost-%COMP%] {overflow: visible !important;}"] });
SidebarNavComponent.ctorParameters = () => [
    { type: SidebarComponent, decorators: [{ type: Optional }] },
    { type: SidebarNavHelper },
    { type: Router },
    { type: Renderer2 },
    { type: ElementRef },
    { type: SidebarService }
];
SidebarNavComponent.propDecorators = {
    navItems: [{ type: Input }],
    dropdownMode: [{ type: Input }],
    dropdownItems: [{ type: Input }],
    sidebarNavClass: [{ type: HostBinding, args: ['class.c-sidebar-nav',] }],
    sidebarNavDropdownItemsClass: [{ type: HostBinding, args: ['class.c-sidebar-nav-dropdown-items',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav',
                template: "<!--<c-sidebar-nav-items-->\r\n<!--  class=\"c-sidebar-nav\"-->\r\n<!--  [items]=\"navItemsArray\">-->\r\n<!--</c-sidebar-nav-items>-->\r\n<ng-container *ngFor=\"let item of navItemsArray\">\r\n  <ng-container [ngSwitch]=\"helper.itemType(item)\">\r\n    <c-sidebar-nav-dropdown\r\n      *ngSwitchCase=\"'dropdown'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\">\r\n    </c-sidebar-nav-dropdown>\r\n<!--\r\n    <c-sidebar-nav-dropdown\r\n      *ngSwitchCase=\"'dropdown'\"\r\n      [item]=\"item\"\r\n      [class.c-show]=\"helper.isActive(router, item)\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      cSidebarNavDropdown\r\n      [dropdownMode]=\"dropdownMode\"\r\n      [routerLinkActive]=\"'c-show'\">\r\n    </c-sidebar-nav-dropdown>\r\n-->\r\n    <c-sidebar-nav-divider\r\n      *ngSwitchCase=\"'divider'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      [cHtmlAttr]=\"item.attributes\">\r\n    </c-sidebar-nav-divider>\r\n    <c-sidebar-nav-title\r\n      *ngSwitchCase=\"'title'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      [cHtmlAttr]=\"item.attributes\">\r\n    </c-sidebar-nav-title>\r\n    <c-sidebar-nav-label\r\n      *ngSwitchCase=\"'label'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\">\r\n    </c-sidebar-nav-label>\r\n    <ng-container\r\n      *ngSwitchCase=\"'empty'\">\r\n    </ng-container>\r\n    <c-sidebar-nav-link\r\n      *ngSwitchDefault\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      (linkClick)=\"hideMobile()\"\r\n    >\r\n    </c-sidebar-nav-link>\r\n  </ng-container>\r\n</ng-container>\r\n",
                styles: [':host {flex: 1;}',
                    '.c-sidebar-minimized :host {overflow: visible !important;}']
            }]
    }], function () { return [{ type: SidebarComponent, decorators: [{
                type: Optional
            }] }, { type: SidebarNavHelper }, { type: ɵngcc4.Router }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: SidebarService }]; }, { navItems: [{
            type: Input
        }], dropdownMode: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], sidebarNavClass: [{
            type: HostBinding,
            args: ['class.c-sidebar-nav']
        }], sidebarNavDropdownItemsClass: [{
            type: HostBinding,
            args: ['class.c-sidebar-nav-dropdown-items']
        }], dropdownItems: [{
            type: Input
        }] }); })();

class SidebarNavDividerComponent {
    constructor() { }
    ngOnInit() { }
}
SidebarNavDividerComponent.ɵfac = function SidebarNavDividerComponent_Factory(t) { return new (t || SidebarNavDividerComponent)(); };
SidebarNavDividerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavDividerComponent, selectors: [["c-sidebar-nav-divider"]], inputs: { item: "item" }, decls: 0, vars: 0, template: function SidebarNavDividerComponent_Template(rf, ctx) { }, encapsulation: 2 });
SidebarNavDividerComponent.ctorParameters = () => [];
SidebarNavDividerComponent.propDecorators = {
    item: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavDividerComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-divider',
                template: ``
            }]
    }], function () { return []; }, { item: [{
            type: Input
        }] }); })();

class SidebarNavDropdownComponent {
    constructor(router, helper) {
        this.router = router;
        this.helper = helper;
        this.dropdownMode = 'closeInactive';
        this.navItems = [];
        this.navigationEndObservable = router.events.pipe(filter(event => event instanceof NavigationEnd));
    }
    get getClasses() {
        return this.hostClasses;
    }
    ngOnInit() {
        this.navItems = [...this.item.children];
        this.navSubscription = this.navigationEndObservable.subscribe(event => {
            const itemArray = this.item.url.split('/');
            const urlArray = event.url.split('/');
            const samePath = itemArray.every((value, index) => value === urlArray[index]);
            this.openDropdown(samePath);
        });
    }
    openDropdown(open) {
        this.open = open;
    }
    toggleDropdown() {
        this.open = !this.open;
    }
    ngOnDestroy() {
        this.navSubscription.unsubscribe();
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-sidebar-nav-dropdown': true,
            'c-show': this.open,
        });
        return classes;
    }
}
SidebarNavDropdownComponent.ɵfac = function SidebarNavDropdownComponent_Factory(t) { return new (t || SidebarNavDropdownComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Router), ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper)); };
SidebarNavDropdownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavDropdownComponent, selectors: [["c-sidebar-nav-dropdown"]], hostVars: 2, hostBindings: function SidebarNavDropdownComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { dropdownMode: "dropdownMode", item: "item", show: "show", class: "class", ngClass: "ngClass" }, features: [ɵngcc0.ɵɵProvidersFeature([SidebarNavHelper])], decls: 6, vars: 6, consts: [["cSidebarNavDropdownToggle", "", 1, "c-sidebar-nav-dropdown-toggle", 3, "cHtmlAttr"], [3, "ngClass", 4, "ngIf"], [3, "dropdownItems", "navItems"], [3, "ngClass"]], template: function SidebarNavDropdownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtemplate(1, SidebarNavDropdownComponent_i_1_Template, 2, 3, "i", 1);
        ɵngcc0.ɵɵelementContainerStart(2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(4, SidebarNavDropdownComponent_span_4_Template, 3, 4, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "c-sidebar-nav", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("cHtmlAttr", ctx.item.attributes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.helper.hasIcon(ctx.item));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.item.name);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.helper.hasBadge(ctx.item));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("dropdownItems", true)("navItems", ctx.navItems);
    } }, directives: function () { return [SidebarNavDropdownToggleDirective, HtmlAttributesDirective, ɵngcc3.NgIf, SidebarNavComponent, ɵngcc3.NgClass]; }, pipes: function () { return [SidebarNavIconPipe, SidebarNavBadgePipe]; }, styles: [".c-sidebar-nav-dropdown-toggle[_ngcontent-%COMP%]{cursor:pointer}.c-sidebar-nav-dropdown-items[_ngcontent-%COMP%]{display:block}"] });
SidebarNavDropdownComponent.ctorParameters = () => [
    { type: Router },
    { type: SidebarNavHelper }
];
SidebarNavDropdownComponent.propDecorators = {
    item: [{ type: Input }],
    dropdownMode: [{ type: Input }],
    show: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavDropdownComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-dropdown',
                template: `
    <a class="c-sidebar-nav-dropdown-toggle"
       cSidebarNavDropdownToggle
       [cHtmlAttr]="item.attributes">
      <i *ngIf="helper.hasIcon(item)" [ngClass]="item | cSidebarNavIcon"></i>
      <ng-container>{{ item.name }}</ng-container>
      <span *ngIf="helper.hasBadge(item)" [ngClass]="item | cSidebarNavBadge">{{ item.badge.text }}</span>
    </a>
    <c-sidebar-nav
      [dropdownItems]="true"
      [navItems]="navItems">
    </c-sidebar-nav>
  `,
                providers: [SidebarNavHelper],
                styles: [".c-sidebar-nav-dropdown-toggle{cursor:pointer}.c-sidebar-nav-dropdown-items{display:block}"]
            }]
    }], function () { return [{ type: ɵngcc4.Router }, { type: SidebarNavHelper }]; }, { dropdownMode: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], item: [{
            type: Input
        }], show: [{
            type: Input
        }], class: [{
            type: Input
        }], ngClass: [{
            type: Input
        }] }); })();

class SidebarNavItemsComponent {
    constructor(router, helper) {
        this.router = router;
        this.helper = helper;
    }
    set items(items) {
        this._items = [...items];
    }
    get items() {
        return this._items;
    }
}
SidebarNavItemsComponent.ɵfac = function SidebarNavItemsComponent_Factory(t) { return new (t || SidebarNavItemsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Router), ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper)); };
SidebarNavItemsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavItemsComponent, selectors: [["c-sidebar-nav-items"]], inputs: { items: "items" }, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], [3, "ngSwitch"], ["cSidebarNavDropdown", "", "routerLinkActive", "c-show", 3, "item", "c-show", "ngClass", 4, "ngSwitchCase"], [3, "item", "ngClass", "cHtmlAttr", 4, "ngSwitchCase"], [3, "item", "ngClass", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [3, "item", "ngClass", 4, "ngSwitchDefault"], ["cSidebarNavDropdown", "", "routerLinkActive", "c-show", 3, "item", "ngClass"], [3, "item", "ngClass", "cHtmlAttr"], [3, "item", "ngClass"]], template: function SidebarNavItemsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SidebarNavItemsComponent_ng_container_0_Template, 8, 6, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: function () { return [ɵngcc3.NgForOf, ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgSwitchDefault, SidebarNavDropdownComponent, ɵngcc4.RouterLinkActive, ɵngcc3.NgClass, SidebarNavDividerComponent, HtmlAttributesDirective, SidebarNavTitleComponent, SidebarNavLabelComponent, SidebarNavLinkComponent]; }, pipes: function () { return [SidebarNavItemClassPipe]; }, encapsulation: 2 });
SidebarNavItemsComponent.ctorParameters = () => [
    { type: Router },
    { type: SidebarNavHelper }
];
SidebarNavItemsComponent.propDecorators = {
    items: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavItemsComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-items',
                template: `
    <ng-container *ngFor="let item of items">
      <ng-container [ngSwitch]="helper.itemType(item)">
        <c-sidebar-nav-dropdown
          *ngSwitchCase="'dropdown'"
          [item]="item"
          [class.c-show]="helper.isActive(router, item)"
          [ngClass]="item | cSidebarNavItemClass"
          cSidebarNavDropdown
          routerLinkActive="c-show">
        </c-sidebar-nav-dropdown>
        <c-sidebar-nav-divider
          *ngSwitchCase="'divider'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
          [cHtmlAttr]="item.attributes">
        </c-sidebar-nav-divider>
        <c-sidebar-nav-title
          *ngSwitchCase="'title'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
          [cHtmlAttr]="item.attributes">
        </c-sidebar-nav-title>
        <c-sidebar-nav-label
          *ngSwitchCase="'label'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass">
        </c-sidebar-nav-label>
        <ng-container
          *ngSwitchCase="'empty'">
        </ng-container>
        <c-sidebar-nav-link
          *ngSwitchDefault
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
        >
        </c-sidebar-nav-link>
      </ng-container>
    </ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc4.Router }, { type: SidebarNavHelper }]; }, { items: [{
            type: Input
        }] }); })();

class SidebarNavLinkContentComponent {
    constructor(helper) {
        this.helper = helper;
    }
}
SidebarNavLinkContentComponent.ɵfac = function SidebarNavLinkContentComponent_Factory(t) { return new (t || SidebarNavLinkContentComponent)(ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper)); };
SidebarNavLinkContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavLinkContentComponent, selectors: [["c-sidebar-nav-link-content"]], inputs: { item: "item" }, features: [ɵngcc0.ɵɵProvidersFeature([SidebarNavHelper])], decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function SidebarNavLinkContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SidebarNavLinkContentComponent_ng_container_0_Template, 3, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", true);
    } }, directives: [ɵngcc3.NgIf], encapsulation: 2 });
SidebarNavLinkContentComponent.ctorParameters = () => [
    { type: SidebarNavHelper }
];
SidebarNavLinkContentComponent.propDecorators = {
    item: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavLinkContentComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-link-content',
                template: `
    <ng-container *ngIf="true">
      <ng-container>{{item.name}}</ng-container>
    </ng-container>
  `,
                providers: [SidebarNavHelper]
            }]
    }], function () { return [{ type: SidebarNavHelper }]; }, { item: [{
            type: Input
        }] }); })();
class SidebarNavLinkComponent {
    constructor(router, renderer, hostElement, sidebarService) {
        this.router = router;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.sidebarService = sidebarService;
        this.linkClick = new EventEmitter();
        this.navigationEndObservable = router.events.pipe(filter(event => {
            return event instanceof NavigationEnd;
        }));
    }
    set item(item) {
        this._item = JSON.parse(JSON.stringify(item));
    }
    get item() {
        return this._item;
    }
    ngOnInit() {
        this.url = typeof this.item.url === 'string' ? this.item.url : this.router.serializeUrl(this.router.createUrlTree(this.item.url));
        this.linkType = this.getLinkType();
        this.href = this.isDisabled() ? '' : (this.item.href || this.url);
        this.linkActive = this.router.url.split(/[?#(;]/)[0] === this.href.split(/[?#(;]/)[0];
        this.navSubscription = this.navigationEndObservable.subscribe(event => {
            const itemUrlArray = this.href.split(/[?#(;]/)[0].split('/');
            const urlArray = event.urlAfterRedirects.split(/[?#(;]/)[0].split('/');
            this.linkActive = itemUrlArray.every((value, index) => value === urlArray[index]);
        });
    }
    ngOnDestroy() {
        this.navSubscription.unsubscribe();
    }
    getLinkType() {
        return this.isDisabled() ? 'disabled' : this.isExternalLink() ? 'external' : 'link';
    }
    isDisabled() {
        return (this.item.attributes && this.item.attributes.disabled) ? true : null;
    }
    isExternalLink() {
        const linkPath = Array.isArray(this.item.url) ? this.item.url[0] : this.item.url;
        return !!this.item.href || linkPath.substring(0, 4) === 'http';
    }
    linkClicked() {
        this.linkClick.emit();
    }
}
SidebarNavLinkComponent.ɵfac = function SidebarNavLinkComponent_Factory(t) { return new (t || SidebarNavLinkComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarNavLinkComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavLinkComponent, selectors: [["c-sidebar-nav-link"]], inputs: { item: "item" }, outputs: { linkClick: "linkClick" }, features: [ɵngcc0.ɵɵProvidersFeature([SidebarNavHelper])], decls: 4, vars: 3, consts: [[3, "ngSwitch"], [3, "ngClass", "cHtmlAttr", 4, "ngSwitchCase"], [3, "ngClass", "href", "cHtmlAttr", "click", 4, "ngSwitchCase"], [3, "ngClass", "cHtmlAttr", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "routerLink", "c-active", "click", 4, "ngSwitchDefault"], [3, "ngClass", "cHtmlAttr"], [3, "ngClass", 4, "ngIf"], [3, "item"], [3, "ngClass"], [3, "ngClass", "href", "cHtmlAttr", "click"], [3, "ngClass", "cHtmlAttr", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "routerLink", "click"]], template: function SidebarNavLinkComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, SidebarNavLinkComponent_a_1_Template, 6, 8, "a", 1);
        ɵngcc0.ɵɵtemplate(2, SidebarNavLinkComponent_a_2_Template, 6, 9, "a", 2);
        ɵngcc0.ɵɵtemplate(3, SidebarNavLinkComponent_a_3_Template, 6, 19, "a", 3);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.linkType);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "disabled");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "external");
    } }, directives: function () { return [ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgSwitchDefault, ɵngcc3.NgClass, HtmlAttributesDirective, ɵngcc3.NgIf, SidebarNavLinkContentComponent, ɵngcc4.RouterLinkWithHref]; }, pipes: function () { return [SidebarNavLinkPipe, SidebarNavIconPipe, SidebarNavBadgePipe]; }, encapsulation: 2 });
SidebarNavLinkComponent.ctorParameters = () => [
    { type: Router },
    { type: Renderer2 },
    { type: ElementRef },
    { type: SidebarService }
];
SidebarNavLinkComponent.propDecorators = {
    item: [{ type: Input }],
    linkClick: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavLinkComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-link',
                template: "<ng-container [ngSwitch]=\"linkType\">\r\n  <a *ngSwitchCase=\"'disabled'\"\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n  <a *ngSwitchCase=\"'external'\"\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [href]=\"href\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n     (click)=\"linkClicked()\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n  <a *ngSwitchDefault\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n     [target]=\"item.attributes?.target\"\r\n     [queryParams]=\"item.linkProps?.queryParams\"\r\n     [fragment]=\"item.linkProps?.fragment\"\r\n     [queryParamsHandling]=\"item.linkProps?.queryParamsHandling\"\r\n     [preserveFragment]=\"item.linkProps?.preserveFragment\"\r\n     [skipLocationChange]=\"item.linkProps?.skipLocationChange\"\r\n     [replaceUrl]=\"item.linkProps?.replaceUrl\"\r\n     [state]=\"item.linkProps?.state\"\r\n     [routerLink]=\"item.url\"\r\n     [class.c-active]=\"linkActive\"\r\n     (click)=\"linkClicked()\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n</ng-container>\r\n",
                providers: [SidebarNavHelper]
            }]
    }], function () { return [{ type: ɵngcc4.Router }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: SidebarService }]; }, { linkClick: [{
            type: Output
        }], item: [{
            type: Input
        }] }); })();

class SidebarNavTitleComponent {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    ngOnInit() {
        const nativeElement = this.el.nativeElement;
        const name = this.renderer.createText(this.item.name);
        if (this.item.class) {
            const classes = this.item.class;
            this.renderer.addClass(nativeElement, classes);
        }
        if (this.item.wrapper) {
            const wrapper = this.renderer.createElement(this.item.wrapper.element);
            this.addAttribs(this.item.wrapper.attributes, wrapper);
            this.renderer.appendChild(wrapper, name);
            this.renderer.appendChild(nativeElement, wrapper);
        }
        else {
            this.renderer.appendChild(nativeElement, name);
        }
    }
    addAttribs(attribs, element) {
        if (attribs) {
            for (const attr in attribs) {
                if (attr === 'style' && typeof (attribs[attr]) === 'object') {
                    this.setStyle(attribs[attr], element);
                }
                else if (attr === 'class') {
                    this.addClass(attribs[attr], element);
                }
                else {
                    this.setAttrib(attr, attribs[attr], element);
                }
            }
        }
    }
    setStyle(styles, el) {
        for (const style in styles) {
            if (style) {
                this.renderer.setStyle(el, style, styles[style]);
            }
        }
    }
    addClass(classes, el) {
        const classArray = (Array.isArray(classes) ? classes : classes.split(' '));
        classArray.filter((element) => element.length > 0).forEach(element => {
            this.renderer.addClass(el, element);
        });
    }
    setAttrib(key, value, el) {
        this.renderer.setAttribute(el, key, value);
    }
}
SidebarNavTitleComponent.ɵfac = function SidebarNavTitleComponent_Factory(t) { return new (t || SidebarNavTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
SidebarNavTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavTitleComponent, selectors: [["c-sidebar-nav-title"]], inputs: { item: "item" }, decls: 0, vars: 0, template: function SidebarNavTitleComponent_Template(rf, ctx) { }, encapsulation: 2 });
SidebarNavTitleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SidebarNavTitleComponent.propDecorators = {
    item: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavTitleComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-title',
                template: ''
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { item: [{
            type: Input
        }] }); })();

class SidebarNavLabelComponent {
    constructor(helper) {
        this.helper = helper;
        this.classes = {
            'c-nav-label': true,
            'c-active': true
        };
        this.iconClasses = {};
    }
    ngOnInit() {
        this.iconClasses = this.helper.getIconClass(this.item);
    }
    getItemClass() {
        const itemClass = this.item.class;
        this.classes[itemClass] = !!itemClass;
        return this.classes;
    }
    getLabelIconClass() {
        const variant = `text-${this.item.label.variant}`;
        this.iconClasses[variant] = !!this.item.label.variant;
        const labelClass = this.item.label.class;
        this.iconClasses[labelClass] = !!labelClass;
        return this.iconClasses;
    }
}
SidebarNavLabelComponent.ɵfac = function SidebarNavLabelComponent_Factory(t) { return new (t || SidebarNavLabelComponent)(ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper)); };
SidebarNavLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SidebarNavLabelComponent, selectors: [["c-sidebar-nav-label"]], inputs: { item: "item" }, decls: 5, vars: 6, consts: [[3, "ngClass", "href", "cHtmlAttr"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"]], template: function SidebarNavLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵtemplate(1, SidebarNavLabelComponent_i_1_Template, 1, 1, "i", 1);
        ɵngcc0.ɵɵelementContainerStart(2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(4, SidebarNavLabelComponent_span_4_Template, 3, 4, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("href", ctx.item.url, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵproperty("ngClass", ctx.getItemClass())("cHtmlAttr", ctx.item.attributes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.helper.hasIcon(ctx.item));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.item.name);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.helper.hasBadge(ctx.item));
    } }, directives: function () { return [ɵngcc3.NgClass, HtmlAttributesDirective, ɵngcc3.NgIf]; }, pipes: function () { return [SidebarNavBadgePipe]; }, encapsulation: 2 });
SidebarNavLabelComponent.ctorParameters = () => [
    { type: SidebarNavHelper }
];
SidebarNavLabelComponent.propDecorators = {
    item: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavLabelComponent, [{
        type: Component,
        args: [{
                selector: 'c-sidebar-nav-label',
                template: "<a [ngClass]=\"getItemClass()\"\r\n   href=\"{{item.url}}\"\r\n   [cHtmlAttr]=\"item.attributes\">\r\n  <i *ngIf=\"helper.hasIcon(item)\" [ngClass]=\"getLabelIconClass()\"></i>\r\n  <ng-container>{{ item.name }}</ng-container>\r\n  <span *ngIf=\"helper.hasBadge(item)\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\r\n</a>\r\n"
            }]
    }], function () { return [{ type: SidebarNavHelper }]; }, { item: [{
            type: Input
        }] }); })();

class SidebarNavIconPipe {
    transform(item, args) {
        const classes = {
            'c-sidebar-nav-icon': true
        };
        const icon = item.icon;
        classes[icon] = !!item.icon;
        return classes;
    }
}
SidebarNavIconPipe.ɵfac = function SidebarNavIconPipe_Factory(t) { return new (t || SidebarNavIconPipe)(); };
SidebarNavIconPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "cSidebarNavIcon", type: SidebarNavIconPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavIconPipe, [{
        type: Pipe,
        args: [{
                name: 'cSidebarNavIcon'
            }]
    }], null, null); })();

class SidebarNavBadgePipe {
    transform(item, args) {
        const classes = {
            badge: true
        };
        const variant = `badge-${item.badge.variant}`;
        classes[variant] = !!item.badge.variant;
        classes[item.badge.class] = !!item.badge.class;
        return classes;
    }
}
SidebarNavBadgePipe.ɵfac = function SidebarNavBadgePipe_Factory(t) { return new (t || SidebarNavBadgePipe)(); };
SidebarNavBadgePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "cSidebarNavBadge", type: SidebarNavBadgePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavBadgePipe, [{
        type: Pipe,
        args: [{
                name: 'cSidebarNavBadge'
            }]
    }], null, null); })();

class SidebarNavItemClassPipe {
    constructor(helper) {
        this.helper = helper;
    }
    transform(item, args) {
        const itemType = this.helper.itemType(item);
        let itemClass;
        if (['divider', 'title'].includes(itemType)) {
            itemClass = `c-sidebar-nav-${itemType}`;
        }
        else if (itemType === 'dropdown') {
            itemClass = '';
        }
        else {
            itemClass = 'c-sidebar-nav-item';
        }
        return item.class ? `${itemClass} ${item.class}` : itemClass;
    }
}
SidebarNavItemClassPipe.ɵfac = function SidebarNavItemClassPipe_Factory(t) { return new (t || SidebarNavItemClassPipe)(ɵngcc0.ɵɵdirectiveInject(SidebarNavHelper)); };
SidebarNavItemClassPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "cSidebarNavItemClass", type: SidebarNavItemClassPipe, pure: true });
SidebarNavItemClassPipe.ctorParameters = () => [
    { type: SidebarNavHelper }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavItemClassPipe, [{
        type: Pipe,
        args: [{
                name: 'cSidebarNavItemClass'
            }]
    }], function () { return [{ type: SidebarNavHelper }]; }, null); })();

class SidebarNavLinkPipe {
    transform(item) {
        var _a;
        const disabled = (_a = item === null || item === void 0 ? void 0 : item.attributes) === null || _a === void 0 ? void 0 : _a.disabled;
        const classes = {
            'c-sidebar-nav-link': true,
            disabled,
            'btn-link': disabled,
        };
        classes[`c-sidebar-nav-link-${item.variant}`] = !!item.variant;
        return classes;
    }
}
SidebarNavLinkPipe.ɵfac = function SidebarNavLinkPipe_Factory(t) { return new (t || SidebarNavLinkPipe)(); };
SidebarNavLinkPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "cSidebarNavLink", type: SidebarNavLinkPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavLinkPipe, [{
        type: Pipe,
        args: [{
                name: 'cSidebarNavLink'
            }]
    }], null, null); })();

class SidebarNavDropdownToggleDirective {
    constructor(sidebarNavDropdown) {
        this.sidebarNavDropdown = sidebarNavDropdown;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.sidebarNavDropdown.toggleDropdown();
    }
}
SidebarNavDropdownToggleDirective.ɵfac = function SidebarNavDropdownToggleDirective_Factory(t) { return new (t || SidebarNavDropdownToggleDirective)(ɵngcc0.ɵɵdirectiveInject(SidebarNavDropdownComponent)); };
SidebarNavDropdownToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SidebarNavDropdownToggleDirective, selectors: [["", "cSidebarNavDropdownToggle", ""]], hostBindings: function SidebarNavDropdownToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function SidebarNavDropdownToggleDirective_click_HostBindingHandler($event) { return ctx.toggleOpen($event); });
    } }, exportAs: ["cSidebarNavDropdownToggle"] });
SidebarNavDropdownToggleDirective.ctorParameters = () => [
    { type: SidebarNavDropdownComponent }
];
SidebarNavDropdownToggleDirective.propDecorators = {
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarNavDropdownToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[cSidebarNavDropdownToggle]',
                exportAs: 'cSidebarNavDropdownToggle'
            }]
    }], function () { return [{ type: SidebarNavDropdownComponent }]; }, { toggleOpen: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

class SidebarModule {
}
SidebarModule.ɵfac = function SidebarModule_Factory(t) { return new (t || SidebarModule)(); };
SidebarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SidebarModule });
SidebarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        OutClickService,
        SidebarService,
        SidebarNavHelper,
    ], imports: [[
            CommonModule,
            RouterModule,
            SharedModule
        ], SharedModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SidebarModule, { declarations: function () { return [SidebarBrandComponent, SidebarFooterComponent, SidebarFormComponent, SidebarHeaderComponent, SidebarMinimizerComponent, SidebarComponent, SidebarNavItemsComponent, SidebarNavComponent, SidebarNavDividerComponent, SidebarNavDropdownComponent, SidebarNavLinkComponent, SidebarNavLinkContentComponent, SidebarNavTitleComponent, SidebarNavDropdownToggleDirective, SidebarNavLabelComponent, SidebarNavIconPipe, SidebarNavBadgePipe, SidebarNavItemClassPipe, SidebarNavLinkPipe, SidebarBackdropComponent, SidebarToggleDirective, SidebarMinimizeDirective]; }, imports: function () { return [CommonModule,
        RouterModule, SharedModule]; }, exports: function () { return [SidebarBrandComponent, SidebarFooterComponent, SidebarFormComponent, SidebarHeaderComponent, SidebarMinimizerComponent, SidebarComponent, SidebarNavItemsComponent, SidebarNavComponent, SidebarNavDividerComponent, SidebarNavDropdownComponent, SidebarNavLinkComponent, SidebarNavLinkContentComponent, SidebarNavTitleComponent, SidebarToggleDirective, SidebarMinimizeDirective, SharedModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    SharedModule
                ],
                exports: [
                    SidebarBrandComponent,
                    SidebarFooterComponent,
                    SidebarFormComponent,
                    SidebarHeaderComponent,
                    SidebarMinimizerComponent,
                    SidebarComponent,
                    SidebarNavItemsComponent,
                    SidebarNavComponent,
                    SidebarNavDividerComponent,
                    SidebarNavDropdownComponent,
                    SidebarNavLinkComponent,
                    SidebarNavLinkContentComponent,
                    SidebarNavTitleComponent,
                    SidebarToggleDirective,
                    SidebarMinimizeDirective,
                    SharedModule
                ],
                declarations: [
                    SidebarBrandComponent,
                    SidebarFooterComponent,
                    SidebarFormComponent,
                    SidebarHeaderComponent,
                    SidebarMinimizerComponent,
                    SidebarComponent,
                    SidebarNavItemsComponent,
                    SidebarNavComponent,
                    SidebarNavDividerComponent,
                    SidebarNavDropdownComponent,
                    SidebarNavLinkComponent,
                    SidebarNavLinkContentComponent,
                    SidebarNavTitleComponent,
                    SidebarNavDropdownToggleDirective,
                    SidebarNavLabelComponent,
                    SidebarNavIconPipe,
                    SidebarNavBadgePipe,
                    SidebarNavItemClassPipe,
                    SidebarNavLinkPipe,
                    SidebarBackdropComponent,
                    SidebarToggleDirective,
                    SidebarMinimizeDirective
                ],
                providers: [
                    OutClickService,
                    SidebarService,
                    SidebarNavHelper,
                ]
            }]
    }], null, null); })();

class SpinkitComponent {
    constructor() {
        this.center = true;
        this.name = 'plane';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            [`sk-${this.name}`]: true,
            'sk-center': this.center,
        });
        return classes;
    }
    ngOnInit() { }
}
SpinkitComponent.ɵfac = function SpinkitComponent_Factory(t) { return new (t || SpinkitComponent)(); };
SpinkitComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SpinkitComponent, selectors: [["c-spinkit"]], hostVars: 2, hostBindings: function SpinkitComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { center: "center", name: "name" }, decls: 14, vars: 13, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [1, "sk-chase-dot"], [1, "sk-bounce-dot"], [1, "sk-wave-rect"], [1, "sk-flow-dot"], [1, "sk-swing-dot"], [1, "sk-circle-dot"], [1, "sk-circle-fade-dot"], [1, "sk-grid-cube"], [1, "sk-fold-cube"], [1, "sk-wander-cube"]], template: function SpinkitComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, SpinkitComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, SpinkitComponent_ng_container_2_Template, 7, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, SpinkitComponent_ng_container_3_Template, 3, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(4, SpinkitComponent_ng_container_4_Template, 6, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(5, SpinkitComponent_ng_container_5_Template, 1, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(6, SpinkitComponent_ng_container_6_Template, 4, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(7, SpinkitComponent_ng_container_7_Template, 3, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(8, SpinkitComponent_ng_container_8_Template, 13, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(9, SpinkitComponent_ng_container_9_Template, 13, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(10, SpinkitComponent_ng_container_10_Template, 10, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(11, SpinkitComponent_ng_container_11_Template, 5, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(12, SpinkitComponent_ng_container_12_Template, 5, 0, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(13, SpinkitComponent_ng_container_13_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.name);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "plane");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "chase");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "bounce");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "wave");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "pulse");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "flow");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "swing");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "circle");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "circle-fade");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "grid");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "fold");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "wander");
    } }, directives: [ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgSwitchDefault], styles: ["[_nghost-%COMP%]{display:block}.sk-wave[_nghost-%COMP%]{display:flex}.sk-flow[_nghost-%COMP%]{display:flex;align-items:center}"] });
SpinkitComponent.ctorParameters = () => [];
SpinkitComponent.propDecorators = {
    center: [{ type: Input }],
    name: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpinkitComponent, [{
        type: Component,
        args: [{
                selector: 'c-spinkit',
                template: "<ng-container [ngSwitch]=\"name\">\n  <ng-container *ngSwitchCase=\"'plane'\"></ng-container>\n  <ng-container *ngSwitchCase=\"'chase'\">\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'bounce'\">\n    <div class=\"sk-bounce-dot\"></div>\n    <div class=\"sk-bounce-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'wave'\">\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'pulse'\"></ng-container>\n  <ng-container *ngSwitchCase=\"'flow'\">\n    <div class=\"sk-flow-dot\"></div>\n    <div class=\"sk-flow-dot\"></div>\n    <div class=\"sk-flow-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'swing'\">\n    <div class=\"sk-swing-dot\"></div>\n    <div class=\"sk-swing-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'circle'\">\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'circle-fade'\">\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'grid'\">\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'fold'\">\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'wander'\">\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchDefault></ng-container>\n</ng-container>\n",
                styles: [":host{display:block}:host.sk-wave{display:flex}:host.sk-flow{display:flex;align-items:center}"]
            }]
    }], function () { return []; }, { center: [{
            type: Input
        }], name: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class SpinkitModule {
}
SpinkitModule.ɵfac = function SpinkitModule_Factory(t) { return new (t || SpinkitModule)(); };
SpinkitModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SpinkitModule });
SpinkitModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SpinkitModule, { declarations: function () { return [SpinkitComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SpinkitComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpinkitModule, [{
        type: NgModule,
        args: [{
                declarations: [SpinkitComponent],
                exports: [
                    SpinkitComponent
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class SpinnerComponent {
    constructor() {
        this.color = '';
        this.grow = false;
        this.size = '';
        this.role = 'status';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const shape = this.grow ? 'grow' : 'border';
        const classes = classNames({
            [`spinner-${shape}`]: true,
            [`text-${this.color}`]: !!this.color,
            [`spinner-${shape}-${this.size}`]: !!this.size
        });
        return classes;
    }
}
SpinnerComponent.ɵfac = function SpinnerComponent_Factory(t) { return new (t || SpinnerComponent)(); };
SpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SpinnerComponent, selectors: [["c-spinner"]], hostVars: 3, hostBindings: function SpinnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { color: "color", grow: "grow", size: "size", role: "role" }, decls: 2, vars: 0, consts: [[1, "sr-only"]], template: function SpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1, "Loading...");
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [""] });
SpinnerComponent.propDecorators = {
    color: [{ type: Input }],
    grow: [{ type: Input }],
    size: [{ type: Input }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'c-spinner',
                template: "<!--<div [ngClass]=\"classes\" [attr.role]=\"role\" [ngStyle]=\"styles\">-->\n  <span class=\"sr-only\">Loading...</span>\n<!--</div>-->\n",
                styles: [""]
            }]
    }], function () { return []; }, { color: [{
            type: Input
        }], grow: [{
            type: Input
        }], size: [{
            type: Input
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class SpinnerModule {
}
SpinnerModule.ɵfac = function SpinnerModule_Factory(t) { return new (t || SpinnerModule)(); };
SpinnerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SpinnerModule });
SpinnerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            SharedModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SpinnerModule, { declarations: function () { return [SpinnerComponent]; }, imports: function () { return [CommonModule, SharedModule]; }, exports: function () { return [SpinnerComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpinnerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SpinnerComponent
                ],
                exports: [
                    SpinnerComponent
                ],
                imports: [
                    CommonModule,
                    SharedModule
                ]
            }]
    }], null, null); })();

class SwitchComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.variant = '';
        this.labelOn = '';
        this.labelOff = '';
        this.size = '';
        this.shape = '';
        this.tabindex = '0';
        this.type = 'checkbox';
        this.value = 'on';
        this.data = {};
        this._props = {
            autofocus: false,
            checked: false,
            disabled: false,
            required: false,
        };
        this.hostTabIndex = -1;
        this.toggle = new EventEmitter();
        this.classes = {};
        this.host = this.hostElement.nativeElement;
    }
    get label() {
        return !!this.labelOn || !!this.labelOff;
    }
    set autofocus(value) {
        this._props.autofocus = typeof value === 'string' || !!value;
    }
    get autofocus() {
        return this._props.autofocus;
    }
    set checked(value) {
        this._props.checked = typeof value === 'string' || !!value;
    }
    get checked() {
        return this._props.checked;
    }
    set disabled(value) {
        this._props.disabled = typeof value === 'string' || !!value;
        this.tabindex = this._props.disabled ? -1 : this.tabindex;
    }
    get disabled() {
        return this._props.disabled;
    }
    set required(value) {
        this._props.required = typeof value === 'string' || !!value;
    }
    get required() {
        return this._props.required;
    }
    ngOnInit() {
        this.data = {
            'data-checked': this.labelOn,
            'data-unchecked': this.labelOff
        };
        this.setClasses();
    }
    setClasses() {
        const variant = this.variant ? `-${this.variant}` : '';
        this.classes['c-switch'] = true;
        this.classes['form-check-label'] = true;
        this.classes[`c-switch-${this.size}`] = !!this.size;
        this.classes[`c-switch-${this.shape}`] = !!this.shape;
        this.classes[`c-switch${variant}-${this.color}`] = !!this.color;
        this.classes['c-switch-label'] = !!this.label || typeof this.label === 'string';
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.classes[`c-switch-${changes.color.previousValue}`] = false;
        }
        if (changes.size) {
            this.classes[`c-switch-${changes.size.previousValue}`] = false;
        }
        if (changes.variant) {
            this.classes[`c-switch-variant-${changes.variant.previousValue}-alt`] = false;
            this.classes[`c-switch-variant-${changes.variant.previousValue}`] = false;
        }
        if (changes.shape) {
            this.classes[`c-switch-${changes.shape.previousValue}`] = false;
        }
        this.setClasses();
    }
    onKeyDown(e) {
        if (e.code === 'Space' && e.target === this.host.firstChild) {
            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();
        }
    }
    onKeyUp(e) {
        if (e.key === 'Enter') {
            this.toggleSwitch();
        }
    }
    onClick(e) {
        if (e.target.tagName === 'INPUT') {
            if (e instanceof MouseEvent) {
                this.toggleSwitch();
            }
        }
    }
    toggleSwitch() {
        if (this.disabled) {
            return false;
        }
        this.checked = !this.checked;
        this.toggle.emit(this);
    }
}
SwitchComponent.ɵfac = function SwitchComponent_Factory(t) { return new (t || SwitchComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SwitchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwitchComponent, selectors: [["c-switch"]], hostVars: 1, hostBindings: function SwitchComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function SwitchComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("keyup", function SwitchComponent_keyup_HostBindingHandler($event) { return ctx.onKeyUp($event); })("click", function SwitchComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.hostTabIndex);
    } }, inputs: { variant: "variant", labelOn: "labelOn", labelOff: "labelOff", size: "size", shape: "shape", tabindex: "tabindex", type: "type", value: "value", autofocus: "autofocus", checked: "checked", disabled: "disabled", required: "required", color: "color", name: "name" }, outputs: { toggle: "checked" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 12, consts: [[3, "ngClass", "tabindex"], [1, "c-switch-input", "form-check-input", 3, "tabindex", "type", "autofocus", "checked", "disabled", "required", "name", "value"], [1, "c-switch-slider"]], template: function SwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelement(1, "input", 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.classes)("tabindex", -1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("tabindex", ctx.tabindex)("type", ctx.type)("autofocus", ctx.autofocus)("checked", ctx.checked)("disabled", ctx.disabled)("required", ctx.required)("name", ctx.name ? ctx.name : "")("value", ctx.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("data-checked", ctx.labelOn)("data-unchecked", ctx.labelOff);
    } }, directives: [ɵngcc3.NgClass], styles: ["[_nghost-%COMP%]{outline:0}[_nghost-%COMP%], [_nghost-%COMP%]   .c-switch[_ngcontent-%COMP%], [_nghost-%COMP%]   .c-switch-input[_ngcontent-%COMP%], [_nghost-%COMP%]   .c-switch-slider[_ngcontent-%COMP%]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[_nghost-%COMP%]   .c-switch-label[_ngcontent-%COMP%]:focus{outline:0}.c-switch[_ngcontent-%COMP%]:focus{outline-style:auto;outline-offset:1px}.c-switch-slider[_ngcontent-%COMP%]:focus, .c-switch[_ngcontent-%COMP%]:hover{outline:none}"] });
SwitchComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
SwitchComponent.propDecorators = {
    color: [{ type: Input }],
    variant: [{ type: Input }],
    labelOn: [{ type: Input }],
    labelOff: [{ type: Input }],
    size: [{ type: Input }],
    shape: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: Input }],
    autofocus: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    hostTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    toggle: [{ type: Output, args: ['checked',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SwitchComponent, [{
        type: Component,
        args: [{
                selector: 'c-switch',
                template: "<label [ngClass]=\"classes\" [tabindex]=\"-1\">\n  <input\n    class=\"c-switch-input form-check-input\"\n    [tabindex]=\"tabindex\"\n    [type]=\"type\"\n    [autofocus]=\"autofocus\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    [required]=\"required\"\n    [name]=\"name ? name : ''\"\n    [value]=\"value\">\n  <span class=\"c-switch-slider\" attr.data-checked=\"{{labelOn}}\" attr.data-unchecked=\"{{labelOff}}\"></span>\n</label>\n",
                styles: [":host{outline:0}:host,:host .c-switch,:host .c-switch-input,:host .c-switch-slider{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host .c-switch-label:focus{outline:0}.c-switch:focus{outline-style:auto;outline-offset:1px}.c-switch-slider:focus,.c-switch:hover{outline:none}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { variant: [{
            type: Input
        }], labelOn: [{
            type: Input
        }], labelOff: [{
            type: Input
        }], size: [{
            type: Input
        }], shape: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: Input
        }], hostTabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], toggle: [{
            type: Output,
            args: ['checked']
        }], autofocus: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], required: [{
            type: Input
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onKeyUp: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();

class SwitchModule {
}
SwitchModule.ɵfac = function SwitchModule_Factory(t) { return new (t || SwitchModule)(); };
SwitchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SwitchModule });
SwitchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SwitchModule, { declarations: function () { return [SwitchComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SwitchComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SwitchComponent
                ],
                exports: [
                    SwitchComponent
                ],
                imports: [
                    CommonModule,
                ]
            }]
    }], null, null); })();

class TabsetService {
    constructor() {
        this.activeTab = new Subject();
        this.activeTab$ = this.activeTab.asObservable();
    }
    setActiveTab(tab) {
        this.activeTab.next(tab);
    }
}
TabsetService.ɵfac = function TabsetService_Factory(t) { return new (t || TabsetService)(); };
TabsetService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TabsetService, factory: TabsetService.ɵfac });
TabsetService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsetService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class TabComponent {
    constructor(renderer, tabsetService) {
        this.renderer = renderer;
        this.tabsetService = tabsetService;
        this.classMap = {};
        this._navItemClass = true;
    }
    set active(active) {
        this.classMap.active = active;
    }
    get active() {
        return this.classMap.active;
    }
    set disabled(disabled) {
        this.classMap.disabled = disabled;
    }
    get disabled() {
        return this.classMap.disabled;
    }
    onClick(e) {
        e.preventDefault();
        if (!this.disabled) {
            this.active = true;
            this.tabsetService.setActiveTab(this);
        }
    }
    ngOnInit() {
        this.classMap = {
            'nav-link': true,
            active: this.active,
            disabled: this.disabled
        };
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    ngAfterViewInit() {
        this.activeTabSubscribe();
    }
    ngOnChanges(changes) {
        this.classMap = {
            active: changes.active ? changes.active.currentValue : this.active,
            disabled: changes.disabled ? changes.disabled.currentValue : this.disabled
        };
        this.classMap = Object.assign(Object.create(null), this.classMap);
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
            this.active = this.indexKey === activeTab.indexKey;
            this.classMap.active = this.indexKey === activeTab.indexKey;
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabComponent.ɵfac = function TabComponent_Factory(t) { return new (t || TabComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TabsetService)); };
TabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabComponent, selectors: [["c-tab"]], viewQuery: function TabComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c16, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._link = _t.first);
    } }, hostVars: 2, hostBindings: function TabComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function TabComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav-item", ctx._navItemClass);
    } }, inputs: { active: "active", disabled: "disabled" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["href", "", 3, "ngClass", "tabindex"], ["link", ""]], template: function TabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("tabindex", ctx.disabled ? -1 : 0);
        ɵngcc0.ɵɵproperty("ngClass", ctx.classMap);
    } }, directives: [ɵngcc3.NgClass], styles: ["[_nghost-%COMP%]   .nav-link[_ngcontent-%COMP%]:focus{outline:none!important}"] });
TabComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: TabsetService }
];
TabComponent.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    _navItemClass: [{ type: HostBinding, args: ['class.nav-item',] }],
    _link: [{ type: ViewChild, args: ['link', { static: true },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabComponent, [{
        type: Component,
        args: [{
                selector: 'c-tab',
                template: "<!--<a #link href=\"javascript:void(0);\" [ngClass]=\"classMap\" (click)=\"onClick($event)\" tabindex=\"{{disabled ? -1 : 0}}\">-->\n<a #link href [ngClass]=\"classMap\" tabindex=\"{{disabled ? -1 : 0}}\">\n  <ng-content></ng-content>\n</a>\n",
                styles: [":host .nav-link:focus{outline:none!important}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: TabsetService }]; }, { _navItemClass: [{
            type: HostBinding,
            args: ['class.nav-item']
        }], active: [{
            type: Input
        }], disabled: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], _link: [{
            type: ViewChild,
            args: ['link', { static: true }]
        }] }); })();

class TabPaneComponent {
    constructor(tabsetService) {
        this.tabsetService = tabsetService;
        this.fade = true;
        this._tabPane = true;
        this._tabActive = true;
        this._tabShow = false;
        this._tabFade = this.fade;
    }
    set active(active) {
        this._tabActive = active;
        this._tabShow = active;
    }
    get active() {
        return this._tabActive;
    }
    ngOnInit() {
        this.activeTabSubscribe();
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
            setTimeout(() => {
                this.active = activeTab.indexKey === this.indexKey;
            });
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabPaneComponent.ɵfac = function TabPaneComponent_Factory(t) { return new (t || TabPaneComponent)(ɵngcc0.ɵɵdirectiveInject(TabsetService)); };
TabPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabPaneComponent, selectors: [["c-tab-pane"]], hostVars: 8, hostBindings: function TabPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("tab-pane", ctx._tabPane)("active", ctx._tabActive)("show", ctx._tabShow)("fade", ctx._tabFade);
    } }, inputs: { active: "active" }, ngContentSelectors: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function TabPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TabPaneComponent_ng_content_0_Template, 1, 0, "ng-content", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.active);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
TabPaneComponent.ctorParameters = () => [
    { type: TabsetService }
];
TabPaneComponent.propDecorators = {
    active: [{ type: Input }],
    _tabPane: [{ type: HostBinding, args: ['class.tab-pane',] }],
    _tabActive: [{ type: HostBinding, args: ['class.active',] }],
    _tabShow: [{ type: HostBinding, args: ['class.show',] }],
    _tabFade: [{ type: HostBinding, args: ['class.fade',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabPaneComponent, [{
        type: Component,
        args: [{
                selector: 'c-tab-pane',
                template: "<ng-content *ngIf=\"active\"></ng-content>\n\n",
                styles: [""]
            }]
    }], function () { return [{ type: TabsetService }]; }, { _tabPane: [{
            type: HostBinding,
            args: ['class.tab-pane']
        }], _tabActive: [{
            type: HostBinding,
            args: ['class.active']
        }], _tabShow: [{
            type: HostBinding,
            args: ['class.show']
        }], _tabFade: [{
            type: HostBinding,
            args: ['class.fade']
        }], active: [{
            type: Input
        }] }); })();

class TabListComponent {
    constructor() {
        this._navClass = true;
    }
    set variant(variant) {
        this._navTabsClass = variant !== 'pills';
        this._navPillsClass = variant === 'pills';
    }
    set vertical(vertical) {
        this._navFlexColumn = !!vertical;
        this._navH100 = !!vertical;
    }
    set fill(fill) {
        this._navFill = !!fill;
    }
    set justified(justified) {
        this._navJustified = !!justified;
    }
}
TabListComponent.ɵfac = function TabListComponent_Factory(t) { return new (t || TabListComponent)(); };
TabListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabListComponent, selectors: [["c-tablist"]], hostVars: 14, hostBindings: function TabListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav", ctx._navClass)("nav-tabs", ctx._navTabsClass)("nav-pills", ctx._navPillsClass)("flex-column", ctx._navFlexColumn)("h-100", ctx._navH100)("nav-fill", ctx._navFill)("nav-justified", ctx._navJustified);
    } }, inputs: { variant: "variant", vertical: "vertical", fill: "fill", justified: "justified" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function TabListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
TabListComponent.ctorParameters = () => [];
TabListComponent.propDecorators = {
    variant: [{ type: Input }],
    vertical: [{ type: Input }],
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    _navClass: [{ type: HostBinding, args: ['class.nav',] }],
    _navTabsClass: [{ type: HostBinding, args: ['class.nav-tabs',] }],
    _navPillsClass: [{ type: HostBinding, args: ['class.nav-pills',] }],
    _navFill: [{ type: HostBinding, args: ['class.nav-fill',] }],
    _navJustified: [{ type: HostBinding, args: ['class.nav-justified',] }],
    _navFlexColumn: [{ type: HostBinding, args: ['class.flex-column',] }],
    _navH100: [{ type: HostBinding, args: ['class.h-100',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabListComponent, [{
        type: Component,
        args: [{
                selector: 'c-tablist',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            }]
    }], function () { return []; }, { _navClass: [{
            type: HostBinding,
            args: ['class.nav']
        }], variant: [{
            type: Input
        }], _navTabsClass: [{
            type: HostBinding,
            args: ['class.nav-tabs']
        }], _navPillsClass: [{
            type: HostBinding,
            args: ['class.nav-pills']
        }], vertical: [{
            type: Input
        }], _navFlexColumn: [{
            type: HostBinding,
            args: ['class.flex-column']
        }], _navH100: [{
            type: HostBinding,
            args: ['class.h-100']
        }], fill: [{
            type: Input
        }], _navFill: [{
            type: HostBinding,
            args: ['class.nav-fill']
        }], justified: [{
            type: Input
        }], _navJustified: [{
            type: HostBinding,
            args: ['class.nav-justified']
        }] }); })();

class TabsetComponent {
    constructor(hostElement, renderer, tabsetService) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.tabsetService = tabsetService;
        this._activeTab = 0;
        this._tabsArray = [];
        this.variant = 'tabs';
        this.fade = true;
        this.boxed = false;
        this.activeTabChange = new EventEmitter();
        this.host = this.hostElement.nativeElement;
    }
    set activeTab(index) {
        this._activeTab = index >= 0 ? index : this._activeTab;
    }
    get activeTab() {
        return this._activeTab;
    }
    ngOnInit() {
        if (typeof this.boxed === 'string') {
            this.renderer.addClass(this.host, `nav-tabs-boxed-${this.boxed}`);
        }
        this.activeTabSubscribe();
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    ngAfterContentInit() {
        this.tabList.variant = this.variant;
        this.tabList.vertical = this.vertical;
        this.tabList.fill = this.fill;
        this.tabList.justified = this.justified;
        this._tabsArray = this.tabs.toArray();
        if (this.tabs.length) {
            this._selectedTab = this.tabs.length - 1 < this.activeTab ? this.tabs.first : this._tabsArray[this.activeTab];
        }
        this.tabs.forEach((item, index) => {
            item.indexKey = index;
        });
        this.panes.forEach((item, index) => {
            item.indexKey = index;
        });
        this.tabsetService.setActiveTab(this._selectedTab);
        this.setActiveTab(this._selectedTab);
    }
    ngAfterContentChecked() {
    }
    ngOnChanges(changes) {
    }
    setActiveTab(tab = this._selectedTab) {
        this.activeTab = tab.indexKey;
        if (!tab.disabled) {
            tab.active = true;
            this.tabsetService.setActiveTab(tab);
            this.activeTabChange.emit(this.activeTab);
        }
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabsetComponent.ɵfac = function TabsetComponent_Factory(t) { return new (t || TabsetComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TabsetService)); };
TabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabsetComponent, selectors: [["c-tabset"]], contentQueries: function TabsetComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabListComponent, 3);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabPaneComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 2, hostBindings: function TabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nav-tabs-boxed", ctx.boxed);
    } }, inputs: { variant: "variant", fade: "fade", boxed: "boxed", activeTab: "activeTab", fill: "fill", justified: "justified", vertical: "vertical" }, outputs: { activeTabChange: "activeTabChange" }, features: [ɵngcc0.ɵɵProvidersFeature([TabsetService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function TabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""] });
TabsetComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: TabsetService }
];
TabsetComponent.propDecorators = {
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    variant: [{ type: Input }],
    fade: [{ type: Input }],
    vertical: [{ type: Input }],
    activeTab: [{ type: Input }],
    boxed: [{ type: HostBinding, args: ['class.nav-tabs-boxed',] }, { type: Input }],
    activeTabChange: [{ type: Output }],
    tabList: [{ type: ContentChild, args: [TabListComponent, { static: true },] }],
    tabs: [{ type: ContentChildren, args: [TabComponent, { descendants: true },] }],
    panes: [{ type: ContentChildren, args: [TabPaneComponent, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsetComponent, [{
        type: Component,
        args: [{
                selector: 'c-tabset',
                template: "<ng-content></ng-content>\n",
                providers: [TabsetService],
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: TabsetService }]; }, { variant: [{
            type: Input
        }], fade: [{
            type: Input
        }], boxed: [{
            type: HostBinding,
            args: ['class.nav-tabs-boxed']
        }, {
            type: Input
        }], activeTabChange: [{
            type: Output
        }], activeTab: [{
            type: Input
        }], fill: [{
            type: Input
        }], justified: [{
            type: Input
        }], vertical: [{
            type: Input
        }], tabList: [{
            type: ContentChild,
            args: [TabListComponent, { static: true }]
        }], tabs: [{
            type: ContentChildren,
            args: [TabComponent, { descendants: true }]
        }], panes: [{
            type: ContentChildren,
            args: [TabPaneComponent, { descendants: true }]
        }] }); })();

class TabContentComponent {
    constructor() {
        this._hasPanes = false;
        this._tabContent = true;
    }
    set hasPanes(hasPanes) {
        this._hasPanes = hasPanes;
    }
    get hasPanes() {
        return this._hasPanes ? null : true;
    }
    ngOnInit() {
    }
    ngAfterContentChecked() {
        this.hasPanes = this.panes.length > 0;
    }
}
TabContentComponent.ɵfac = function TabContentComponent_Factory(t) { return new (t || TabContentComponent)(); };
TabContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabContentComponent, selectors: [["c-tab-content"]], contentQueries: function TabContentComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabPaneComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 3, hostBindings: function TabContentComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("hidden", ctx.hasPanes);
        ɵngcc0.ɵɵclassProp("tab-content", ctx._tabContent);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function TabContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
TabContentComponent.ctorParameters = () => [];
TabContentComponent.propDecorators = {
    _tabContent: [{ type: HostBinding, args: ['class.tab-content',] }],
    hasPanes: [{ type: HostBinding, args: ['attr.hidden',] }],
    panes: [{ type: ContentChildren, args: [TabPaneComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabContentComponent, [{
        type: Component,
        args: [{
                selector: 'c-tab-content',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:block}"]
            }]
    }], function () { return []; }, { _tabContent: [{
            type: HostBinding,
            args: ['class.tab-content']
        }], hasPanes: [{
            type: HostBinding,
            args: ['attr.hidden']
        }], panes: [{
            type: ContentChildren,
            args: [TabPaneComponent]
        }] }); })();

class TabsetModule {
}
TabsetModule.ɵfac = function TabsetModule_Factory(t) { return new (t || TabsetModule)(); };
TabsetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabsetModule });
TabsetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        TabsetService
    ], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsetModule, { declarations: function () { return [TabsetComponent, TabListComponent, TabComponent, TabContentComponent, TabPaneComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TabsetComponent, TabListComponent, TabComponent, TabContentComponent, TabPaneComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsetModule, [{
        type: NgModule,
        args: [{
                declarations: [TabsetComponent, TabListComponent, TabComponent, TabContentComponent, TabPaneComponent],
                exports: [
                    TabsetComponent,
                    TabListComponent,
                    TabComponent,
                    TabContentComponent,
                    TabPaneComponent,
                ],
                imports: [
                    CommonModule
                ],
                providers: [
                    TabsetService
                ]
            }]
    }], null, null); })();

const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextMaskDirective),
    multi: true
};
class TextMaskDirective {
    constructor(platform, _renderer, _elementRef, _compositionMode) {
        this.platform = platform;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !platform.ANDROID;
        }
    }
    ngOnChanges(changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() { this._composing = true; }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
TextMaskDirective.ɵfac = function TextMaskDirective_Factory(t) { return new (t || TextMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc7.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8)); };
TextMaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextMaskDirective, selectors: [["", "textMask", ""]], hostBindings: function TextMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function TextMaskDirective_input_HostBindingHandler($event) { return ctx._handleInput($event.target.value); })("blur", function TextMaskDirective_blur_HostBindingHandler() { return ctx.onTouched(); })("compositionstart", function TextMaskDirective_compositionstart_HostBindingHandler() { return ctx._compositionStart(); })("compositionend", function TextMaskDirective_compositionend_HostBindingHandler($event) { return ctx._compositionEnd($event.target.value); });
    } }, inputs: { textMaskConfig: ["textMask", "textMaskConfig"] }, exportAs: ["textMask"], features: [ɵngcc0.ɵɵProvidersFeature([MASKEDINPUT_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature] });
TextMaskDirective.ctorParameters = () => [
    { type: Platform },
    { type: Renderer2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
TextMaskDirective.propDecorators = {
    textMaskConfig: [{ type: Input, args: ['textMask',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextMaskDirective, [{
        type: Directive,
        args: [{
                host: {
                    '(input)': '_handleInput($event.target.value)',
                    '(blur)': 'onTouched()',
                    '(compositionstart)': '_compositionStart()',
                    '(compositionend)': '_compositionEnd($event.target.value)'
                },
                selector: '[textMask]',
                exportAs: 'textMask',
                providers: [MASKEDINPUT_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ɵngcc7.Platform }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [COMPOSITION_BUFFER_MODE]
            }] }]; }, { textMaskConfig: [{
            type: Input,
            args: ['textMask']
        }] }); })();

class TextMaskConfig {
}

class TextMaskModule {
    static forRoot() {
        return {
            ngModule: TextMaskModule
        };
    }
}
TextMaskModule.ɵfac = function TextMaskModule_Factory(t) { return new (t || TextMaskModule)(); };
TextMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TextMaskModule });
TextMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextMaskModule, { declarations: function () { return [TextMaskDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TextMaskDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TextMaskModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    TextMaskDirective
                ],
                exports: [
                    TextMaskDirective
                ]
            }]
    }], null, null); })();

class ToasterService {
    constructor() {
        this.toasterState = new BehaviorSubject({});
        this.toasterState$ = this.toasterState.asObservable();
    }
    setState(state) {
        this.toasterState.next(state);
    }
}
ToasterService.ɵfac = function ToasterService_Factory(t) { return new (t || ToasterService)(); };
ToasterService.ɵprov = ɵɵdefineInjectable({ factory: function ToasterService_Factory() { return new ToasterService(); }, token: ToasterService, providedIn: "root" });
ToasterService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToasterService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class ToastComponent {
    constructor(hostElement, renderer, ref, toasterService) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ref = ref;
        this.toasterService = toasterService;
        this.autohide = true;
        this.delay = 5000;
        this.fade = true;
        this.shown = new EventEmitter();
        this.hidden = new EventEmitter();
        this.timer = new EventEmitter();
    }
    set clock(value) {
        this._clock = value;
        this.timer.emit(this._clock);
    }
    get clock() {
        return this._clock;
    }
    get animationDisabled() {
        return !this.fade;
    }
    get animateType() {
        return this.show ? 'show' : 'hide';
    }
    onMouseOver() {
        this.clearTimer();
        this.clearClock();
    }
    onMouseOut() {
        this.setTimer();
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            toast: true,
            [`toast-${this.color}`]: !!this.color,
        });
        return classes;
    }
    ngOnInit() {
        if (this.show) {
            this.toasterService.setState({ toast: this, show: this.show, position: this.position });
            this.setTimer();
        }
        this.stateToasterSubscribe(true);
    }
    ngOnDestroy() {
        this.clearTimer();
        this.clearClock();
        this.stateToasterSubscribe(false);
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.hostElement.nativeElement, `toast-${changes.color.previousValue}`);
        }
        if (changes.show) {
            this.toasterService.setState({ toast: this, show: this.show, position: this.position });
        }
    }
    setTimer() {
        this.clearTimer();
        if (this.autohide) {
            this.timerId = this.delay > 0 ? setTimeout(() => this.onClose(), this.delay) : null;
            this.setClock();
        }
    }
    clearTimer() {
        clearTimeout(this.timerId);
        this.timerId = null;
    }
    onClose() {
        this.clearTimer();
        this.show = false;
        this.hidden.emit();
        this.toasterService.setState({ toast: this, show: this.show, position: this.position });
    }
    setClock() {
        this.clearClock();
        this.clock = 0;
        this.clockId = setInterval(() => {
            this.clock += 1;
        }, 1000);
        this.clockTimerId = setTimeout(() => {
            this.clearClock();
        }, this.delay);
    }
    clearClock() {
        clearTimeout(this.clockTimerId);
        clearInterval(this.clockId);
        this.clockId = null;
    }
    stateToasterSubscribe(subscribe = true) {
        if (subscribe) {
            const filtered = this.toasterService.toasterState$.pipe(filter(state => state.toast === this));
            this.stateToasterSubscription = filtered.subscribe((state) => {
                this.state = state.toast;
            });
        }
        else {
            this.stateToasterSubscription.unsubscribe();
        }
    }
}
ToastComponent.ɵfac = function ToastComponent_Factory(t) { return new (t || ToastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ToasterService)); };
ToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToastComponent, selectors: [["c-toast"]], hostVars: 4, hostBindings: function ToastComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseover", function ToastComponent_mouseover_HostBindingHandler() { return ctx.onMouseOver(); })("mouseout", function ToastComponent_mouseout_HostBindingHandler() { return ctx.onMouseOut(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@.disabled", ctx.animationDisabled)("@fadeInOut", ctx.animateType);
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { autohide: "autohide", delay: "delay", fade: "fade", show: "show", color: "color", index: "index" }, outputs: { shown: "shown", hidden: "hidden", timer: "timer" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ToastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: [""], data: { animation: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1 })),
                state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => *', [
                    animate('{{ time }} {{ easing }}', style({ opacity: 0 })),
                    animate('{{ time }} {{ easing }}', style({ height: 0, padding: 0, border: 0, margin: 0 })),
                ], {
                    params: { time: '300ms', easing: 'ease-out' }
                }),
                transition('* => show', [
                    animate('{{ time }} {{ easing }}', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                ], {
                    params: { time: '300ms', easing: 'ease-in' }
                })
            ])
        ] } });
ToastComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: ToasterService }
];
ToastComponent.propDecorators = {
    autohide: [{ type: Input }],
    color: [{ type: Input }],
    delay: [{ type: Input }],
    fade: [{ type: Input }],
    show: [{ type: Input }],
    index: [{ type: Input }],
    shown: [{ type: Output }],
    hidden: [{ type: Output }],
    timer: [{ type: Output }],
    animationDisabled: [{ type: HostBinding, args: ['@.disabled',] }],
    animateType: [{ type: HostBinding, args: ['@fadeInOut',] }],
    onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
    onMouseOut: [{ type: HostListener, args: ['mouseout',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastComponent, [{
        type: Component,
        args: [{
                selector: 'c-toast',
                template: "<ng-content></ng-content>\n",
                animations: [
                    trigger('fadeInOut', [
                        state('show', style({ opacity: 1 })),
                        state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        transition('show => *', [
                            animate('{{ time }} {{ easing }}', style({ opacity: 0 })),
                            animate('{{ time }} {{ easing }}', style({ height: 0, padding: 0, border: 0, margin: 0 })),
                        ], {
                            params: { time: '300ms', easing: 'ease-out' }
                        }),
                        transition('* => show', [
                            animate('{{ time }} {{ easing }}', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                        ], {
                            params: { time: '300ms', easing: 'ease-in' }
                        })
                    ])
                ],
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ToasterService }]; }, { autohide: [{
            type: Input
        }], delay: [{
            type: Input
        }], fade: [{
            type: Input
        }], shown: [{
            type: Output
        }], hidden: [{
            type: Output
        }], timer: [{
            type: Output
        }], animationDisabled: [{
            type: HostBinding,
            args: ['@.disabled']
        }], animateType: [{
            type: HostBinding,
            args: ['@fadeInOut']
        }], onMouseOver: [{
            type: HostListener,
            args: ['mouseover']
        }], onMouseOut: [{
            type: HostListener,
            args: ['mouseout']
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], show: [{
            type: Input
        }], color: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();

class ToastHeaderComponent {
    constructor(toast) {
        this.toast = toast;
        this.closeButton = true;
        this.toastHeaderClass = true;
    }
}
ToastHeaderComponent.ɵfac = function ToastHeaderComponent_Factory(t) { return new (t || ToastHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(ToastComponent, 8)); };
ToastHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToastHeaderComponent, selectors: [["c-toast-header"]], hostVars: 2, hostBindings: function ToastHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("toast-header", ctx.toastHeaderClass);
    } }, inputs: { closeButton: "closeButton" }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [["class", "close mfs-auto", "aria-label", "close", 3, "style", "cToastClose", 4, "ngIf"], ["aria-label", "close", 1, "close", "mfs-auto", 3, "cToastClose"]], template: function ToastHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, ToastHeaderComponent_button_2_Template, 2, 4, "button", 0);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.closeButton);
    } }, directives: function () { return [ɵngcc3.NgIf, ToastCloseDirective]; }, styles: [""] });
ToastHeaderComponent.ctorParameters = () => [
    { type: ToastComponent, decorators: [{ type: Optional }] }
];
ToastHeaderComponent.propDecorators = {
    closeButton: [{ type: Input }],
    toastHeaderClass: [{ type: HostBinding, args: ['class.toast-header',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'c-toast-header',
                template: "<ng-container>\r\n  <ng-content></ng-content>\r\n  <button *ngIf=\"closeButton\" class=\"close mfs-auto\" aria-label=\"close\" [style]=\"{outline: 0}\" [cToastClose]=\"toast\">\u00D7</button>\r\n</ng-container>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: ToastComponent, decorators: [{
                type: Optional
            }] }]; }, { closeButton: [{
            type: Input
        }], toastHeaderClass: [{
            type: HostBinding,
            args: ['class.toast-header']
        }] }); })();

class ToastBodyComponent {
    constructor(toast) {
        this.toast = toast;
        this.toastBodyClass = true;
    }
    ngOnInit() {
    }
}
ToastBodyComponent.ɵfac = function ToastBodyComponent_Factory(t) { return new (t || ToastBodyComponent)(ɵngcc0.ɵɵdirectiveInject(ToastComponent, 8)); };
ToastBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToastBodyComponent, selectors: [["c-toast-body"]], hostVars: 2, hostBindings: function ToastBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("toast-body", ctx.toastBodyClass);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ToastBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:block}"] });
ToastBodyComponent.ctorParameters = () => [
    { type: ToastComponent, decorators: [{ type: Optional }] }
];
ToastBodyComponent.propDecorators = {
    toastBodyClass: [{ type: HostBinding, args: ['class.toast-body',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastBodyComponent, [{
        type: Component,
        args: [{
                selector: 'c-toast-body',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:block}"]
            }]
    }], function () { return [{ type: ToastComponent, decorators: [{
                type: Optional
            }] }]; }, { toastBodyClass: [{
            type: HostBinding,
            args: ['class.toast-body']
        }] }); })();

class ToasterHostDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
ToasterHostDirective.ɵfac = function ToasterHostDirective_Factory(t) { return new (t || ToasterHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ToasterHostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToasterHostDirective, selectors: [["", "cToasterHost", ""]], exportAs: ["cToasterHost"] });
ToasterHostDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToasterHostDirective, [{
        type: Directive,
        args: [{
                selector: '[cToasterHost]',
                exportAs: 'cToasterHost'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();

var ToasterPosition;
(function (ToasterPosition) {
    ToasterPosition["Static"] = "static";
    ToasterPosition["TopCenter"] = "top-center";
    ToasterPosition["TopFull"] = "top-full";
    ToasterPosition["TopLeft"] = "top-left";
    ToasterPosition["TopRight"] = "top-right";
    ToasterPosition["BottomCenter"] = "bottom-center";
    ToasterPosition["BottomFull"] = "bottom-full";
    ToasterPosition["BottomLeft"] = "bottom-left";
    ToasterPosition["BottomRight"] = "bottom-right";
})(ToasterPosition || (ToasterPosition = {}));
class ToasterComponent {
    constructor(componentFactoryResolver, hostElement, renderer, toasterService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.toasterService = toasterService;
        this.positions = Object.values(ToasterPosition);
        this.toastsDynamic = [];
        this.position = ToasterPosition.TopRight;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            toaster: true,
            [`toaster-${this.position}`]: this.position !== 'static' && !!this.position
        });
        return classes;
    }
    ngOnInit() {
        this.stateToasterSubscribe(true);
    }
    ngOnDestroy() {
        this.stateToasterSubscribe(false);
    }
    ngAfterContentChecked() {
        this.toasts = this.contentToasts;
    }
    stateToasterSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToasterSubscription = this.toasterService.toasterState$.subscribe((state) => {
                var _a;
                if (state.show === false) {
                    this.removeToast(state);
                }
                if (state.show === true && ((_a = state.toast) === null || _a === void 0 ? void 0 : _a.dynamic) === undefined) { }
            });
        }
        else {
            this.stateToasterSubscription.unsubscribe();
        }
    }
    addToast(toast, options) {
        const factory = this.componentFactoryResolver.resolveComponentFactory(toast);
        const componentRef = this.toasterHost.viewContainerRef.createComponent(factory);
        this.toastsDynamic.push(componentRef);
        const index = this.toastsDynamic.indexOf(componentRef);
        for (const [key, value] of Object.entries(options)) {
            componentRef.instance[key] = value;
        }
        componentRef.instance['position'] = this.position;
        componentRef.instance['dynamic'] = true;
        componentRef.instance['index'] = index;
        componentRef.instance['show'] = true;
        componentRef.changeDetectorRef.detectChanges();
        return componentRef;
    }
    removeToast(state) {
        var _a, _b;
        (_a = this.toastsDynamic) === null || _a === void 0 ? void 0 : _a.forEach(item => {
            if (state.toast.dynamic && (item.instance === state.toast)) {
                item.destroy();
            }
        });
        (_b = this.toasts) === null || _b === void 0 ? void 0 : _b.forEach(item => {
            if (item.element.nativeElement === state.toast.hostElement.nativeElement) {
                state.toast.show = false;
                setTimeout(() => {
                    item.element.nativeElement.remove();
                }, 300);
            }
        });
    }
}
ToasterComponent.ɵfac = function ToasterComponent_Factory(t) { return new (t || ToasterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ToasterService)); };
ToasterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToasterComponent, selectors: [["c-toaster"]], contentQueries: function ToasterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ToastComponent, 0, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentToasts = _t);
    } }, viewQuery: function ToasterComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ToasterHostDirective, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toasterHost = _t.first);
    } }, hostVars: 2, hostBindings: function ToasterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { position: "position" }, ngContentSelectors: _c0, decls: 2, vars: 0, consts: [["cToasterHost", ""]], template: function ToasterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ToasterComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
        ɵngcc0.ɵɵprojection(1, 0, ["cToasterHost", ""]);
    } }, directives: [ToasterHostDirective], styles: [""] });
ToasterComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ToasterService }
];
ToasterComponent.propDecorators = {
    position: [{ type: Input }],
    toasterHost: [{ type: ViewChild, args: [ToasterHostDirective, { static: true },] }],
    contentToasts: [{ type: ContentChildren, args: [ToastComponent, { read: ViewContainerRef },] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToasterComponent, [{
        type: Component,
        args: [{
                selector: 'c-toaster',
                template: "<ng-template cToasterHost></ng-template>\n<ng-content cToasterHost></ng-content>\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ToasterService }]; }, { position: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], toasterHost: [{
            type: ViewChild,
            args: [ToasterHostDirective, { static: true }]
        }], contentToasts: [{
            type: ContentChildren,
            args: [ToastComponent, { read: ViewContainerRef }]
        }] }); })();

class ToastCloseDirective {
    constructor(toasterService) {
        this.toasterService = toasterService;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.toasterService.setState({ show: false, toast: this.toast });
    }
}
ToastCloseDirective.ɵfac = function ToastCloseDirective_Factory(t) { return new (t || ToastCloseDirective)(ɵngcc0.ɵɵdirectiveInject(ToasterService)); };
ToastCloseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToastCloseDirective, selectors: [["", "cToastClose", ""]], hostBindings: function ToastCloseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ToastCloseDirective_click_HostBindingHandler($event) { return ctx.toggleOpen($event); });
    } }, inputs: { toast: ["cToastClose", "toast"] }, exportAs: ["cToastClose"] });
ToastCloseDirective.ctorParameters = () => [
    { type: ToasterService }
];
ToastCloseDirective.propDecorators = {
    toast: [{ type: Input, args: ['cToastClose',] }],
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastCloseDirective, [{
        type: Directive,
        args: [{
                selector: '[cToastClose]',
                exportAs: 'cToastClose'
            }]
    }], function () { return [{ type: ToasterService }]; }, { toggleOpen: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], toast: [{
            type: Input,
            args: ['cToastClose']
        }] }); })();

class ToastModule {
}
ToastModule.ɵfac = function ToastModule_Factory(t) { return new (t || ToastModule)(); };
ToastModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ToastModule });
ToastModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [ToasterService], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ToastModule, { declarations: function () { return [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastModule, [{
        type: NgModule,
        args: [{
                declarations: [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective],
                imports: [
                    CommonModule
                ],
                providers: [ToasterService],
                exports: [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective]
            }]
    }], null, null); })();

class TogglerComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.displayFlex = true;
        this.hasContent = true;
    }
    get buttonClass() {
        if (this.inHeader) {
            return 'c-header-toggler';
        }
        else if (this.inNavbar) {
            return 'navbar-toggler';
        }
    }
    get iconClass() {
        if (this.inHeader) {
            return 'c-header-toggler-icon';
        }
        else if (this.inNavbar) {
            return 'navbar-toggler-icon';
        }
    }
    ngAfterViewInit() {
        this.hasContent = this.content.nativeElement.childNodes.length;
        this.changeDetector.detectChanges();
    }
}
TogglerComponent.ɵfac = function TogglerComponent_Factory(t) { return new (t || TogglerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TogglerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TogglerComponent, selectors: [["c-toggler"]], viewQuery: function TogglerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c7, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, hostVars: 2, hostBindings: function TogglerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("d-flex", ctx.displayFlex);
    } }, inputs: { inHeader: "inHeader", inNavbar: "inNavbar" }, ngContentSelectors: _c0, decls: 3, vars: 2, consts: [["class", "d-flex", 4, "ngIf", "ngIfElse"], ["default", ""], [1, "d-flex"], ["content", ""], ["type", "button"]], template: function TogglerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TogglerComponent_div_0_Template, 3, 0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, TogglerComponent_ng_template_1_Template, 2, 4, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasContent)("ngIfElse", _r1);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
TogglerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
TogglerComponent.propDecorators = {
    inHeader: [{ type: Input }],
    inNavbar: [{ type: Input }],
    displayFlex: [{ type: HostBinding, args: ['class.d-flex',] }],
    content: [{ type: ViewChild, args: ['content',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TogglerComponent, [{
        type: Component,
        args: [{
                selector: 'c-toggler',
                template: "<div #content *ngIf = \"hasContent; else default\" class=\"d-flex\"><ng-content></ng-content></div>\n<ng-template #default>\n  <button [class]=\"buttonClass\" type=\"button\">\n    <span [class]=\"iconClass\"></span>\n  </button>\n</ng-template>\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { displayFlex: [{
            type: HostBinding,
            args: ['class.d-flex']
        }], inHeader: [{
            type: Input
        }], inNavbar: [{
            type: Input
        }], content: [{
            type: ViewChild,
            args: ['content']
        }] }); })();

class TogglerModule {
}
TogglerModule.ɵfac = function TogglerModule_Factory(t) { return new (t || TogglerModule)(); };
TogglerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TogglerModule });
TogglerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TogglerModule, { declarations: function () { return [TogglerComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TogglerComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TogglerModule, [{
        type: NgModule,
        args: [{
                declarations: [TogglerComponent],
                exports: [
                    TogglerComponent
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

class WidgetSimpleComponent {
    constructor() { }
    ngOnInit() { }
}
WidgetSimpleComponent.ɵfac = function WidgetSimpleComponent_Factory(t) { return new (t || WidgetSimpleComponent)(); };
WidgetSimpleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetSimpleComponent, selectors: [["c-widget-simple"]], inputs: { header: "header", text: "text" }, ngContentSelectors: _c0, decls: 5, vars: 2, consts: [[1, "card"], [1, "card-body", "text-center"], ["class", "text-muted small text-uppercase font-weight-bold", 4, "ngIf"], ["class", "h2 py-3", 4, "ngIf"], [1, "text-muted", "small", "text-uppercase", "font-weight-bold"], [1, "h2", "py-3"]], template: function WidgetSimpleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, WidgetSimpleComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵtemplate(3, WidgetSimpleComponent_div_3_Template, 2, 1, "div", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.text);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
WidgetSimpleComponent.ctorParameters = () => [];
WidgetSimpleComponent.propDecorators = {
    header: [{ type: Input }],
    text: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetSimpleComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-simple',
                template: "<div class=\"card\">\n  <div class=\"card-body text-center\">\n    <div *ngIf=\"!!header\" class=\"text-muted small text-uppercase font-weight-bold\">\n      {{header}}\n    </div>\n    <div *ngIf=\"!!text\" class=\"h2 py-3\">\n      {{text}}\n    </div>\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                styles: [""]
            }]
    }], function () { return []; }, { header: [{
            type: Input
        }], text: [{
            type: Input
        }] }); })();

class WidgetBrandComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
        });
        return classes;
    }
    ngOnInit() {
    }
    get headerClasses() {
        const classes = classNames({
            'card-header': true,
            'content-center': true,
            'text-white': true,
            'p-0': true,
            [`bg-${this.color}`]: !!this.color,
        }, this.addHeaderClasses);
        return classes;
    }
}
WidgetBrandComponent.ɵfac = function WidgetBrandComponent_Factory(t) { return new (t || WidgetBrandComponent)(); };
WidgetBrandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetBrandComponent, selectors: [["c-widget-brand"]], hostVars: 2, hostBindings: function WidgetBrandComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { color: "color", rightHeader: "rightHeader", leftHeader: "leftHeader", rightFooter: "rightFooter", leftFooter: "leftFooter", addHeaderClasses: "addHeaderClasses" }, ngContentSelectors: _c0, decls: 11, vars: 6, consts: [[1, "card-body", "row", "text-center"], [1, "col"], ["class", "text-value-lg", 4, "ngIf"], ["class", "text-uppercase text-muted small", 4, "ngIf"], [1, "c-vr"], [1, "text-value-lg"], [1, "text-uppercase", "text-muted", "small"]], template: function WidgetBrandComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵelementStart(1, "div");
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 0);
        ɵngcc0.ɵɵelementStart(4, "div", 1);
        ɵngcc0.ɵɵtemplate(5, WidgetBrandComponent_div_5_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵtemplate(6, WidgetBrandComponent_div_6_Template, 2, 1, "div", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "div", 4);
        ɵngcc0.ɵɵelementStart(8, "div", 1);
        ɵngcc0.ɵɵtemplate(9, WidgetBrandComponent_div_9_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵtemplate(10, WidgetBrandComponent_div_10_Template, 2, 1, "div", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ctx.headerClasses);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.rightHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.rightFooter);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.leftHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.leftFooter);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
WidgetBrandComponent.ctorParameters = () => [];
WidgetBrandComponent.propDecorators = {
    color: [{ type: Input }],
    rightHeader: [{ type: Input }],
    leftHeader: [{ type: Input }],
    rightFooter: [{ type: Input }],
    leftFooter: [{ type: Input }],
    addHeaderClasses: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetBrandComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-brand',
                template: "<ng-container>\n  <div [class]=\"headerClasses\">\n    <ng-content></ng-content>\n  </div>\n  <!--todo: <ng-content select=\"[slot=body]\"></ng-content>-->\n  <div class=\"card-body row text-center\">\n    <div class=\"col\">\n      <div *ngIf=\"!!rightHeader\" class=\"text-value-lg\">{{rightHeader}}</div>\n      <div *ngIf=\"!!rightFooter\" class=\"text-uppercase text-muted small\">{{rightFooter}}</div>\n    </div>\n    <div class=\"c-vr\"></div>\n    <div class=\"col\">\n      <div *ngIf=\"!!leftHeader\" class=\"text-value-lg\">{{leftHeader}}</div>\n      <div *ngIf=\"!!leftFooter\" class=\"text-uppercase text-muted small\">{{leftFooter}}</div>\n    </div>\n  </div>\n</ng-container>\n",
                styles: [""]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }], rightHeader: [{
            type: Input
        }], leftHeader: [{
            type: Input
        }], rightFooter: [{
            type: Input
        }], leftFooter: [{
            type: Input
        }], addHeaderClasses: [{
            type: Input
        }] }); })();

class WidgetIconComponent {
    constructor() {
        this.iconPadding = true;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
        });
        return classes;
    }
    ngOnInit() {
    }
    get cardBodyClasses() {
        const classes = classNames({
            'card-body': true,
            'd-flex': true,
            'align-items-center': true,
            [`p-${this.iconPadding ? '3' : '0'}`]: true,
        });
        return classes;
    }
    get bodySlotClasses() {
        const classes = classNames({
            'mfe-3': true,
            'text-white': true,
            [`bg-${this.color}`]: this.color,
            [`p-${this.iconPadding ? '3' : '4'}`]: true,
        });
        return classes;
    }
    get headerClasses() {
        const classes = classNames({
            'text-value': true,
            [`text-${this.color}`]: this.color
        });
        return classes;
    }
}
WidgetIconComponent.ɵfac = function WidgetIconComponent_Factory(t) { return new (t || WidgetIconComponent)(); };
WidgetIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetIconComponent, selectors: [["c-widget-icon"]], hostVars: 2, hostBindings: function WidgetIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { iconPadding: "iconPadding", color: "color", header: "header", text: "text" }, ngContentSelectors: _c19, decls: 8, vars: 6, consts: [[3, "class", 4, "ngIf"], ["class", "text-muted text-uppercase font-weight-bold small", 4, "ngIf"], [1, "text-muted", "text-uppercase", "font-weight-bold", "small"]], template: function WidgetIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c18);
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵelementStart(1, "div");
        ɵngcc0.ɵɵelementStart(2, "div");
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div");
        ɵngcc0.ɵɵtemplate(5, WidgetIconComponent_div_5_Template, 2, 3, "div", 0);
        ɵngcc0.ɵɵtemplate(6, WidgetIconComponent_div_6_Template, 2, 1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(7, 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ctx.cardBodyClasses);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ctx.bodySlotClasses);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.text);
    } }, directives: [ɵngcc3.NgIf], styles: [""] });
WidgetIconComponent.ctorParameters = () => [];
WidgetIconComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    iconPadding: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetIconComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-icon',
                template: "<ng-container>\n  <div [class]=\"cardBodyClasses\">\n    <div [class]=\"bodySlotClasses\">\n      <ng-content></ng-content>\n    </div>\n    <div>\n      <div *ngIf=\"!!header\" [class]=\"headerClasses\">\n        {{header}}\n      </div>\n      <div *ngIf=\"!!text\" class=\"text-muted text-uppercase font-weight-bold small\">\n        {{text}}\n      </div>\n    </div>\n  </div>\n  <ng-content select=\"[slot=footer]\"></ng-content>\n</ng-container>\n",
                styles: [""]
            }]
    }], function () { return []; }, { iconPadding: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }], header: [{
            type: Input
        }], text: [{
            type: Input
        }] }); })();

class WidgetDropdownComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': true,
            [`bg-${this.color}`]: !!this.color,
        });
        return classes;
    }
    ngOnInit() { }
}
WidgetDropdownComponent.ɵfac = function WidgetDropdownComponent_Factory(t) { return new (t || WidgetDropdownComponent)(); };
WidgetDropdownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetDropdownComponent, selectors: [["c-widget-dropdown"]], hostVars: 2, hostBindings: function WidgetDropdownComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { color: "color", header: "header", text: "text" }, ngContentSelectors: _c19, decls: 9, vars: 2, consts: [[1, "card-body", "pb-0", "d-flex", "justify-content-between", "align-items-start"], ["v-if", "header", 1, "text-value-lg"], ["v-if", "text"]], template: function WidgetDropdownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c18);
        ɵngcc0.ɵɵelementContainerStart(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "div");
        ɵngcc0.ɵɵelementStart(3, "div", 1);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 2);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(8, 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate(ctx.header);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.text);
    } }, styles: [""] });
WidgetDropdownComponent.ctorParameters = () => [];
WidgetDropdownComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetDropdownComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-dropdown',
                template: "<ng-container>\n  <div class=\"card-body pb-0 d-flex justify-content-between align-items-start\">\n    <div>\n      <div v-if=\"header\" class=\"text-value-lg\">{{header}}</div>\n      <div v-if=\"text\">{{text}}</div>\n    </div>\n    <ng-content></ng-content>\n<!--    <ng-content select=\"[dropdown]\" ></ng-content>-->\n  </div>\n  <ng-content select=\"[slot=footer]\"></ng-content>\n</ng-container>\n",
                styles: [""]
            }]
    }], function () { return []; }, { getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }], header: [{
            type: Input
        }], text: [{
            type: Input
        }] }); })();

class WidgetProgressComponent {
    constructor() {
        this.value = 25;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': this.inverse,
            [`bg-${this.color}`]: this.inverse && !!this.color
        });
        return classes;
    }
    ngOnInit() {
    }
}
WidgetProgressComponent.ɵfac = function WidgetProgressComponent_Factory(t) { return new (t || WidgetProgressComponent)(); };
WidgetProgressComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetProgressComponent, selectors: [["c-widget-progress"]], hostVars: 2, hostBindings: function WidgetProgressComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { value: "value", color: "color", footer: "footer", header: "header", text: "text", inverse: "inverse" }, decls: 8, vars: 9, consts: [[1, "card-body"], ["v-if", "header", 1, "h4", "m-0"], ["v-if", "text"], ["size", "xs"], [3, "color", "value"], ["class", "text-muted", 4, "ngIf"], [1, "text-muted"]], template: function WidgetProgressComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "c-progress", 3);
        ɵngcc0.ɵɵelement(6, "c-progress-bar", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, WidgetProgressComponent_small_7_Template, 2, 1, "small", 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.header);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.text);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ɵngcc0.ɵɵpureFunction1(7, _c20, ctx.inverse));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", !ctx.inverse ? ctx.color : "")("value", ctx.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.footer);
    } }, directives: [ProgressComponent, ProgressBarComponent, ɵngcc3.NgIf], styles: [""] });
WidgetProgressComponent.ctorParameters = () => [];
WidgetProgressComponent.propDecorators = {
    color: [{ type: Input }],
    footer: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    inverse: [{ type: Input }],
    value: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetProgressComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-progress',
                template: "<div class=\"card-body\">\n  <div v-if=\"header\" class=\"h4 m-0\">{{header}}</div>\n  <div v-if=\"text\">{{text}}</div>\n  <c-progress size=\"xs\" [class]=\"{'my-3': true, 'mb-0': true, 'progress-white': inverse }\">\n    <c-progress-bar\n      [color]=\"!inverse ? color : ''\"\n      [value]=\"value\"\n    ></c-progress-bar>\n  </c-progress>\n  <small *ngIf=\"!!footer\" class=\"text-muted\">\n    {{footer}}\n  </small>\n</div>\n",
                styles: [""]
            }]
    }], function () { return []; }, { value: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }], footer: [{
            type: Input
        }], header: [{
            type: Input
        }], text: [{
            type: Input
        }], inverse: [{
            type: Input
        }] }); })();

class WidgetProgressIconComponent {
    constructor() {
        this.value = 25;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': this.inverse,
            [`bg-${this.color}`]: this.inverse && !!this.color
        });
        return classes;
    }
    ngOnInit() {
    }
}
WidgetProgressIconComponent.ɵfac = function WidgetProgressIconComponent_Factory(t) { return new (t || WidgetProgressIconComponent)(); };
WidgetProgressIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WidgetProgressIconComponent, selectors: [["c-widget-progress-icon"]], hostVars: 2, hostBindings: function WidgetProgressIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.getClasses);
    } }, inputs: { value: "value", color: "color", header: "header", text: "text", inverse: "inverse" }, ngContentSelectors: _c0, decls: 7, vars: 8, consts: [[1, "card-body"], [1, "h1", "text-muted", "text-right", "mb-4"], ["class", "h4 mb-0", 4, "ngIf"], ["class", "text-muted text-uppercase font-weight-bold", 4, "ngIf"], ["size", "xs"], [3, "color", "value"], [1, "h4", "mb-0"], [1, "text-muted", "text-uppercase", "font-weight-bold"]], template: function WidgetProgressIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, WidgetProgressIconComponent_div_3_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵtemplate(4, WidgetProgressIconComponent_small_4_Template, 2, 1, "small", 3);
        ɵngcc0.ɵɵelementStart(5, "c-progress", 4);
        ɵngcc0.ɵɵelement(6, "c-progress-bar", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.header);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !!ctx.text);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ɵngcc0.ɵɵpureFunction1(6, _c20, ctx.inverse));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", !ctx.inverse ? ctx.color : "")("value", ctx.value);
    } }, directives: [ɵngcc3.NgIf, ProgressComponent, ProgressBarComponent], styles: [""] });
WidgetProgressIconComponent.ctorParameters = () => [];
WidgetProgressIconComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    inverse: [{ type: Input }],
    value: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetProgressIconComponent, [{
        type: Component,
        args: [{
                selector: 'c-widget-progress-icon',
                template: "<div class=\"card-body\">\n  <div class=\"h1 text-muted text-right mb-4\">\n    <ng-content></ng-content>\n  </div>\n  <div *ngIf=\"!!header\" class=\"h4 mb-0\">{{header}}</div>\n  <small *ngIf=\"!!text\" class=\"text-muted text-uppercase font-weight-bold\">\n    {{text}}\n  </small>\n<!-- todo  <ng-content slot=\"progress\"></ng-content>-->\n    <c-progress size=\"xs\" [class]=\"{'my-3': true, 'mb-0': true, 'progress-white': inverse }\">\n      <c-progress-bar\n        [color]=\"!inverse ? color : ''\"\n        [value]=\"value\"\n        >\n      </c-progress-bar>\n    </c-progress>\n</div>\n",
                styles: [""]
            }]
    }], function () { return []; }, { value: [{
            type: Input
        }], getClasses: [{
            type: HostBinding,
            args: ['class']
        }], color: [{
            type: Input
        }], header: [{
            type: Input
        }], text: [{
            type: Input
        }], inverse: [{
            type: Input
        }] }); })();

class WidgetModule {
}
WidgetModule.ɵfac = function WidgetModule_Factory(t) { return new (t || WidgetModule)(); };
WidgetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: WidgetModule });
WidgetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            ProgressModule
        ], ProgressModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(WidgetModule, { declarations: function () { return [WidgetSimpleComponent, WidgetBrandComponent, WidgetIconComponent, WidgetDropdownComponent, WidgetProgressComponent, WidgetProgressIconComponent]; }, imports: function () { return [CommonModule, ProgressModule]; }, exports: function () { return [WidgetSimpleComponent, WidgetBrandComponent, WidgetIconComponent, WidgetDropdownComponent, WidgetProgressComponent, WidgetProgressIconComponent, ProgressModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(WidgetModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    WidgetSimpleComponent,
                    WidgetBrandComponent,
                    WidgetIconComponent,
                    WidgetDropdownComponent,
                    WidgetProgressComponent,
                    WidgetProgressIconComponent
                ],
                exports: [
                    WidgetSimpleComponent,
                    WidgetBrandComponent,
                    WidgetIconComponent,
                    WidgetDropdownComponent,
                    WidgetProgressComponent,
                    WidgetProgressIconComponent,
                    ProgressModule
                ],
                imports: [
                    CommonModule,
                    ProgressModule
                ]
            }]
    }], null, null); })();

export { AccordionModule, AlertModule, BadgeModule, BodyComponent, BreadcrumbModule, ButtonModule, CalloutModule, CardModule, CarouselModule, ChartModule, ClassToggleService, CollapseDirective, CollapseModule, DropdownModule, EmbedModule, FooterComponent, FormModule, GridModule, HeaderBrandComponent, HeaderComponent, ImgModule, LayoutModule, ListGroupModule, MediaModule, ModalModule, NavModule, NavbarModule, ProgressModule, SharedModule, SidebarBackdropComponent, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarFormComponent, SidebarHeaderComponent, SidebarMinimizeDirective, SidebarMinimizerComponent, SidebarModule, SidebarNavBadgePipe, SidebarNavComponent, SidebarNavDividerComponent, SidebarNavDropdownComponent, SidebarNavDropdownToggleDirective, SidebarNavIconPipe, SidebarNavItemClassPipe, SidebarNavItemsComponent, SidebarNavLabelComponent, SidebarNavLinkComponent, SidebarNavLinkContentComponent, SidebarNavLinkPipe, SidebarNavService, SidebarNavTitleComponent, SidebarService, SidebarToggleDirective, SpinkitModule, SpinnerModule, SubheaderComponent, SwitchModule, TabsetModule, TextMaskConfig, TextMaskDirective, TextMaskModule, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPosition, ToasterService, TogglerModule, WidgetModule, WrapperComponent, AccordionComponent as ɵa, AccordionGroupComponent as ɵb, CarouselComponent as ɵba, CarouselService as ɵbb, CarouselState as ɵbc, CarouselConfig as ɵbd, CarouselCaptionComponent as ɵbe, CarouselControlComponent as ɵbf, CarouselIndicatorsComponent as ɵbg, CarouselInnerComponent as ɵbh, toLeft as ɵbi, toRight as ɵbj, slideAnimation as ɵbk, CarouselItemComponent as ɵbl, DropdownDirective as ɵbm, DropdownService as ɵbn, DropdownState as ɵbo, OutClickService as ɵbp, DropdownToggleDirective as ɵbq, DropdownMenuDirective as ɵbr, DropdownHeaderDirective as ɵbs, DropdownDividerDirective as ɵbt, DropdownItemDirective as ɵbu, DropdownDividerComponent as ɵbv, EmbedComponent as ɵbw, EmbedItemDirective as ɵbx, FormDirective as ɵby, FormCheckComponent as ɵbz, CardModule as ɵc, FormFeedbackComponent as ɵca, FormGroupComponent as ɵcb, FormTextComponent as ɵcc, InputDirective as ɵcd, InputGroupComponent as ɵce, InputGroupTextComponent as ɵcf, InputGroupAddonComponent as ɵcg, InputGroupPrependComponent as ɵch, InputGroupAppendComponent as ɵci, TextareaDirective as ɵcj, SelectDirective as ɵck, LabelDirective as ɵcl, ContainerComponent as ɵcm, RowComponent as ɵcn, RowDirective as ɵco, ColComponent as ɵcp, ColDirective as ɵcq, ImgDirective as ɵcr, ListGroupDirective as ɵcs, ListGroupItemDirective as ɵct, MediaComponent as ɵcu, MediaDirective as ɵcv, MediaBodyComponent as ɵcw, ModalComponent as ɵcx, NavComponent as ɵcy, NavItemComponent as ɵcz, CollapseDirective as ɵd, NavLinkDirective as ɵda, NavbarComponent as ɵdb, NavbarBrandComponent as ɵdc, NavbarNavComponent as ɵdd, NavbarTextComponent as ɵde, ProgressComponent as ɵdf, ProgressBarComponent as ɵdg, OutClickDirective as ɵdh, OutClickService as ɵdi, HtmlAttributesDirective as ɵdj, SpinkitComponent as ɵdk, SpinnerComponent as ɵdl, SwitchComponent as ɵdm, TabsetComponent as ɵdn, TabsetService as ɵdo, TabListComponent as ɵdp, TabComponent as ɵdq, TabPaneComponent as ɵdr, TabContentComponent as ɵds, ToastComponent as ɵdt, ToasterService as ɵdu, ToastHeaderComponent as ɵdv, ToastBodyComponent as ɵdw, ToasterComponent as ɵdx, ToasterHostDirective as ɵdy, ToastCloseDirective as ɵdz, AlertComponent as ɵe, TogglerComponent as ɵea, WidgetSimpleComponent as ɵeb, WidgetBrandComponent as ɵec, WidgetIconComponent as ɵed, WidgetDropdownComponent as ɵee, WidgetProgressComponent as ɵef, WidgetProgressIconComponent as ɵeg, BadgeComponent as ɵf, SharedModule as ɵg, BreadcrumbComponent as ɵh, BreadcrumbDirective as ɵi, BreadcrumbService as ɵj, ButtonComponent as ɵk, ButtonDirective as ɵl, ButtonGroupComponent as ɵm, ButtonToolbarComponent as ɵn, RADIO_CONTROL_VALUE_ACCESSOR$1 as ɵo, ButtonRadioDirective as ɵp, RADIO_CONTROL_VALUE_ACCESSOR as ɵq, ButtonRadioGroupDirective as ɵr, CalloutComponent as ɵs, CardComponent as ɵt, CardBodyComponent as ɵu, CardFooterComponent as ɵv, CardGroupComponent as ɵw, CardHeaderComponent as ɵx, CardHeaderActionsComponent as ɵy, NoZoneBaseChartDirective as ɵz };

//# sourceMappingURL=coreui-angular.js.map