import { Component, HostBinding, Inject, Input, NgModule, EventEmitter, Directive, ElementRef, Output, SecurityContext, Renderer2, ɵɵdefineInjectable, ɵɵinject, Injectable, Host, HostListener, forwardRef, ChangeDetectorRef, Optional, NgZone, ViewChild, ContentChildren, ContentChild, RendererFactory2, Pipe, ViewContainerRef, ComponentFactoryResolver } from '@angular/core';
import { CommonModule, DOCUMENT } from '@angular/common';
import classNames from 'classnames';
import { animation, style, animate, useAnimation, AnimationBuilder, trigger, state, transition, group, query } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { NavigationEnd, Router, ActivatedRoute, RouterModule } from '@angular/router';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { BaseChartDirective, ThemeService } from 'ng2-charts';
import { BreakpointObserver } from '@angular/cdk/layout';
import { Platform } from '@angular/cdk/platform';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';

class AccordionComponent {
    constructor() {
        this.accordionClass = true;
        this.groups = [];
    }
    closeOtherGroups(openGroup) {
        this.groups.forEach((group) => {
            if (group !== openGroup) {
                group.isOpen = false;
            }
        });
    }
    addGroup(group) {
        this.groups.push(group);
    }
    removeGroup(group) {
        const index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-accordion',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            },] }
];
AccordionComponent.propDecorators = {
    accordionClass: [{ type: HostBinding, args: ['class.accordion',] }]
};

class AccordionGroupComponent {
    constructor(accordion) {
        this.isOpen = false;
        this.groupClass = '';
        this.cardClass = true;
        this.accordion = accordion;
    }
    ngOnInit() {
        this.accordion.addGroup(this);
    }
    ngOnDestroy() {
        this.accordion.removeGroup(this);
    }
    toggleGroup() {
        this.isOpen = !this.isOpen;
        this.accordion.closeOtherGroups(this);
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-accordion-group',
                template: "<c-card-header (click)=\"toggleGroup()\">\n  <ng-content select=\"[c-accordion-header]\"></ng-content>\n</c-card-header>\n<c-card-body cCollapse [show]=\"!isOpen\">\n  <ng-content></ng-content>\n</c-card-body>\n",
                styles: [":host{margin-bottom:0}"]
            },] }
];
AccordionGroupComponent.ctorParameters = () => [
    { type: AccordionComponent, decorators: [{ type: Inject, args: [AccordionComponent,] }] }
];
AccordionGroupComponent.propDecorators = {
    isOpen: [{ type: Input }],
    groupClass: [{ type: Input }],
    cardClass: [{ type: HostBinding, args: ['class.card',] }]
};

class CardComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            [`card-accent-${this.accentColor}`]: this.accentColor,
            [`text-${this.align}`]: this.align,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor
        });
        return classes;
    }
}
CardComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card, [c-card]',
                template: `<ng-content></ng-content>`
            },] }
];
CardComponent.propDecorators = {
    accentColor: [{ type: Input }],
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CardBodyComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-body': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card-body, [c-card-body]',
                template: '<ng-content></ng-content>'
            },] }
];
CardBodyComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CardFooterComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-footer': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card-footer, [c-card-footer]',
                template: '<ng-content></ng-content>'
            },] }
];
CardFooterComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CardGroupComponent {
    constructor() {
        this.deck = false;
        this.columns = false;
    }
    get hostClasses() {
        return this.getClasses();
    }
    getClasses() {
        return `card-${this.columns ? 'columns' : this.deck ? 'deck' : 'group'}`;
    }
}
CardGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card-group, [c-card-group]',
                template: '<ng-content></ng-content>'
            },] }
];
CardGroupComponent.propDecorators = {
    deck: [{ type: Input }],
    columns: [{ type: Input }],
    hostClasses: [{ type: HostBinding, args: ['class',] }]
};

class CardHeaderComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'card-header': true,
            [`bg-${this.color}`]: this.color,
            [`border-${this.borderColor}`]: this.borderColor,
            [`text-${this.textColor}`]: this.textColor,
            [`text-${this.align}`]: this.align
        });
        return classes;
    }
}
CardHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card-header, [c-card-header]',
                template: '<ng-content></ng-content>'
            },] }
];
CardHeaderComponent.propDecorators = {
    align: [{ type: Input }],
    color: [{ type: Input }],
    borderColor: [{ type: Input }],
    textColor: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CardHeaderActionsComponent {
    constructor() {
        this.cardHeaderActions = true;
    }
}
CardHeaderActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-card-header-actions, [c-card-header-actions]',
                template: '<ng-content></ng-content>'
            },] }
];
CardHeaderActionsComponent.propDecorators = {
    cardHeaderActions: [{ type: HostBinding, args: ['class.card-header-actions',] }]
};

class CardModule {
}
CardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CardComponent,
                    CardBodyComponent,
                    CardFooterComponent,
                    CardGroupComponent,
                    CardHeaderComponent,
                    CardHeaderActionsComponent
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    CardComponent,
                    CardBodyComponent,
                    CardFooterComponent,
                    CardGroupComponent,
                    CardHeaderComponent,
                    CardHeaderActionsComponent
                ]
            },] }
];

const expandAnimation = animation([
    style({ height: 0, visibility: 'hidden', overflow: 'hidden', paddingTop: 0, paddingBottom: 0 }),
    animate('{{ time }} {{ easing }}', style({ height: '*', visibility: 'visible', paddingTop: '*', paddingBottom: '*', minHeight: '*' })),
    animate('{{ time }}', style({ opacity: '*', overflow: '*' })),
]);
const collapseAnimation = animation([
    style({ height: '*', visibility: 'visible', overflow: 'hidden', paddingTop: '*', paddingBottom: '*', minHeight: '*' }),
    animate('{{ time }} {{ easing }}', style({ height: 0, visibility: 'hidden', opacity: 0, overflow: 'hidden', paddingTop: 0, paddingBottom: 0, minHeight: 0 }))
]);

class CollapseDirective {
    constructor(hostElement, animationBuilder) {
        this.hostElement = hostElement;
        this.animationBuilder = animationBuilder;
        this.duration = '400ms';
        this.transition = 'ease-in-out';
        this.animate = true;
        this.collapseChange = new EventEmitter();
        this._show = false;
        this._animate = this.animate;
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'navbar-collapse': !!this.navbar,
            show: !!this.show,
        });
        return classes;
    }
    ngOnInit() {
        this._show = this.show;
    }
    ngOnDestroy() {
        this.destroyPlayer();
    }
    ngOnChanges(changes) {
        if (changes.show) {
            (!changes.show.firstChange || !changes.show.currentValue) && this.toggle(changes.show.currentValue);
        }
    }
    ngDoCheck() {
        if (this._show !== this.show) {
            this.toggle();
        }
    }
    toggle(show = this.show) {
        this._show = show;
        this.createPlayer(show);
        this.player.play();
    }
    destroyPlayer() {
        if (this.player) {
            this.player.destroy();
        }
    }
    createPlayer(show = this.show) {
        if (this.player) {
            this.destroyPlayer();
        }
        let animationFactory;
        const duration = this._animate ? this.duration : '0ms';
        animationFactory = this.animationBuilder.build(useAnimation(show ? expandAnimation : collapseAnimation, { params: { time: duration, easing: this.transition } }));
        this.player = animationFactory.create(this.host);
        this.player.onStart(() => { this.collapseChange.emit(show ? 'opening' : 'collapsing'); });
        this.player.onDone(() => { this.collapseChange.emit(show ? 'open' : 'collapsed'); });
    }
}
CollapseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cCollapse]',
                exportAs: 'cCollapse',
            },] }
];
CollapseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder }
];
CollapseDirective.propDecorators = {
    navbar: [{ type: Input }],
    duration: [{ type: Input }],
    transition: [{ type: Input }],
    show: [{ type: Input }],
    animate: [{ type: Input }],
    collapseChange: [{ type: Output }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CollapseModule {
    static forRoot() {
        return { ngModule: CollapseModule, providers: [] };
    }
}
CollapseModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CollapseDirective],
                exports: [CollapseDirective],
                imports: [
                    CommonModule
                ]
            },] }
];

class AccordionModule {
}
AccordionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [AccordionComponent, AccordionGroupComponent],
                exports: [
                    AccordionComponent,
                    AccordionGroupComponent
                ],
                imports: [
                    CommonModule,
                    CardModule,
                    CollapseModule
                ]
            },] }
];

class AlertComponent {
    constructor(sanitizer, hostElement, renderer) {
        this.sanitizer = sanitizer;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.color = 'info';
        this.closeButton = false;
        this.show = true;
        this.fade = false;
        this.iconHtml = '<span>&times;</span>';
        this.timeout = 0;
        this.dismissed = new EventEmitter();
        this.timer = new EventEmitter();
    }
    get clock() {
        const time = this._clock;
        this.timer.emit(time);
        return time;
    }
    get animationDisabled() {
        return !this.fade;
    }
    get animateType() {
        return this.show ? 'show' : 'hide';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            alert: true,
            'alert-dismissible': !!this.closeButton,
            [`alert-${this.color}`]: !!this.color
        });
        return classes;
    }
    ngOnInit() {
        this.safeIcon = this.sanitizer.sanitize(SecurityContext.HTML, this.iconHtml);
        if (this.show && this.timeout) {
            this.setTimer();
        }
    }
    ngOnDestroy() {
        this.clearTimer();
        this.clearClock();
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.hostElement.nativeElement, `alert-${changes.color.previousValue}`);
        }
        if (changes.timeout) {
            this.setTimer();
        }
    }
    setTimer() {
        this.clearTimer();
        this.timerId = this.timeout > 0 ? setTimeout(() => this.onClose(), this.timeout) : null;
        this.setClock();
    }
    clearTimer() {
        clearTimeout(this.timerId);
        this.timerId = null;
    }
    onClose() {
        this.clearTimer();
        if (this.show) {
            this.show = false;
            this.hide = true;
            this.dismissed.emit(this);
        }
    }
    setClock() {
        this.clearClock();
        this._clock = 0;
        this.clockId = setInterval(() => {
            this._clock += 1;
        }, 1000);
        setTimeout(() => {
            this.clearClock();
        }, this.timeout);
    }
    clearClock() {
        clearInterval(this.clockId);
        this.clockId = null;
    }
    onAnimationEvent(event) {
        console.warn(event);
        if (event.phaseName === 'done' && event.toState === 'hide') {
        }
        if (event.phaseName === 'start' && event.toState === 'show') {
        }
    }
}
AlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-alert',
                template: "<!--<div [@fadeInOut]=\"show ? 'show' : 'hide'\" [class]=\"alertClasses\">-->\n<ng-container>\n  <ng-template [ngIf]=\"closeButton\">\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"onClose()\">\n      <span aria-hidden=\"true\" [innerHTML]=\"safeIcon\"></span>\n      <span class=\"sr-only\">Close</span>\n    </button>\n  </ng-template>\n  <ng-content></ng-content>\n</ng-container>\n",
                animations: [
                    trigger('fadeInOut', [
                        state('show', style({ opacity: 1 })),
                        state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        transition('show => hide', [
                            animate('.3s ease-out', style({ opacity: 0 })),
                            animate('.3s ease-out', style({ height: 0, padding: 0, border: 0, margin: 0 }))
                        ]),
                        transition('hide => show', [
                            animate('.3s ease-in', style({ height: '*', padding: '*', border: '*', margin: '*' })),
                            animate('.3s ease-in', style({ opacity: '*' }))
                        ])
                    ])
                ],
                styles: [":host{display:block}"]
            },] }
];
AlertComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ElementRef },
    { type: Renderer2 }
];
AlertComponent.propDecorators = {
    color: [{ type: Input }],
    closeButton: [{ type: Input }],
    show: [{ type: Input }],
    fade: [{ type: Input }],
    iconHtml: [{ type: Input }],
    timeout: [{ type: Input }],
    dismissed: [{ type: Output }],
    timer: [{ type: Output }],
    animationDisabled: [{ type: HostBinding, args: ['@.disabled',] }],
    animateType: [{ type: HostBinding, args: ['@fadeInOut',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class AlertModule {
}
AlertModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    AlertComponent
                ],
                declarations: [
                    AlertComponent
                ]
            },] }
];

class BadgeComponent {
    constructor(hostElement, renderer) {
        this.hostElement = hostElement;
        this.renderer = renderer;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            badge: true,
            [`badge-${this.color}`]: !!this.color,
            [`badge-${this.shape}`]: !!this.shape
        });
        return classes;
    }
    ngOnChanges(changes) {
        if (changes.color) {
            const classOff = `badge-${changes.color.previousValue}`;
            this.renderer.removeClass(this.hostElement.nativeElement, classOff);
        }
        if (changes.shape) {
            const classOff = `badge-${changes.shape.previousValue}`;
            this.renderer.removeClass(this.hostElement.nativeElement, classOff);
        }
    }
}
BadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-badge',
                template: '<ng-content></ng-content>',
                styles: [""]
            },] }
];
BadgeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
BadgeComponent.propDecorators = {
    shape: [{ type: Input }],
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class BadgeModule {
}
BadgeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    BadgeComponent
                ],
                declarations: [
                    BadgeComponent
                ]
            },] }
];

class BreadcrumbService {
    constructor(router, route) {
        this.router = router;
        this.route = route;
        this.outlet = 'primary';
        this.breadcrumbsBehaviorSubject = new BehaviorSubject(new Array());
        this.breadcrumbs$ = this.breadcrumbsBehaviorSubject.asObservable();
        this.router.events.pipe(filter(event => event instanceof NavigationEnd)).subscribe((event) => {
            const breadcrumbs = [];
            let currentRoute = this.route.root;
            let url = '';
            do {
                const childrenRoutes = currentRoute.children;
                currentRoute = null;
                childrenRoutes.forEach(route => {
                    if (route.outlet === this.outlet) {
                        const routeSnapshot = route.snapshot;
                        url += '/' + routeSnapshot.url.map(segment => segment.path).join('/');
                        breadcrumbs.push({
                            label: route.snapshot.data.title || '',
                            url,
                            queryParams: routeSnapshot.queryParams
                        });
                        currentRoute = route;
                    }
                });
            } while (currentRoute);
            this.breadcrumbsBehaviorSubject.next(Object.assign([], breadcrumbs));
            return breadcrumbs;
        });
    }
}
BreadcrumbService.ɵprov = ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(ɵɵinject(Router), ɵɵinject(ActivatedRoute)); }, token: BreadcrumbService, providedIn: "root" });
BreadcrumbService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
BreadcrumbService.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];

class BreadcrumbComponent {
    constructor() {
        this.divider = false;
        this.breadcrumbClass = true;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes.items) {
            this.setup();
        }
    }
    setup() {
        if (this.items && this.items.length > 0) {
            this.breadcrumbs = new Observable((observer) => {
                if (this.items) {
                    observer.next(this.items);
                }
            });
        }
    }
    ngOnDestroy() {
        this.breadcrumbs = null;
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-breadcrumb',
                template: "<ng-container>\n  <ng-template ngFor let-breadcrumb [ngForOf]=\"breadcrumbs | async\" let-last = last>\n    <ng-container *ngIf=\"breadcrumb.label && (breadcrumb.url.slice(-1) == '/' || last)\">\n      <div *ngIf=\"!last\" class=\"breadcrumb-item\">\n        <a [routerLink]=\"breadcrumb.url\"\n           [cHtmlAttr]=\"breadcrumb.attributes\"\n           [target]=\"breadcrumb.attributes?.target\"\n           [queryParams]=\"breadcrumb.linkProps?.queryParams\"\n           [fragment]=\"breadcrumb.linkProps?.fragment\"\n           [queryParamsHandling]=\"breadcrumb.linkProps?.queryParamsHandling\"\n           [preserveFragment]=\"breadcrumb.linkProps?.preserveFragment\"\n           [skipLocationChange]=\"breadcrumb.linkProps?.skipLocationChange\"\n           [replaceUrl]=\"breadcrumb.linkProps?.replaceUrl\"\n           [state]=\"breadcrumb.linkProps?.state\"\n           i18n>{{breadcrumb.label}}\n        </a>\n      </div>\n      <span *ngIf=\"!last && divider\" ngPreserveWhitespaces=\"true\"> {{divider}} </span>\n      <span class=\"breadcrumb-item active\" *ngIf=\"last\" [cHtmlAttr]=\"breadcrumb.attributes\" i18n>{{breadcrumb.label}}</span>\n    </ng-container>\n  </ng-template>\n  <ng-content></ng-content>\n</ng-container>\n",
                styles: [""]
            },] }
];
BreadcrumbComponent.ctorParameters = () => [];
BreadcrumbComponent.propDecorators = {
    items: [{ type: Input }],
    divider: [{ type: Input }],
    breadcrumbClass: [{ type: HostBinding, args: ['class.breadcrumb',] }]
};

class BreadcrumbDirective {
    constructor(breadcrumbComponent, service) {
        this.breadcrumbComponent = breadcrumbComponent;
        this.service = service;
    }
    ngOnInit() {
        this.breadcrumbComponent.breadcrumbs = this.service.breadcrumbs$;
    }
}
BreadcrumbDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cBreadcrumbRouter]',
                exportAs: 'cBreadcrumbRouter'
            },] }
];
BreadcrumbDirective.ctorParameters = () => [
    { type: BreadcrumbComponent, decorators: [{ type: Host }] },
    { type: BreadcrumbService }
];

class OutClickService {
    constructor() {
        this.outClick = new BehaviorSubject({ event: undefined });
        this.outClick$ = this.outClick.asObservable();
    }
    onClick(message) {
        this.outClick.next(message);
    }
}
OutClickService.ɵprov = ɵɵdefineInjectable({ factory: function OutClickService_Factory() { return new OutClickService(); }, token: OutClickService, providedIn: "root" });
OutClickService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
OutClickService.ctorParameters = () => [];

class OutClickDirective {
    constructor(elementRef, outClickService) {
        this.elementRef = elementRef;
        this.outClickService = outClickService;
    }
    onDocumentClick($event) {
        const targetElement = $event.target;
        if (targetElement && !this.elementRef.nativeElement.contains(targetElement)) {
            this.outClickService.onClick({ event: $event });
        }
    }
    ngOnInit() {
        this.outClickSubscription = this.outClickService.outClick$.subscribe((message) => {
        });
    }
    ngOnDestroy() {
        this.outClickSubscription.unsubscribe();
    }
}
OutClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cOutClick]',
                exportAs: 'cOutClick',
            },] }
];
OutClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: OutClickService }
];
OutClickDirective.propDecorators = {
    onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

class HtmlAttributesDirective {
    constructor(renderer, el) {
        this.renderer = renderer;
        this.el = el;
    }
    ngOnInit() {
        const attribs = this.cHtmlAttr;
        for (const attr in attribs) {
            if (attr === 'style' && typeof (attribs[attr]) === 'object') {
                this.setStyle(attribs[attr]);
            }
            else if (attr === 'class') {
                this.addClass(attribs[attr]);
            }
            else {
                this.setAttrib(attr, attribs[attr]);
            }
        }
    }
    setStyle(styles) {
        for (const style in styles) {
            if (style) {
                this.renderer.setStyle(this.el.nativeElement, style, styles[style]);
            }
        }
    }
    addClass(classes) {
        const classArray = (Array.isArray(classes) ? classes : classes.split(' '));
        classArray.filter((element) => element.length > 0).forEach(element => {
            this.renderer.addClass(this.el.nativeElement, element);
        });
    }
    setAttrib(key, value) {
        value !== null ?
            this.renderer.setAttribute(this.el.nativeElement, key, value) :
            this.renderer.removeAttribute(this.el.nativeElement, key);
    }
}
HtmlAttributesDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cHtmlAttr]',
                exportAs: 'cHtmlAttr'
            },] }
];
HtmlAttributesDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
HtmlAttributesDirective.propDecorators = {
    cHtmlAttr: [{ type: Input }]
};

class SharedModule {
    static forRoot() {
        return {
            ngModule: SharedModule,
            providers: [
                { provide: OutClickService }
            ]
        };
    }
}
SharedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    OutClickDirective,
                    HtmlAttributesDirective
                ],
                exports: [
                    OutClickDirective,
                    HtmlAttributesDirective
                ],
                providers: []
            },] }
];

const sidebarCssClasses = [
    'c-sidebar-show',
    'c-sidebar-sm-show',
    'c-sidebar-md-show',
    'c-sidebar-lg-show',
    'c-sidebar-xl-show'
];
const validBreakpoints = ['sm', 'md', 'lg', 'xl'];
function checkBreakpoint(breakpoint, list) {
    return list.indexOf(breakpoint) > -1;
}

class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, SharedModule],
                exports: [BreadcrumbComponent, BreadcrumbDirective],
                declarations: [BreadcrumbComponent, BreadcrumbDirective],
                providers: [BreadcrumbService]
            },] }
];

class ButtonComponent {
    constructor() {
        this.block = null;
        this.size = '';
        this.type = 'button';
        this.tabindex = null;
        this.disabled = null;
        this.pressed = null;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const outlineSuffix = this.variant === 'outline' ? 'outline-' : '';
        const classes = classNames({
            btn: true,
            [`btn-${outlineSuffix}${this.color}`]: this.color,
            [`btn-${this.size}`]: this.size,
            [`btn-ghost-${this.color}`]: this.variant === 'ghost',
            'btn-block': this.block != null,
            'btn-pill': this.shape === 'pill',
            'btn-square': this.shape === 'square',
            disabled: !!this.disabled,
            focus: !this.variant && this.pressed != null,
            active: this.variant && this.pressed != null
        });
        return classes;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get hostType() {
        return this.type;
    }
    get hostRole() {
        return 'button';
    }
    ngOnInit() {
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-button, [c-button]',
                template: '<ng-content></ng-content>',
                styles: [":host.disabled,:host:disabled{cursor:default}"]
            },] }
];
ButtonComponent.ctorParameters = () => [];
ButtonComponent.propDecorators = {
    block: [{ type: Input }],
    shape: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    disabled: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
    pressed: [{ type: HostBinding, args: ['attr.aria-pressed',] }, { type: Input }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostType: [{ type: HostBinding, args: ['attr.type',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};

class ButtonDirective {
    constructor() {
        this.block = null;
        this.size = '';
        this.type = 'button';
        this.tabindex = null;
        this.disabled = null;
        this.pressed = null;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const outlineSuffix = this.variant === 'outline' ? 'outline-' : '';
        const classes = classNames({
            btn: true,
            [`btn-${outlineSuffix}${this.color}`]: this.color,
            [`btn-${this.size}`]: this.size,
            [`btn-ghost-${this.color}`]: this.variant === 'ghost',
            'btn-block': this.block != null,
            'btn-pill': this.shape === 'pill',
            'btn-square': this.shape === 'square',
            disabled: !!this.disabled,
            focus: !this.variant && this.pressed != null,
            active: this.variant && this.pressed != null
        });
        return classes;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get hostType() {
        return this.type;
    }
    get hostRole() {
        return 'button';
    }
    ngOnInit() {
    }
}
ButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cButton]',
                exportAs: 'cButton',
            },] }
];
ButtonDirective.ctorParameters = () => [];
ButtonDirective.propDecorators = {
    block: [{ type: Input }],
    shape: [{ type: Input }],
    variant: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    disabled: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
    pressed: [{ type: HostBinding, args: ['attr.aria-pressed',] }, { type: Input }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostType: [{ type: HostBinding, args: ['attr.type',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};

class ButtonGroupComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.size = '';
        this.vertical = null;
        this.classes = Object.create(null);
        this.aria = 'Button group';
        this.host = this.hostElement.nativeElement;
    }
    get hostRole() {
        return 'group';
    }
    ngOnInit() {
        this.addClasses();
    }
    addClasses() {
        this.setClasses();
        for (const [key, value] of Object.entries(this.classes)) {
            if (value) {
                this.renderer.addClass(this.host, key);
            }
        }
    }
    setClasses() {
        this.classes['btn-group-vertical'] = Boolean(this.vertical) || this.vertical != null;
        this.classes['btn-group'] = !this.classes['btn-group-vertical'];
        this.classes[`btn-group-${this.size}`] = Boolean(this.size);
    }
}
ButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-button-group',
                template: '<ng-content></ng-content>',
                styles: [""]
            },] }
];
ButtonGroupComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ButtonGroupComponent.propDecorators = {
    size: [{ type: Input }],
    vertical: [{ type: Input }],
    aria: [{ type: HostBinding, args: ['attr.aria-label',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }]
};

class ButtonToolbarComponent {
    constructor() {
        this.justify = '';
        this.class = '';
        this.classes = Object.create(null);
        this.aria = 'Button toolbar';
    }
    get hostRole() {
        return 'toolbar';
    }
    get hostClasses() {
        return this.getClasses();
    }
    ngOnInit() {
    }
    getClasses() {
        this.classes['btn-toolbar'] = true;
        this.classes[`justify-content-start`] = this.justify === 'start';
        this.classes[`justify-content-end`] = this.justify === 'end';
        this.classes[`justify-content-center}`] = this.justify === 'center';
        this.classes[`justify-content-between`] = this.justify === 'between';
        return classNames(this.classes, this.class, this.ngClass);
    }
}
ButtonToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-button-toolbar',
                template: '<ng-content></ng-content>',
                styles: [":host{display:flex}"]
            },] }
];
ButtonToolbarComponent.ctorParameters = () => [];
ButtonToolbarComponent.propDecorators = {
    justify: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    aria: [{ type: HostBinding, args: ['attr.aria-label',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    hostClasses: [{ type: HostBinding, args: ['class',] }]
};

const RADIO_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ButtonRadioGroupDirective),
    multi: true
};
class ButtonRadioGroupDirective {
    constructor(cdr) {
        this.cdr = cdr;
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    writeValue(value) {
        this._value = value;
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
ButtonRadioGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cButtonRadioGroup]',
                providers: [RADIO_CONTROL_VALUE_ACCESSOR]
            },] }
];
ButtonRadioGroupDirective.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

const RADIO_CONTROL_VALUE_ACCESSOR$1 = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ButtonRadioDirective),
    multi: true
};
class ButtonRadioDirective {
    constructor(el, cdr, group, renderer) {
        this.el = el;
        this.cdr = cdr;
        this.group = group;
        this.renderer = renderer;
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
    }
    get value() {
        return this.group ? this.group.value : this._value;
    }
    set value(value) {
        if (this.group) {
            this.group.value = value;
            return;
        }
        this._value = value;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        this._disabled = disabled;
        this.setDisabledState(disabled);
    }
    get isActive() {
        return this.btnRadio === this.value;
    }
    onClick() {
        if (this.el.nativeElement.attributes.disabled || !this.uncheckable && this.btnRadio === this.value) {
            return;
        }
        this.value = this.uncheckable && this.btnRadio === this.value ? undefined : this.btnRadio;
        this._onChange(this.value);
    }
    ngOnInit() {
        this.uncheckable = typeof this.uncheckable !== 'undefined';
    }
    onBlur() {
        this.onTouched();
    }
    _onChange(value) {
        if (this.group) {
            this.group.onTouched();
            this.group.onChange(value);
            return;
        }
        this.onTouched();
        this.onChange(value);
    }
    writeValue(value) {
        this.value = value;
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(disabled) {
        if (disabled) {
            this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');
            return;
        }
        this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
    }
}
ButtonRadioDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cBtnRadio]',
                exportAs: 'cBtnRadio',
                providers: [RADIO_CONTROL_VALUE_ACCESSOR$1]
            },] }
];
ButtonRadioDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ButtonRadioGroupDirective, decorators: [{ type: Optional }] },
    { type: Renderer2 }
];
ButtonRadioDirective.propDecorators = {
    btnRadio: [{ type: Input }],
    uncheckable: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    isActive: [{ type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['attr.aria-pressed',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

class ButtonModule {
}
ButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ButtonComponent,
                    ButtonDirective,
                    ButtonGroupComponent,
                    ButtonToolbarComponent,
                    ButtonRadioDirective,
                    ButtonRadioGroupDirective
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    ButtonComponent,
                    ButtonDirective,
                    ButtonGroupComponent,
                    ButtonToolbarComponent,
                    ButtonRadioDirective,
                    ButtonRadioGroupDirective
                ]
            },] }
];

class CalloutComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'c-callout': true,
            [`c-callout-${this.color}`]: !!this.color
        });
        return classes;
    }
}
CalloutComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-callout, [c-callout]',
                template: `<ng-content></ng-content>`,
                styles: [":host{display:block}"]
            },] }
];
CalloutComponent.ctorParameters = () => [];
CalloutComponent.propDecorators = {
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CalloutModule {
}
CalloutModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CalloutComponent],
                exports: [CalloutComponent],
                imports: [
                    CommonModule
                ]
            },] }
];

class NoZoneBaseChartDirective extends BaseChartDirective {
    constructor(element, themeService, zone) {
        super(element, themeService);
        this.zone = zone;
        const refresh = this.refresh;
        this.refresh = () => {
            this.zone.runOutsideAngular(refresh.bind(this));
        };
    }
}
NoZoneBaseChartDirective.decorators = [
    { type: Directive, args: [{
                selector: 'canvas[cNoZoneBaseChart]',
                exportAs: 'base-chart'
            },] }
];
NoZoneBaseChartDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ThemeService },
    { type: NgZone }
];

class ChartModule {
}
ChartModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NoZoneBaseChartDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    NoZoneBaseChartDirective
                ]
            },] }
];

class CarouselService {
    constructor() {
        this.carouselIndex = new BehaviorSubject({});
        this.carouselIndex$ = this.carouselIndex.asObservable();
    }
    setIndex(index) {
        this.carouselIndex.next(index);
    }
}
CarouselService.decorators = [
    { type: Injectable }
];
CarouselService.ctorParameters = () => [];

class CarouselState {
    constructor(carouselService) {
        this.carouselService = carouselService;
        this._state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
        };
    }
    get state() {
        return this._state;
    }
    set state(state) {
        const prevState = Object.assign({}, this._state);
        const nextState = Object.assign(Object.assign({}, this._state), state);
        this._state = nextState;
        if (prevState.activeItemIndex !== nextState.activeItemIndex) {
            this.carouselService.setIndex({ active: nextState.activeItemIndex });
        }
    }
    setItems(newItems) {
        if (newItems.length) {
            const itemsArray = newItems.toArray();
            itemsArray.forEach((item, i) => {
                item.index = i;
            });
            this.state = {
                items: itemsArray,
            };
        }
        else {
            this.reset();
        }
    }
    setNextIndex(nextIndex) {
        this.carouselService.setIndex(nextIndex);
    }
    direction(direction = 'next') {
        this.state = { direction };
        const { activeItemIndex, items } = this.state;
        const itemsCount = items.length;
        return direction === 'next' ?
            (activeItemIndex === itemsCount - 1 ? 0 : activeItemIndex + 1) :
            (activeItemIndex === 0 ? itemsCount - 1 : activeItemIndex - 1);
    }
    reset() {
        this.state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
        };
    }
}
CarouselState.decorators = [
    { type: Injectable }
];
CarouselState.ctorParameters = () => [
    { type: CarouselService }
];

class CarouselConfig {
    constructor() {
        this.activeIndex = 0;
        this.animate = true;
        this.direction = 'next';
        this.interval = 3000;
    }
}
CarouselConfig.decorators = [
    { type: Injectable }
];

class CarouselComponent {
    constructor(config, carouselService, carouselState) {
        this.config = config;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.activeIndex = 0;
        this.animate = true;
        this.direction = 'next';
        this.interval = 0;
        this.itemChange = new EventEmitter();
        this.carouselClass = true;
        this.carouselSlideClass = true;
        Object.assign(this, config);
    }
    onMouseenter($event) {
        this.resetTimer();
    }
    onMouseleave($event) {
        this.setTimer();
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    ngAfterContentInit() {
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setTimer();
    }
    setTimer() {
        this.resetTimer();
        if (this.interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, this.interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                if ('active' in nextIndex) {
                    this.setTimer();
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel',
                template: "<ng-content></ng-content>\n",
                providers: [CarouselService, CarouselState, CarouselConfig],
                styles: [":host{display:block}"]
            },] }
];
CarouselComponent.ctorParameters = () => [
    { type: CarouselConfig, decorators: [{ type: Inject, args: [CarouselConfig,] }] },
    { type: CarouselService },
    { type: CarouselState }
];
CarouselComponent.propDecorators = {
    activeIndex: [{ type: Input }],
    animate: [{ type: Input }],
    direction: [{ type: Input }],
    interval: [{ type: Input }],
    itemChange: [{ type: Output }],
    carouselClass: [{ type: HostBinding, args: ['class.carousel',] }],
    carouselSlideClass: [{ type: HostBinding, args: ['class.slide',] }],
    onMouseenter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] }],
    onMouseleave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] }]
};

class CarouselCaptionComponent {
    constructor() {
        this.carouselCaptionClass = true;
    }
    ngOnInit() {
    }
}
CarouselCaptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel-caption',
                template: "<ng-content></ng-content>\n\n",
                styles: [""]
            },] }
];
CarouselCaptionComponent.ctorParameters = () => [];
CarouselCaptionComponent.propDecorators = {
    carouselCaptionClass: [{ type: HostBinding, args: ['class.carousel-caption',] }]
};

class CarouselControlComponent {
    constructor(changeDetector, carouselState) {
        this.changeDetector = changeDetector;
        this.carouselState = carouselState;
        this.direction = 'next';
        this.hasContent = true;
    }
    get hostRole() {
        return 'button';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get carouselControlClass() {
        return `carousel-control-${this.direction}`;
    }
    get carouselControlIconClass() {
        return `carousel-control-${this.direction}-icon`;
    }
    get hostClasses() {
        const classes = classNames(this.carouselControlClass);
        return classes;
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.play();
        }
        if ($event.key === 'ArrowLeft') {
            this.play('prev');
        }
        if ($event.key === 'ArrowRight') {
            this.play('next');
        }
    }
    onClick($event) {
        this.play();
    }
    ngOnInit() { }
    ngAfterViewInit() {
        this.hasContent = this.content.nativeElement.childNodes.length;
        this.changeDetector.detectChanges();
    }
    play(direction = this.direction) {
        const nextIndex = this.carouselState.direction(direction);
        this.carouselState.state = { activeItemIndex: nextIndex };
    }
}
CarouselControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel-control',
                template: "<div #content *ngIf = \"hasContent; else default\"><ng-content></ng-content></div>\n<ng-template #default>\n  <span [class]=\"carouselControlIconClass\" [attr.aria-label]=\"direction\"></span>\n</ng-template>\n",
                styles: [""]
            },] }
];
CarouselControlComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: CarouselState }
];
CarouselControlComponent.propDecorators = {
    direction: [{ type: Input }],
    content: [{ type: ViewChild, args: ['content',] }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class CarouselIndicatorsComponent {
    constructor(carouselService, carouselState) {
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.items = [];
        this.active = 0;
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    onClick(index) {
        if (index !== this.active) {
            const direction = index < this.active ? 'prev' : 'next';
            this.carouselState.state = { direction, activeItemIndex: index };
        }
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                var _a, _b, _c;
                this.items = (_c = (_b = (_a = this.carouselState) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.map(item => item.index);
                if ('active' in nextIndex) {
                    this.active = nextIndex.active;
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselIndicatorsComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel-indicators',
                template: "<ol class=\"carousel-indicators\">\n  <ng-container *ngFor=\"let item of items; let i=index\">\n    <li (click)=\"onClick(i)\" [class]=\"{active: active === i}\"></li>\n  </ng-container>\n</ol>\n",
                styles: [""]
            },] }
];
CarouselIndicatorsComponent.ctorParameters = () => [
    { type: CarouselService },
    { type: CarouselState }
];

function toLeft(fromState, toState) {
    return toState.left === true;
}
function toRight(fromState, toState) {
    return toState.left === false;
}
const slideAnimation = trigger('slideAnimation', [
    state('*', style({ transform: 'translateX(0)', display: 'block', opacity: 1 })),
    transition(toLeft, group([
        query(':leave', [
            animate('0.6s ease-in-out', style({
                transform: 'translateX(-100%)',
            })),
        ], { optional: true }),
        query(':enter', [
            style({
                transform: 'translateX(100%)',
            }),
            animate('0.6s ease-in-out', style('*')),
        ], { optional: true }),
    ])),
    transition(toRight, group([
        query(':enter', [
            style({
                transform: 'translateX(-100%)',
            }),
            animate('0.6s ease-in-out', style('*')),
        ], { optional: true }),
        query(':leave', [
            animate('0.6s ease-in-out', style({
                transform: 'translateX(100%)',
            })),
        ], { optional: true }),
    ])),
]);

class CarouselItemComponent {
    constructor(carouselService) {
        this.carouselService = carouselService;
    }
    set active(active) {
        this._active = active;
    }
    get active() {
        return this._active;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'carousel-item': true,
            active: this.active,
        });
        return classes;
    }
    ngOnInit() { }
    ngOnDestroy() {
        this.carouselStateSubscribe(false);
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.carouselStateSubscribe();
        });
    }
    carouselStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.carouselIndexSubscription = this.carouselService.carouselIndex$.subscribe((nextIndex) => {
                if ('active' in nextIndex) {
                    this.active = nextIndex.active === this.index;
                }
            });
        }
        else {
            this.carouselIndexSubscription.unsubscribe();
        }
    }
}
CarouselItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel-item',
                template: "<ng-content *ngIf=\"active\"></ng-content>\n",
                styles: [":host{display:block}"]
            },] }
];
CarouselItemComponent.ctorParameters = () => [
    { type: CarouselService }
];
CarouselItemComponent.propDecorators = {
    active: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class CarouselInnerComponent {
    constructor(carouselState) {
        this.carouselState = carouselState;
        this.carouselInnerClass = true;
        this.slide = { left: true };
    }
    ngOnInit() { }
    ngAfterContentInit() {
        this.setItems();
    }
    ngAfterContentChecked() {
        var _a;
        this.setItems();
        const state = (_a = this.carouselState) === null || _a === void 0 ? void 0 : _a.state;
        const nextIndex = state === null || state === void 0 ? void 0 : state.activeItemIndex;
        const nextDirection = state === null || state === void 0 ? void 0 : state.direction;
        if (this.activeIndex !== nextIndex) {
            this.animate = state === null || state === void 0 ? void 0 : state.animate;
            this.slide = { left: nextDirection === 'next' };
            this.activeIndex = state === null || state === void 0 ? void 0 : state.activeItemIndex;
        }
    }
    setItems() {
        if (this.prevContentItems !== this.contentItems) {
            this.prevContentItems = this.contentItems;
            this.carouselState.setItems(this.contentItems);
        }
    }
}
CarouselInnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-carousel-inner',
                template: "<div [@slideAnimation]=\"slide\" [@.disabled]=\"!animate\">\n  <ng-content></ng-content>\n</div>\n",
                animations: [slideAnimation],
                styles: [":host{display:block}"]
            },] }
];
CarouselInnerComponent.ctorParameters = () => [
    { type: CarouselState }
];
CarouselInnerComponent.propDecorators = {
    carouselInnerClass: [{ type: HostBinding, args: ['class.carousel-inner',] }],
    contentItems: [{ type: ContentChildren, args: [CarouselItemComponent,] }]
};

class CarouselModule {
    static forRoot() {
        return { ngModule: CarouselModule, providers: [] };
    }
}
CarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CarouselComponent,
                    CarouselCaptionComponent,
                    CarouselControlComponent,
                    CarouselIndicatorsComponent,
                    CarouselInnerComponent,
                    CarouselItemComponent,
                ],
                imports: [CommonModule],
                providers: [CarouselService, CarouselState, CarouselConfig],
                exports: [
                    CarouselComponent,
                    CarouselCaptionComponent,
                    CarouselControlComponent,
                    CarouselIndicatorsComponent,
                    CarouselInnerComponent,
                    CarouselItemComponent,
                ],
            },] }
];

class DropdownService {
    constructor() {
        this.dropdownState = new BehaviorSubject({});
        this.dropdownState$ = this.dropdownState.asObservable();
    }
    toggle(state) {
        this.dropdownState.next(state);
    }
}
DropdownService.ɵprov = ɵɵdefineInjectable({ factory: function DropdownService_Factory() { return new DropdownService(); }, token: DropdownService, providedIn: "root" });
DropdownService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DropdownService.ctorParameters = () => [];

class DropdownState {
    constructor() {
        this.state = {
            align: '',
            caret: 'caret',
            direction: 'down',
            show: false,
        };
    }
    getState() {
        return Object.assign(Object.create(null), this.state);
    }
    setState(state) {
        this.state = Object.assign(this.state, state);
        return this.getState();
    }
}
DropdownState.decorators = [
    { type: Injectable }
];
DropdownState.ctorParameters = () => [];

class DropdownDirective {
    constructor(renderer, hostElement, outClickService, dropdownService, dropdownState) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.outClickService = outClickService;
        this.dropdownService = dropdownService;
        this.dropdownState = dropdownState;
        this.direction = 'down';
        this.cDropdownAlign = '';
    }
    ngOnInit() {
        const state = { show: this.cDropdownShow, align: this.cDropdownAlign, direction: this.direction };
        this.state = this.dropdownState.setState(state);
        const dropdownClass = `drop${this.direction || 'down'}`;
        this.renderer.addClass(this.hostElement.nativeElement, dropdownClass);
        this.stateToggleSubscribe();
        this.outClickSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.outClickSubscribe(false);
    }
    ngOnChanges(changes) {
        if (changes.direction) {
            this.renderer.removeClass(this.hostElement.nativeElement, `drop${changes.direction.previousValue || 'down'}`);
            this.renderer.addClass(this.hostElement.nativeElement, `drop${changes.direction.currentValue || 'down'}`);
        }
        if (changes.cDropdownShow) {
            const state = { show: changes.cDropdownShow.currentValue };
            this.state = this.dropdownState.setState(state);
            this.dropdownService.toggle(this.state);
        }
    }
    ngAfterViewInit() {
        this.cDropdownShow = this.state.show;
        this.dropdownService.toggle(this.state);
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.dropdownService.dropdownState$.subscribe((state) => {
                if ('show' in state) {
                    this.show(state.show);
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
    show(show) {
        this.cDropdownShow = show;
        this.state = this.dropdownState.setState({ show });
        show ?
            this.renderer.addClass(this.hostElement.nativeElement, 'show') :
            this.renderer.removeClass(this.hostElement.nativeElement, 'show');
    }
    toggle() {
        this.show(!this.state.show);
    }
    outClickSubscribe(subscribe = true) {
        if (subscribe) {
            this.outClickSubscription = this.outClickService.outClick$.subscribe(message => {
                if (message.event) {
                    this.autoClose(message.event);
                }
            });
        }
        else {
            this.outClickSubscription.unsubscribe();
        }
    }
    autoClose(e) {
        const state = this.dropdownState.getState();
        if (state.show) {
            if (!this.hostElement.nativeElement.contains(e.target.closest('[cDropdownToggle]'))) {
                this.cDropdownShow = false;
                this.dropdownService.toggle({ show: false });
            }
        }
    }
}
DropdownDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdown], c-dropdown',
                exportAs: 'cDropdown',
                providers: [DropdownService, DropdownState],
            },] }
];
DropdownDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: OutClickService },
    { type: DropdownService },
    { type: DropdownState }
];
DropdownDirective.propDecorators = {
    direction: [{ type: Input, args: ['cDropdown',] }],
    cDropdownAlign: [{ type: Input }],
    cDropdownShow: [{ type: Input }, { type: HostBinding, args: ['attr.aria-expanded',] }]
};

class DropdownMenuDirective {
    constructor(renderer, hostElement, dropdownState, dropdownService) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.dropdownState = dropdownState;
        this.dropdownService = dropdownService;
        this.role = 'menu';
        this.dropdownMenu = true;
        this.host = this.hostElement.nativeElement;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
    }
    show(show) {
        const className = 'show';
        show ?
            this.renderer.addClass(this.host, className) :
            this.renderer.removeClass(this.host, className);
    }
    align(align) {
        if (align) {
            const className = `dropdown-menu-${align}`;
            this.renderer.addClass(this.host, className);
        }
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.dropdownService.dropdownState$.subscribe((state) => {
                if ('show' in state) {
                    this.show(state.show);
                }
                if ('align' in state) {
                    this.align(state.align);
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
}
DropdownMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdownMenu], c-dropdown-menu',
                exportAs: 'cDropdownMenu'
            },] }
];
DropdownMenuDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DropdownState },
    { type: DropdownService }
];
DropdownMenuDirective.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    dropdownMenu: [{ type: HostBinding, args: ['class.dropdown-menu',] }]
};

class DropdownToggleDirective {
    constructor(renderer, hostElement, dropdown, dropdownService, dropdownState) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.dropdown = dropdown;
        this.dropdownService = dropdownService;
        this.dropdownState = dropdownState;
        this.cDropdownCaret = 'caret';
        this.host = this.hostElement.nativeElement;
    }
    ngOnInit() {
        this.state = this.dropdownState.setState({ caret: this.cDropdownCaret });
        const toggleClass = 'dropdown-toggle';
        if (this.state.caret === 'none') {
            this.renderer.removeClass(this.host, toggleClass);
        }
        else {
            this.renderer.addClass(this.host, toggleClass);
            if (this.state.caret === 'split') {
                this.renderer.addClass(this.host, `${toggleClass}-split`);
            }
        }
    }
    toggleShow($event) {
        $event.preventDefault();
        this.state = this.dropdownState.getState();
        this.dropdownService.toggle({ show: !this.state.show });
    }
}
DropdownToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdownToggle], c-dropdown-toggle',
                exportAs: 'cDropdownToggle',
            },] }
];
DropdownToggleDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DropdownDirective },
    { type: DropdownService },
    { type: DropdownState }
];
DropdownToggleDirective.propDecorators = {
    cDropdownCaret: [{ type: Input }],
    toggleShow: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class DropdownHeaderDirective {
    constructor() {
        this.dropdownHeader = true;
    }
}
DropdownHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdownHeader], c-dropdown-header',
                exportAs: 'cDropdownHeader'
            },] }
];
DropdownHeaderDirective.propDecorators = {
    dropdownHeader: [{ type: HostBinding, args: ['class.dropdown-header',] }]
};

class DropdownDividerDirective {
    constructor() {
        this.dropdownDivider = true;
    }
}
DropdownDividerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdownDivider], c-dropdown-divider',
                exportAs: 'cDropdownDivider'
            },] }
];
DropdownDividerDirective.propDecorators = {
    dropdownDivider: [{ type: HostBinding, args: ['class.dropdown-divider',] }]
};

class DropdownItemDirective {
    constructor() {
        this.dropdownItem = true;
    }
}
DropdownItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cDropdownItem], c-dropdown-item',
                exportAs: 'cDropdownItem',
            },] }
];
DropdownItemDirective.propDecorators = {
    dropdownItem: [{ type: HostBinding, args: ['class.dropdown-item',] }]
};

class DropdownDividerComponent {
}
DropdownDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-dropdown-divider',
                template: '<div class="dropdown-divider"></div>',
                styles: [""]
            },] }
];

class DropdownModule {
    static forRoot(config) {
        return {
            ngModule: DropdownModule,
            providers: []
        };
    }
}
DropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DropdownDirective,
                    DropdownToggleDirective,
                    DropdownMenuDirective,
                    DropdownHeaderDirective,
                    DropdownDividerDirective,
                    DropdownItemDirective,
                    DropdownDividerComponent
                ],
                exports: [
                    DropdownDirective,
                    DropdownToggleDirective,
                    DropdownMenuDirective,
                    DropdownItemDirective,
                    DropdownDividerDirective,
                    DropdownHeaderDirective,
                    DropdownDividerComponent
                ],
                imports: [
                    CommonModule
                ],
                providers: [
                    DropdownService,
                    DropdownState
                ]
            },] }
];

class EmbedItemDirective {
    constructor() {
        this.embedItemClass = true;
    }
}
EmbedItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cEmbedItem]'
            },] }
];
EmbedItemDirective.ctorParameters = () => [];
EmbedItemDirective.propDecorators = {
    embedItemClass: [{ type: HostBinding, args: ['class.embed-responsive-item',] }]
};

class EmbedComponent {
    constructor() {
        this.ratio = '16by9';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'embed-responsive': true,
            [`embed-responsive-${this.ratio}`]: !!this.ratio,
        });
        return classes;
    }
    ngOnInit() { }
    ngAfterContentInit() {
    }
}
EmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-embed',
                template: "<ng-content select=\"iframe\"></ng-content>\n",
                styles: [""]
            },] }
];
EmbedComponent.ctorParameters = () => [];
EmbedComponent.propDecorators = {
    ratio: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    embedItem: [{ type: ContentChild, args: [EmbedItemDirective,] }]
};

class EmbedModule {
}
EmbedModule.decorators = [
    { type: NgModule, args: [{
                declarations: [EmbedComponent, EmbedItemDirective],
                imports: [CommonModule],
                exports: [EmbedComponent, EmbedItemDirective],
            },] }
];

function chkBoolProp(prop) {
    return Boolean(prop != null && prop !== false);
}

class FormDirective {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-inline': chkBoolProp(this.inline),
            'was-validated': chkBoolProp(this.wasValidated),
        };
        return classes;
    }
}
FormDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cForm]'
            },] }
];
FormDirective.ctorParameters = () => [];
FormDirective.propDecorators = {
    inline: [{ type: Input }],
    wasValidated: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class FormGroupComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-group': true,
            disabled: chkBoolProp(this.disabled)
        };
        return classes;
    }
    ngOnInit() {
    }
}
FormGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-form-group',
                template: "<ng-content></ng-content>\n",
                styles: [":host:not(.row):not(.form-check-inline):not(.custom-control-inline){display:block}"]
            },] }
];
FormGroupComponent.ctorParameters = () => [];
FormGroupComponent.propDecorators = {
    inline: [{ type: Input }],
    disabled: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class FormFeedbackComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const validMode = this.tooltip ? 'tooltip' : 'feedback';
        const classes = {
            [`valid-${validMode}`]: this.valid === true,
            [`invalid-${validMode}`]: this.valid !== true,
        };
        return classes;
    }
}
FormFeedbackComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-form-feedback',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
FormFeedbackComponent.ctorParameters = () => [];
FormFeedbackComponent.propDecorators = {
    valid: [{ type: Input }],
    tooltip: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class FormTextComponent {
    constructor() {
        this.tag = 'small';
        this.color = 'muted';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'form-text': true,
            [`${this.tag}`]: true,
            [`text-${this.color}`]: !!this.color,
        };
        return classes;
    }
}
FormTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-form-text',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
FormTextComponent.ctorParameters = () => [];
FormTextComponent.propDecorators = {
    tag: [{ type: Input }],
    color: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class InputDirective {
    constructor(hostElement) {
        this.hostElement = hostElement;
        this.sizing = '';
        this.type = 'text';
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isPlainText = this.isPlainText;
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'form-control': !isPlainText && this.isFormControl,
            'form-control-plaintext': isPlainText,
            'form-control-range': this.type === 'range',
            'form-control-file': this.type === 'file' && !isCustom,
            'custom-file-input': this.type === 'file' && isCustom,
            'form-check-input': this.isFormCheck && !isCustom,
            'custom-control-input': this.isFormCheck && isCustom,
            [`form-control-${this.sizing}`]: !!this.sizing,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
    get isPlainText() {
        return chkBoolProp(this.plaintext);
    }
    get isFormControl() {
        const nonTextControls = ['range', 'checkbox', 'radio', 'file'];
        return !nonTextControls.includes(this.type);
    }
    get isFormCheck() {
        const formCheck = ['checkbox', 'radio'];
        return formCheck.includes(this.type);
    }
    ngOnInit() { }
    get attributes() {
        return this.host.getAttributeNames();
    }
    get isReadonly() {
        return this.host.getAttribute('readonly') != null;
    }
    get isDisabled() {
        return this.host.getAttribute('disabled') != null;
    }
}
InputDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cInput]',
            },] }
];
InputDirective.ctorParameters = () => [
    { type: ElementRef }
];
InputDirective.propDecorators = {
    valid: [{ type: Input }],
    plaintext: [{ type: Input }],
    sizing: [{ type: Input }],
    custom: [{ type: Input }],
    type: [{ type: HostBinding, args: ['type',] }, { type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class InputGroupComponent {
    constructor() {
        this.size = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'input-group': true,
            [`input-group-${this.size}`]: !!this.size,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-input-group',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
InputGroupComponent.ctorParameters = () => [];
InputGroupComponent.propDecorators = {
    size: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class InputGroupTextComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = {
            'input-group-text': true,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-input-group-text',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
InputGroupTextComponent.ctorParameters = () => [];
InputGroupTextComponent.propDecorators = {
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class InputGroupAddonComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const addon = chkBoolProp(this.prepend) ? 'prepend' : 'append';
        const classes = {
            [`input-group-${addon}`]: true,
        };
        return classes;
    }
    ngOnInit() { }
}
InputGroupAddonComponent.decorators = [
    { type: Component, args: [{
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            },] }
];
InputGroupAddonComponent.ctorParameters = () => [];
InputGroupAddonComponent.propDecorators = {
    prepend: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};
class InputGroupPrependComponent extends InputGroupAddonComponent {
    constructor() {
        super(...arguments);
        this.prepend = true;
    }
}
InputGroupPrependComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-input-group-prepend',
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            },] }
];
class InputGroupAppendComponent extends InputGroupAddonComponent {
    constructor() {
        super(...arguments);
        this.prepend = false;
    }
}
InputGroupAppendComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-input-group-append',
                template: "<ng-content></ng-content>\n",
                styles: [":host ::ng-deep .btn:not(:hover):not(:focus){box-shadow:none!important}"]
            },] }
];

class TextareaDirective {
    constructor() {
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isPlainText = this.isPlainText;
        const classes = classNames({
            'form-control': !isPlainText,
            'form-control-plaintext': isPlainText,
            [`form-control-${this.sizing}`]: !!this.sizing,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
    get isPlainText() {
        return chkBoolProp(this.plaintext);
    }
}
TextareaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cTextarea]'
            },] }
];
TextareaDirective.propDecorators = {
    valid: [{ type: Input }],
    plaintext: [{ type: Input }],
    sizing: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SelectDirective {
    constructor() {
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'form-control': !isCustom,
            [`form-control-${this.sizing}`]: !!this.sizing && !isCustom,
            'custom-select': isCustom,
            [`custom-select-${this.sizing}`]: !!this.sizing && isCustom,
            'is-valid': this.valid === true,
            'is-invalid': this.valid === false,
        });
        return classes;
    }
}
SelectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cSelect]'
            },] }
];
SelectDirective.ctorParameters = () => [];
SelectDirective.propDecorators = {
    valid: [{ type: Input }],
    custom: [{ type: Input }],
    sizing: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class LabelDirective {
    constructor() {
        this.col = '';
        this.sizing = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const isCustom = chkBoolProp(this.custom);
        const classes = classNames({
            'custom-control-label': isCustom,
            'custom-file-label': isCustom && this.variant === 'file',
            'form-check-label': !isCustom && ['checkbox', 'radio', 'switch'].includes(this.variant),
            'sr-only': chkBoolProp(this.hidden),
            'visually-hidden': chkBoolProp(this.hidden),
            'col-form-label': this.col === 'col',
            [`col-form-label-${this.sizing}`]: !!this.sizing && this.col === 'col',
        });
        return classes;
    }
}
LabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cLabel]'
            },] }
];
LabelDirective.ctorParameters = () => [];
LabelDirective.propDecorators = {
    col: [{ type: Input, args: ['cLabel',] }],
    hidden: [{ type: Input }],
    variant: [{ type: Input }],
    sizing: [{ type: Input }],
    custom: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class FormCheckComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        if (this.variant === 'switch') {
            this.custom = true;
        }
        const variantClass = this.custom ? 'custom-control' : 'form-check';
        const isCustom = chkBoolProp(this.custom);
        const classes = {
            'form-check': !isCustom,
            'custom-control': isCustom,
            [`custom-${this.variant}`]: !!this.variant,
            [`${variantClass}-inline`]: chkBoolProp(this.inline),
            disabled: chkBoolProp(this.disabled)
        };
        return classes;
    }
    ngOnInit() {
    }
}
FormCheckComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-form-check',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
FormCheckComponent.ctorParameters = () => [];
FormCheckComponent.propDecorators = {
    custom: [{ type: Input }],
    disabled: [{ type: Input }],
    inline: [{ type: Input }],
    variant: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class FormModule {
}
FormModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FormDirective,
                    FormCheckComponent,
                    FormFeedbackComponent,
                    FormGroupComponent,
                    FormTextComponent,
                    InputDirective,
                    InputGroupComponent,
                    InputGroupTextComponent,
                    InputGroupAddonComponent,
                    InputGroupPrependComponent,
                    InputGroupAppendComponent,
                    TextareaDirective,
                    SelectDirective,
                    LabelDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    FormDirective,
                    FormCheckComponent,
                    FormFeedbackComponent,
                    FormGroupComponent,
                    FormTextComponent,
                    InputDirective,
                    InputGroupComponent,
                    InputGroupTextComponent,
                    InputGroupPrependComponent,
                    InputGroupAppendComponent,
                    TextareaDirective,
                    SelectDirective,
                    LabelDirective
                ]
            },] }
];

class ContainerComponent {
    constructor() {
        this.fluid = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            container: !this.fluid,
            'container-fluid': !!this.fluid
        });
        return classes;
    }
}
ContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-container, [cContainer]',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            },] }
];
ContainerComponent.propDecorators = {
    fluid: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class RowDirective {
    constructor() {
        this.noGutters = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const alignV = `align-items-${this.alignV}`;
        const alignH = `justify-content-${this.alignH}`;
        const classes = { row: true };
        classes['no-gutters'] = !!this.noGutters;
        classes[alignV] = !!this.alignV;
        classes[alignH] = !!this.alignH;
        return classNames(classes);
    }
}
RowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cRow]'
            },] }
];
RowDirective.propDecorators = {
    noGutters: [{ type: Input }],
    alignV: [{ type: Input }],
    alignH: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class RowComponent extends RowDirective {
}
RowComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-row',
                template: '<ng-content></ng-content>',
                styles: [""]
            },] }
];

class ColDirective {
    constructor() {
        this.suffix = {
            xs: '-xs',
            sm: '-sm',
            md: '-md',
            lg: '-lg',
            xl: '-xl',
            xxl: '-xxl',
            col: ''
        };
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        let classes = Object.create(null);
        const suffix = this.suffix;
        let addColClass = false;
        Object.keys(suffix).forEach((key) => {
            const prop = this[key];
            const breakpoint = suffix[key];
            classes[`col${breakpoint}`] = prop === true;
            classes[`col${breakpoint}-${prop}`] = (typeof prop === 'number') || (typeof prop === 'string');
            if (typeof prop === 'object') {
                classes[`col${breakpoint}-${prop.size}`] = !!prop.size;
                classes[`offset${breakpoint}-${prop.offset}`] = !!prop.offset;
                classes[`order${breakpoint}-${prop.order}`] = !!prop.order;
                addColClass = addColClass || !!prop.offset || !!prop.order;
            }
        });
        classes = classNames(addColClass ? 'col' : '', classes);
        return classes || 'col';
    }
}
ColDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cCol]'
            },] }
];
ColDirective.propDecorators = {
    xs: [{ type: Input }],
    sm: [{ type: Input }],
    md: [{ type: Input }],
    lg: [{ type: Input }],
    xl: [{ type: Input }],
    xxl: [{ type: Input }],
    col: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ColComponent extends ColDirective {
}
ColComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-col',
                template: '<ng-content></ng-content>',
                styles: [":host{display:block}"]
            },] }
];

class GridModule {
}
GridModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    ContainerComponent,
                    RowComponent,
                    ColComponent,
                    RowDirective,
                    ColDirective,
                ],
                declarations: [
                    ContainerComponent,
                    RowComponent,
                    ColComponent,
                    RowDirective,
                    ColDirective,
                ],
                providers: [],
            },] }
];

class ImgDirective {
    constructor() {
        this.align = '';
        this.placeholderColor = 'transparent';
    }
    get getStyles() {
        return { backgroundColor: this.placeholderColor };
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.alignClass, {
            'img-thumbnail': this.thumbnail,
            'img-fluid': this.fluid || this.fluidGrow,
            'w-100': this.fluidGrow,
            'd-block': this.block,
            [`${this.shape}`]: this.shape,
        });
        return classes;
    }
    get alignClass() {
        return this.align === 'center' ? 'mx-auto' :
            this.align === 'right' ? 'float-right' :
                this.align === 'left' ? 'float-left' : '';
    }
    ngOnInit() { }
}
ImgDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cImg]'
            },] }
];
ImgDirective.ctorParameters = () => [];
ImgDirective.propDecorators = {
    block: [{ type: Input }],
    fluid: [{ type: Input }],
    fluidGrow: [{ type: Input }],
    shape: [{ type: Input }],
    thumbnail: [{ type: Input }],
    align: [{ type: Input }],
    placeholderColor: [{ type: Input }],
    getStyles: [{ type: HostBinding, args: ['style',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ImgModule {
}
ImgModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    ImgDirective
                ],
                declarations: [
                    ImgDirective
                ],
            },] }
];

class BodyComponent {
    constructor() {
        this.bodyClass = true;
    }
}
BodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-body, [c-body]',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:flex;flex-direction:column}"]
            },] }
];
BodyComponent.propDecorators = {
    bodyClass: [{ type: HostBinding, args: ['class.c-body',] }]
};

class FooterComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.fixedClass = 'c-footer-fixed';
        renderer.addClass(hostElement.nativeElement, 'c-footer');
    }
    ngOnInit() {
        this.isFixed(this.fixed);
    }
    ngOnDestroy() {
        this.renderer.removeClass(this.hostElement.nativeElement, this.fixedClass);
    }
    isFixed(fixed = this.fixed) {
        if (fixed) {
            this.renderer.addClass(this.hostElement.nativeElement, this.fixedClass);
        }
    }
}
FooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-footer, [c-footer]',
                template: `<ng-content></ng-content>`,
                styles: [""]
            },] }
];
FooterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FooterComponent.propDecorators = {
    fixed: [{ type: Input }]
};

class HeaderComponent {
    constructor() {
        this.colorScheme = 'light';
        this.fixed = true;
        this.role = 'header';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-header': true,
            'c-header-fixed': this.fixed,
        }, `c-header-${this.colorScheme}`);
        return classes;
    }
}
HeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-header, [c-header]',
                template: `<ng-content></ng-content>`,
                styles: [""]
            },] }
];
HeaderComponent.ctorParameters = () => [];
HeaderComponent.propDecorators = {
    colorScheme: [{ type: Input }],
    fixed: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SidebarService {
    constructor() {
        this.sidebarState = new BehaviorSubject({});
        this.sidebarState$ = this.sidebarState.asObservable();
    }
    toggle(action) {
        this.sidebarState.next(action);
    }
}
SidebarService.ɵprov = ɵɵdefineInjectable({ factory: function SidebarService_Factory() { return new SidebarService(); }, token: SidebarService, providedIn: "root" });
SidebarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SidebarService.ctorParameters = () => [];

class HeaderBrandComponent {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
        this.routerLink = '';
        this.minimized = false;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
    }
    minimize(force) {
        this.minimized = (force === 'toggle') ? !this.minimized : force;
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.sidebarService.sidebarState$.subscribe((state) => {
                if (!state.id) {
                    if ('minimize' in state) {
                        this.minimize(state.minimize);
                    }
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
}
HeaderBrandComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-header-brand',
                template: "<a class=\"c-header-brand\" [routerLink]=\"routerLink\" role=\"button\">\r\n  <ng-template [ngIf]=\"minimized\">\r\n    <ng-content></ng-content>\r\n  </ng-template>\r\n  <ng-template [ngIf]=\"!minimized\">\r\n    <ng-content></ng-content>\r\n  </ng-template>\r\n</a>\r\n\r\n"
            },] }
];
HeaderBrandComponent.ctorParameters = () => [
    { type: SidebarService }
];
HeaderBrandComponent.propDecorators = {
    routerLink: [{ type: Input }],
    minimized: [{ type: Input }]
};

class SubheaderComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-subheader': true,
        });
        return classes;
    }
    ngOnInit() {
    }
}
SubheaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-subheader, [c-subheader]',
                template: `<ng-content></ng-content>`
            },] }
];
SubheaderComponent.ctorParameters = () => [];
SubheaderComponent.propDecorators = {
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WrapperComponent {
    constructor() {
        this.fluid = false;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'c-wrapper': true,
            'c-wrapper-fluid': !!this.fluid
        });
        return classes;
    }
}
WrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-wrapper, [c-wrapper]',
                template: `<ng-content></ng-content>`
            },] }
];
WrapperComponent.propDecorators = {
    fluid: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class LayoutModule {
}
LayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                ],
                exports: [
                    BodyComponent,
                    FooterComponent,
                    HeaderComponent,
                    HeaderBrandComponent,
                    SubheaderComponent,
                    WrapperComponent
                ],
                declarations: [
                    FooterComponent,
                    HeaderComponent,
                    HeaderBrandComponent,
                    SubheaderComponent,
                    WrapperComponent,
                    BodyComponent,
                ],
                providers: []
            },] }
];

class ListGroupDirective {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'list-group': true,
            'list-group-horizontal': this.horizontal === true || this.horizontal === '',
            [`list-group-horizontal-${this.horizontal}`]: this.horizontal && this.horizontal !== true,
            'list-group-flush': !!this.flush,
            'list-group-accent': !!this.accent,
        });
        return classes;
    }
}
ListGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cListGroup], c-list-group'
            },] }
];
ListGroupDirective.ctorParameters = () => [];
ListGroupDirective.propDecorators = {
    horizontal: [{ type: Input }],
    accent: [{ type: Input }],
    flush: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ListGroupItemDirective {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.host = this.hostElement.nativeElement;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'list-group-item': true,
            'list-group-item-action': this.action,
            'list-group-item-divider': this.divider,
            active: this.active,
            disabled: this.disabled,
            [`list-group-item-${this.color}`]: !!this.color,
            [`list-group-item-accent-${this.accent}`]: !!this.accent
        });
        return classes;
    }
    ngOnInit() { }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.addClass(this.host, `list-group-item-${changes.color.currentValue}`);
            this.renderer.removeClass(this.host, `list-group-item-${changes.color.previousValue}`);
        }
        if (changes.accent) {
            this.renderer.addClass(this.host, `list-group-item-accent-${changes.accent.currentValue}`);
            this.renderer.removeClass(this.host, `list-group-item-accent-${changes.accent.previousValue}`);
        }
    }
}
ListGroupItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cListGroupItem], c-list-group-item',
                exportAs: 'cListGroupItem'
            },] }
];
ListGroupItemDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ListGroupItemDirective.propDecorators = {
    accent: [{ type: Input }],
    action: [{ type: Input }],
    active: [{ type: Input }],
    color: [{ type: Input }],
    divider: [{ type: Input }],
    disabled: [{ type: HostBinding, args: ['attr.disabled',] }, { type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ListGroupModule {
}
ListGroupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ListGroupDirective, ListGroupItemDirective],
                exports: [
                    ListGroupDirective,
                    ListGroupItemDirective
                ],
                imports: [
                    CommonModule
                ]
            },] }
];

class MediaDirective {
    constructor() {
        this.madiaClass = true;
    }
}
MediaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cMedia]',
            },] }
];
MediaDirective.propDecorators = {
    madiaClass: [{ type: HostBinding, args: ['class.media',] }]
};

class MediaComponent extends MediaDirective {
    constructor() {
        super();
    }
}
MediaComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-media',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
MediaComponent.ctorParameters = () => [];

class MediaBodyComponent {
    constructor() {
        this.mediaBodyClass = true;
    }
}
MediaBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-media-body',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
MediaBodyComponent.propDecorators = {
    mediaBodyClass: [{ type: HostBinding, args: ['class.media-body',] }]
};

class MediaModule {
}
MediaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [MediaComponent, MediaBodyComponent, MediaDirective],
                imports: [CommonModule],
                exports: [MediaDirective, MediaComponent, MediaBodyComponent],
            },] }
];

class ModalComponent {
    constructor(document, renderer, elementRef, changeDetectorRef) {
        this.document = document;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.closeOnBackdrop = true;
        this.size = '';
        this.color = '';
        this.modalClasses = {
            modal: true,
            fade: true
        };
        this.dialogClasses = {
            'modal-dialog': true
        };
        this.backdropClasses = {
            'modal-backdrop': true,
            fade: true,
            show: true
        };
        this.visible = false;
        this.visibleAnimate = false;
    }
    ngOnInit() {
        this.setClasses();
    }
    ngOnDestroy() {
        this.hide();
    }
    setClasses() {
        this.dialogClasses[`modal-${this.size}`] = !!this.size;
        this.dialogClasses[`modal-${this.color}`] = !!this.color;
    }
    show() {
        this.renderer.addClass(this.document.body, 'modal-open');
        this.visible = true;
        this.modalClasses[`d-block`] = true;
        setTimeout(() => {
            this.visibleAnimate = true;
        });
    }
    hide() {
        this.renderer.removeClass(this.document.body, 'modal-open');
        this.visibleAnimate = false;
        setTimeout(() => {
            this.visible = false;
            this.modalClasses[`d-block`] = false;
            this.changeDetectorRef.markForCheck();
        }, 200);
    }
    onContainerClicked(event) {
        if (event.target.classList.contains('modal') && this.isTopmost() && this.closeOnBackdrop) {
            this.hide();
        }
    }
    onKeyDownHandler(event) {
        if (event.key === 'Escape' && this.isTopmost()) {
            this.hide();
        }
    }
    isTopmost() {
        const isTopmost = !this.elementRef.nativeElement.querySelector(':scope c-modal > .modal');
        return isTopmost;
    }
}
ModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-modal',
                template: "<div\n  role=\"dialog\"\n  tabindex=\"-1\"\n  [class.show]=\"visibleAnimate\"\n  [ngClass]=\"modalClasses\"\n  *ngIf=\"visible\">\n  <div [ngClass]=\"dialogClasses\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <ng-container *ngTemplateOutlet=\"header\" class=\"modal-title\"></ng-container>\n        <button class=\"close\" data-dismiss=\"modal\" type=\"button\" aria-label=\"Close\" (click)=\"hide()\">\u00D7</button>\n      </div>\n      <div class=\"modal-body\">\n        <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n      </div>\n      <div class=\"modal-footer\">\n        <ng-container *ngTemplateOutlet=\"footer\"></ng-container>\n      </div>\n    </div>\n  </div>\n</div>\n<div\n  *ngIf=\"visibleAnimate\"\n  [ngClass]=\"backdropClasses\">\n</div>\n",
                styles: [""]
            },] }
];
ModalComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
ModalComponent.propDecorators = {
    header: [{ type: ContentChild, args: ['modalHeader', { static: true },] }],
    body: [{ type: ContentChild, args: ['modalBody', { static: true },] }],
    footer: [{ type: ContentChild, args: ['modalFooter', { static: true },] }],
    closeOnBackdrop: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    onContainerClicked: [{ type: HostListener, args: ['click', ['$event'],] }],
    onKeyDownHandler: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

class ModalModule {
}
ModalModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ModalComponent],
                exports: [ModalComponent],
                imports: [
                    CommonModule
                ]
            },] }
];

class NavComponent {
    constructor() {
        this.variant = '';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const verticalSuffix = this.vertical === true ? '' : `-${this.vertical}`;
        const classes = classNames({
            nav: true,
            [`nav-${this.variant}`]: this.variant,
            [`flex${verticalSuffix}-column`]: this.vertical,
            'nav-fill': this.fill,
            'nav-justified': this.justified,
            [`card-header-${this.variant}`]: this.inCard && this.variant
        });
        return classes;
    }
    ngOnInit() { }
}
NavComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-nav',
                template: "<ng-content></ng-content>\n",
                styles: [":host>.nav-link:focus{outline:0}"]
            },] }
];
NavComponent.ctorParameters = () => [];
NavComponent.propDecorators = {
    variant: [{ type: Input }],
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    vertical: [{ type: Input }],
    inCard: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class NavItemComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'nav-item': true,
        });
        return classes;
    }
    ngOnInit() {
    }
}
NavItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-nav-item',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:list-item;text-align:match-parent}"]
            },] }
];
NavItemComponent.ctorParameters = () => [];
NavItemComponent.propDecorators = {
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class NavLinkDirective {
    constructor() {
        this.disabled = null;
        this.tabindex = null;
    }
    get isDisabled() {
        return (this.disabled !== 'false' && this.disabled !== false && this.disabled !== null) ? this.disabled : null;
    }
    get getTabindex() {
        return this.disabled ? null : this.tabindex != null ? this.tabindex : '0';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'nav-link': true,
            disabled: this.disabled,
            active: this.active
        });
        return classes;
    }
}
NavLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cNavLink]',
            },] }
];
NavLinkDirective.ctorParameters = () => [];
NavLinkDirective.propDecorators = {
    disabled: [{ type: Input }],
    tabindex: [{ type: Input }],
    active: [{ type: Input }],
    isDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    getTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class NavModule {
}
NavModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NavComponent, NavItemComponent, NavLinkDirective],
                imports: [
                    CommonModule
                ],
                exports: [NavComponent, NavItemComponent, NavLinkDirective]
            },] }
];

class NavbarComponent {
    constructor(hostElement, breakpointObserver) {
        this.hostElement = hostElement;
        this.breakpointObserver = breakpointObserver;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const expandClassSuffix = this.expandable === true ? '' : `-${this.expandable}`;
        const classes = classNames({
            navbar: true,
            'navbar-light': this.light,
            'navbar-dark': !this.light,
            [`navbar-expand${expandClassSuffix}`]: !!this.expandable,
            [`bg-${this.color}`]: !!this.color,
            [`fixed-${this.fixed}`]: !!this.fixed,
            'sticky-top': this.sticky,
        });
        return classes;
    }
    get breakpoint() {
        if (typeof this.expandable === 'string') {
            return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.expandable}`);
        }
    }
    ngOnInit() { }
    ngAfterContentInit() {
        if (this.breakpoint) {
            const onBreakpoint = `(min-width: ${this.breakpoint})`;
            this.breakpointObserver.observe([onBreakpoint]).subscribe(result => {
                const { animate } = Object.assign({}, this.collapse);
                this.collapse._animate = false;
                this.collapse.show = false;
                setTimeout(() => {
                    this.collapse.show = result.matches;
                }, 0);
                setTimeout(() => {
                    this.collapse._animate = animate;
                });
            });
        }
    }
}
NavbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-navbar',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
NavbarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: BreakpointObserver }
];
NavbarComponent.propDecorators = {
    light: [{ type: Input }],
    color: [{ type: Input }],
    fixed: [{ type: Input }],
    sticky: [{ type: Input }],
    expandable: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }],
    collapse: [{ type: ContentChild, args: [CollapseDirective,] }]
};

class NavbarBrandComponent {
    constructor() {
        this.navbarBrand = true;
        this.role = 'button';
    }
    ngOnInit() { }
}
NavbarBrandComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-navbar-brand',
                template: "<ng-content></ng-content>\n",
                styles: [":host{outline:inherit}"]
            },] }
];
NavbarBrandComponent.ctorParameters = () => [];
NavbarBrandComponent.propDecorators = {
    navbarBrand: [{ type: HostBinding, args: ['class.navbar-brand',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};

class NavbarNavComponent {
    constructor() {
        this.navbarNav = true;
    }
    ngOnInit() { }
}
NavbarNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-navbar-nav',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
NavbarNavComponent.ctorParameters = () => [];
NavbarNavComponent.propDecorators = {
    navbarNav: [{ type: HostBinding, args: ['class.navbar-nav',] }]
};

class NavbarTextComponent {
    constructor() {
        this.navbarTextClass = true;
    }
    ngOnInit() { }
}
NavbarTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-navbar-text',
                template: "<ng-content></ng-content>\n"
            },] }
];
NavbarTextComponent.ctorParameters = () => [];
NavbarTextComponent.propDecorators = {
    navbarTextClass: [{ type: HostBinding, args: ['class.navbar-text',] }]
};

class NavbarModule {
}
NavbarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NavbarComponent,
                    NavbarBrandComponent,
                    NavbarNavComponent,
                    NavbarTextComponent
                ],
                exports: [
                    NavbarComponent,
                    NavbarBrandComponent,
                    NavbarNavComponent,
                    NavbarTextComponent
                ],
                imports: [
                    CommonModule,
                    RouterModule
                ]
            },] }
];

class ProgressComponent {
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            progress: true,
            [`progress-${this.size}`]: !!this.size
        });
        return classes;
    }
}
ProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-progress',
                template: "<ng-content></ng-content>\n<!--<ng-template [ngIf]=\"stacked.length>0\">-->\n<!--  <c-progress-bar *ngFor=\"let item of stacked\"-->\n<!--                    [value]=\"item.value\"-->\n<!--                    [variant]=\"item.variant\"-->\n<!--                    [animate]=\"item.animate\"-->\n<!--                    [striped]=\"item.striped\"-->\n<!--                    [min]=\"item.min || min || 0\"-->\n<!--                    [max]=\"item.max || max || 100\">-->\n<!--    {{item.label || (item.value/100 | percent)}}-->\n<!--  </c-progress-bar>-->\n<!--</ng-template>-->\n",
                styles: [":host{width:100%;display:flex}"]
            },] }
];
ProgressComponent.propDecorators = {
    size: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ProgressBarComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.state = {
            percent: 0,
            min: 0,
            max: 100
        };
        this.animated = false;
        this.striped = false;
        this.precision = 0;
        this.value = 0;
        this.role = 'progressbar';
        this.host = this.hostElement.nativeElement;
    }
    set min(value) {
        this.state.min = isNaN(value) ? 0 : value;
    }
    get min() {
        return this.state.min;
    }
    set max(value) {
        this.state.max = isNaN(value) || value <= 0 || value === this.min ? 100 : value;
    }
    get max() {
        return this.state.max;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            'progress-bar': true,
            'progress-bar-animated': this.animated,
            'progress-bar-striped': this.striped || this.animated,
            [`bg-${this.color}`]: !!this.color
        });
        return classes;
    }
    ngOnInit() {
        this.setValues();
    }
    setPercent() {
        this.state.percent = +((this.value / (this.max - this.min)) * 100).toFixed(this.precision);
    }
    setValues() {
        this.setPercent();
        this.renderer.setStyle(this.host, 'width', `${this.state.percent}%`);
        this.renderer.setAttribute(this.host, 'aria-valuenow', String(this.value));
        this.renderer.setAttribute(this.host, 'aria-valuemin', String(this.min));
        this.renderer.setAttribute(this.host, 'aria-valuemax', String(this.max));
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.host, `bg-${changes.color.previousValue}`);
        }
        this.setValues();
    }
}
ProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-progress-bar',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
ProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ProgressBarComponent.propDecorators = {
    color: [{ type: Input }],
    animated: [{ type: Input }],
    striped: [{ type: Input }],
    precision: [{ type: Input }],
    value: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ProgressModule {
}
ProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ProgressComponent, ProgressBarComponent],
                exports: [
                    ProgressComponent,
                    ProgressBarComponent
                ],
                imports: [
                    CommonModule
                ]
            },] }
];

class ClassToggleService {
    constructor(document, rendererFactory) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    toggle(selector, className) {
        const element = document.querySelector(selector);
        if (element) {
            element.classList.contains(className) ?
                this.renderer.removeClass(element, className) :
                this.renderer.addClass(element, className);
        }
    }
}
ClassToggleService.ɵprov = ɵɵdefineInjectable({ factory: function ClassToggleService_Factory() { return new ClassToggleService(ɵɵinject(DOCUMENT), ɵɵinject(RendererFactory2)); }, token: ClassToggleService, providedIn: "root" });
ClassToggleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ClassToggleService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: RendererFactory2 }
];

class SidebarBackdropComponent {
    constructor(elementRef, sidebarService) {
        this.elementRef = elementRef;
        this.sidebarService = sidebarService;
        this._sidebarBackdrop = true;
    }
    onClick($event) {
        const targetElement = $event.target;
        if (targetElement && !this.elementRef.nativeElement.contains(targetElement)) {
            this.sidebarService.toggle({ open: false });
        }
    }
    ngOnInit() {
    }
}
SidebarBackdropComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-backdrop',
                template: "",
                styles: [""]
            },] }
];
SidebarBackdropComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SidebarService }
];
SidebarBackdropComponent.propDecorators = {
    _sidebarBackdrop: [{ type: HostBinding, args: ['class.c-sidebar-backdrop',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class SidebarBrandComponent {
    constructor() {
        this.brandText = { icon: '🅲', text: '🅲 CoreUI' };
        this.routerLink = '';
        this._sidebarBrand = true;
    }
    ngOnInit() {
        this.brandImg = Boolean(this.brand || this.brandFull || this.brandMinimized);
    }
}
SidebarBrandComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-brand',
                template: "<a [routerLink]=\"routerLink\">\r\n  <ng-template [ngIf]=\"brandImg\">\r\n<!--    <img *ngIf=\"brand\"-->\r\n<!--         [cHtmlAttr]=\"brand\"-->\r\n<!--         [ngClass]=\"'c-sidebar-brand'\">-->\r\n    <img *ngIf=\"brandFull\"\r\n         [cHtmlAttr]=\"brandFull\"\r\n         [ngClass]=\"'c-sidebar-brand-full'\">\r\n    <img *ngIf=\"brandMinimized\"\r\n         [cHtmlAttr]=\"brandMinimized\"\r\n         [ngClass]=\"'c-sidebar-brand-minimized'\">\r\n  </ng-template>\r\n  <ng-template [ngIf]=\"!brandImg\">\r\n    <div class=\"c-sidebar-brand-full\" [innerHTML]=\"brandText.text\"></div>\r\n    <div class=\"c-sidebar-brand-minimized\" [innerHTML]=\"brandText.icon\"></div>\r\n  </ng-template>\r\n</a>\r\n"
            },] }
];
SidebarBrandComponent.ctorParameters = () => [];
SidebarBrandComponent.propDecorators = {
    brand: [{ type: Input }],
    brandFull: [{ type: Input }],
    brandMinimized: [{ type: Input }],
    brandText: [{ type: Input }],
    routerLink: [{ type: Input }],
    _sidebarBrand: [{ type: HostBinding, args: ['class.c-sidebar-brand',] }]
};

class SidebarFooterComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-footer');
    }
    ngOnInit() { }
}
SidebarFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-footer',
                template: `<ng-content></ng-content>`
            },] }
];
SidebarFooterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];

class SidebarFormComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-form');
    }
    ngOnInit() { }
}
SidebarFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-form',
                template: `<ng-content></ng-content>`
            },] }
];
SidebarFormComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];

class SidebarHeaderComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        renderer.addClass(hostElement.nativeElement, 'c-sidebar-header');
    }
    ngOnInit() { }
}
SidebarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-header',
                template: `<ng-content></ng-content>`
            },] }
];
SidebarHeaderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];

class SidebarMinimizerComponent {
    constructor() {
        this.role = 'button';
        this._sidebarMinimizerClass = true;
    }
}
SidebarMinimizerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-minimizer',
                template: ``
            },] }
];
SidebarMinimizerComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    _sidebarMinimizerClass: [{ type: HostBinding, args: ['class.c-sidebar-minimizer',] }]
};

class SidebarMinimizeDirective {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
    }
    toggleMinimize($event) {
        $event.preventDefault();
        this.sidebarService.toggle({ minimize: 'toggle', id: this.id });
    }
}
SidebarMinimizeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cSidebarMinimize]',
                exportAs: 'cSidebarMinimize'
            },] }
];
SidebarMinimizeDirective.ctorParameters = () => [
    { type: SidebarService }
];
SidebarMinimizeDirective.propDecorators = {
    id: [{ type: Input, args: ['cSidebarMinimize',] }],
    toggleMinimize: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class SidebarToggleDirective {
    constructor(sidebarService) {
        this.sidebarService = sidebarService;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.sidebarService.toggle({ open: 'toggle', id: this.id });
    }
}
SidebarToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cSidebarToggle]',
                exportAs: 'cSidebarToggle',
            },] }
];
SidebarToggleDirective.ctorParameters = () => [
    { type: SidebarService }
];
SidebarToggleDirective.propDecorators = {
    id: [{ type: Input, args: ['cSidebarToggle',] }],
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class SidebarComponent {
    constructor(document, renderer, hostElement, breakpointObserver, sidebarService) {
        this.document = document;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.breakpointObserver = breakpointObserver;
        this.sidebarService = sidebarService;
        this.fixed = true;
        this.unfoldable = false;
        this.overlaid = false;
        this.minimize = false;
        this.breakpoint = 'lg';
        this.mobile = 'lg';
        this.size = '';
        this.hideOnMobileClick = true;
        this.colorScheme = 'dark';
        this.minimized = this.minimize;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get getDesktopBreakpoint() {
        return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.breakpoint}`);
    }
    get hasBreakpoint() {
        return !!this.breakpoint;
    }
    get getMobileBreakpoint() {
        return getComputedStyle(this.hostElement.nativeElement).getPropertyValue(`--breakpoint-${this.mobile}`);
    }
    set isOnMobile(value) {
        this._isOnMobile = value;
    }
    get isOnMobile() {
        const isMobile = Boolean(this._isOnMobile);
        return isMobile;
    }
    set isOnDesktop(value) {
        this._isOnDesktop = this.hasBreakpoint ? value : false;
    }
    get isOnDesktop() {
        return this._isOnDesktop;
    }
    get isOpen() {
        let opened;
        if (this.isOnDesktop) {
            opened = this.openDesktop;
        }
        else {
            opened = (this.openMobile === true);
        }
        return opened;
    }
    get hostClasses() {
        const classes = classNames({
            'c-sidebar': true,
            'c-sidebar-fixed': this.fixed && !this.overlaid,
            'c-sidebar-right': this.aside,
            'c-sidebar-minimized': this.minimize && !this.unfoldable,
            'c-sidebar-unfoldable': this.minimize && this.unfoldable,
            'c-sidebar-overlaid': this.overlaid,
            'c-sidebar-show': this.openMobile === true,
            [`c-sidebar-${this.breakpoint}-show`]: (!!this.breakpoint) && this.openDesktop,
            [`c-sidebar-${this.colorScheme}`]: !!this.colorScheme,
            [`c-sidebar-${this.size}`]: !!this.size,
        });
        return classes;
    }
    ngOnInit() {
        this.stateToggleSubscribe();
        this.layoutChangeSubscribe();
        this.setInitialState();
    }
    layoutChangeSubscribe(subscribe = true) {
        const onDesktop = `(min-width: ${this.getDesktopBreakpoint})`;
        const onMobile = this.breakpoint === false ? `(max-width: ${this.getMobileBreakpoint})` : `(max-width: ${this.getDesktopBreakpoint})`;
        if (subscribe) {
            const layoutChanges = this.breakpointObserver.observe([
                onDesktop,
                onMobile,
            ]);
            this.layoutChangesSubscription = layoutChanges.subscribe(result => {
                this.isOnMobile = result.breakpoints[onMobile];
                this.isOnDesktop = result.breakpoints[onDesktop];
                const openMobile = this.isOnMobile ? false : this.isOpen ? this.isOpen : this.show;
                this.sidebarService.toggle({ open: openMobile, sidebar: this });
            });
        }
        else {
            this.layoutChangesSubscription.unsubscribe();
        }
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.layoutChangeSubscribe(false);
    }
    setInitialState() {
        this.openMobile = this.isOnDesktop ? false : this.isOnMobile ? false : this.show;
        this.openDesktop = this.hasBreakpoint;
        this.sidebarService.toggle({ minimize: this.minimize, open: this.isOpen, sidebar: this });
    }
    getState() {
        return { opened: this.isOpen, minimized: this.minimized, id: this.id };
    }
    open(state) {
        const toggle = (state.open === 'toggle');
        if (this.isOnDesktop) {
            this.openDesktop = toggle ? !this.openDesktop : state.open;
            this.openMobile = false;
        }
        else {
            this.openMobile = toggle ? !this.openMobile : state.open;
            if (this.openMobile && this.isOnMobile) {
                this.setBackdrop();
            }
            else {
                this.clearBackdrop();
            }
        }
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToggleSubscription = this.sidebarService.sidebarState$.subscribe((state) => {
                if (this === state.sidebar || this.id === state.id) {
                    if ('minimize' in state) {
                        this.minimizeSidebar(state);
                    }
                    if ('open' in state) {
                        this.open(state);
                    }
                }
            });
        }
        else {
            this.stateToggleSubscription.unsubscribe();
        }
    }
    hideMobile(e) {
        if (this.isOpen) {
            if (!e.target.closest('[cSidebarNavDropdownToggle]')) {
                this.sidebarService.toggle({ open: false, sidebar: this });
            }
        }
    }
    setBackdrop() {
        const backdrop = this.document.getElementsByClassName('c-sidebar-backdrop');
        if (backdrop.length === 0) {
            this.backdrop = this.renderer.createElement('div');
            this.renderer.addClass(this.backdrop, 'c-sidebar-backdrop');
            this.renderer.appendChild(this.document.body, this.backdrop);
            this.renderer.listen(this.backdrop, 'click', (e) => {
                this.hideMobile(e);
            });
        }
        if (this.backdrop && this.isOnMobile && this.isOpen) {
            this.renderer.addClass(this.backdrop, 'c-show');
            this.renderer.removeClass(this.backdrop, 'd-none');
        }
        else {
            this.renderer.addClass(this.backdrop, 'd-none');
            this.renderer.removeClass(this.backdrop, 'c-show');
        }
    }
    clearBackdrop() {
        if (this.backdrop) {
            this.renderer.listen(this.backdrop, 'click', (e) => { });
            this.renderer.removeChild(this.document.body, this.backdrop);
        }
    }
    minimizeSidebar(state) {
        const toggle = (state.minimize === 'toggle');
        this.minimize = toggle ? !this.minimize : !!state.minimize;
    }
    ngOnChanges(changes) {
        if (changes.breakpoint) {
            const { previousValue, currentValue } = Object.assign({}, changes.breakpoint);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}-show`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}-show`);
        }
        if (changes.size) {
            const { previousValue, currentValue } = Object.assign({}, changes.size);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}`);
        }
        if (changes.colorScheme) {
            const { previousValue, currentValue } = Object.assign({}, changes.colorScheme);
            if (typeof currentValue === 'string') {
                this.renderer.addClass(this.hostElement.nativeElement, `c-sidebar-${currentValue}`);
            }
            this.renderer.removeClass(this.hostElement.nativeElement, `c-sidebar-${previousValue}`);
        }
    }
}
SidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar',
                exportAs: 'cSidebar',
                template: `<ng-content></ng-content>`
            },] }
];
SidebarComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: BreakpointObserver },
    { type: SidebarService }
];
SidebarComponent.propDecorators = {
    fixed: [{ type: Input }],
    unfoldable: [{ type: Input }],
    overlaid: [{ type: Input }],
    minimize: [{ type: Input }],
    breakpoint: [{ type: Input }],
    mobile: [{ type: Input }],
    show: [{ type: Input }],
    size: [{ type: Input }],
    aside: [{ type: Input }],
    hideOnMobileClick: [{ type: Input }],
    colorScheme: [{ type: Input }],
    id: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SidebarNavService {
}
SidebarNavService.decorators = [
    { type: Injectable }
];
class SidebarNavHelper {
    constructor() {
        this.hasBadge = (item) => Boolean(item.badge);
        this.hasIcon = (item) => Boolean(item.icon) || item.icon === '';
    }
    itemType(item) {
        if (item.divider) {
            return 'divider';
        }
        else if (item.title) {
            return 'title';
        }
        else if (item.children && item.children.length > 0) {
            return 'dropdown';
        }
        else if (item.label) {
            return 'label';
        }
        else if (!Object.keys(item).length) {
            return 'empty';
        }
        else {
            return 'link';
        }
    }
    isActive(router, item) {
        return router.isActive(item.url, false);
    }
    getIconClass(item) {
        const classes = {
            'c-sidebar-nav-icon': true
        };
        const icon = item.icon;
        classes[icon] = this.hasIcon(item);
        return classes;
    }
}
SidebarNavHelper.decorators = [
    { type: Injectable }
];

class SidebarNavComponent {
    constructor(sidebar, helper, router, renderer, hostElement, sidebarService) {
        this.sidebar = sidebar;
        this.helper = helper;
        this.router = router;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.sidebarService = sidebarService;
        this.navItems = [];
        this.dropdownMode = 'closeInactive';
        this.role = 'nav';
        this.navItemsArray = [];
    }
    get sidebarNavClass() {
        return !this.dropdownItems;
    }
    get sidebarNavDropdownItemsClass() {
        return this.dropdownItems;
    }
    ngOnChanges(changes) {
        this.navItemsArray = Array.isArray(this.navItems) ? this.navItems.slice() : [];
    }
    hideMobile() {
        if (this.sidebar && this.sidebar.hideOnMobileClick && this.sidebar.isOnMobile) {
            this.sidebarService.toggle({ open: false, sidebar: this.sidebar });
        }
    }
}
SidebarNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav',
                template: "<!--<c-sidebar-nav-items-->\r\n<!--  class=\"c-sidebar-nav\"-->\r\n<!--  [items]=\"navItemsArray\">-->\r\n<!--</c-sidebar-nav-items>-->\r\n<ng-container *ngFor=\"let item of navItemsArray\">\r\n  <ng-container [ngSwitch]=\"helper.itemType(item)\">\r\n    <c-sidebar-nav-dropdown\r\n      *ngSwitchCase=\"'dropdown'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\">\r\n    </c-sidebar-nav-dropdown>\r\n<!--\r\n    <c-sidebar-nav-dropdown\r\n      *ngSwitchCase=\"'dropdown'\"\r\n      [item]=\"item\"\r\n      [class.c-show]=\"helper.isActive(router, item)\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      cSidebarNavDropdown\r\n      [dropdownMode]=\"dropdownMode\"\r\n      [routerLinkActive]=\"'c-show'\">\r\n    </c-sidebar-nav-dropdown>\r\n-->\r\n    <c-sidebar-nav-divider\r\n      *ngSwitchCase=\"'divider'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      [cHtmlAttr]=\"item.attributes\">\r\n    </c-sidebar-nav-divider>\r\n    <c-sidebar-nav-title\r\n      *ngSwitchCase=\"'title'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      [cHtmlAttr]=\"item.attributes\">\r\n    </c-sidebar-nav-title>\r\n    <c-sidebar-nav-label\r\n      *ngSwitchCase=\"'label'\"\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\">\r\n    </c-sidebar-nav-label>\r\n    <ng-container\r\n      *ngSwitchCase=\"'empty'\">\r\n    </ng-container>\r\n    <c-sidebar-nav-link\r\n      *ngSwitchDefault\r\n      [item]=\"item\"\r\n      [ngClass]=\"item | cSidebarNavItemClass\"\r\n      (linkClick)=\"hideMobile()\"\r\n    >\r\n    </c-sidebar-nav-link>\r\n  </ng-container>\r\n</ng-container>\r\n",
                styles: [':host {flex: 1;}',
                    '.c-sidebar-minimized :host {overflow: visible !important;}']
            },] }
];
SidebarNavComponent.ctorParameters = () => [
    { type: SidebarComponent, decorators: [{ type: Optional }] },
    { type: SidebarNavHelper },
    { type: Router },
    { type: Renderer2 },
    { type: ElementRef },
    { type: SidebarService }
];
SidebarNavComponent.propDecorators = {
    navItems: [{ type: Input }],
    dropdownMode: [{ type: Input }],
    dropdownItems: [{ type: Input }],
    sidebarNavClass: [{ type: HostBinding, args: ['class.c-sidebar-nav',] }],
    sidebarNavDropdownItemsClass: [{ type: HostBinding, args: ['class.c-sidebar-nav-dropdown-items',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }]
};

class SidebarNavDividerComponent {
    constructor() { }
    ngOnInit() { }
}
SidebarNavDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-divider',
                template: ``
            },] }
];
SidebarNavDividerComponent.ctorParameters = () => [];
SidebarNavDividerComponent.propDecorators = {
    item: [{ type: Input }]
};

class SidebarNavDropdownComponent {
    constructor(router, helper) {
        this.router = router;
        this.helper = helper;
        this.dropdownMode = 'closeInactive';
        this.navItems = [];
        this.navigationEndObservable = router.events.pipe(filter(event => event instanceof NavigationEnd));
    }
    get getClasses() {
        return this.hostClasses;
    }
    ngOnInit() {
        this.navItems = [...this.item.children];
        this.navSubscription = this.navigationEndObservable.subscribe(event => {
            const itemArray = this.item.url.split('/');
            const urlArray = event.url.split('/');
            const samePath = itemArray.every((value, index) => value === urlArray[index]);
            this.openDropdown(samePath);
        });
    }
    openDropdown(open) {
        this.open = open;
    }
    toggleDropdown() {
        this.open = !this.open;
    }
    ngOnDestroy() {
        this.navSubscription.unsubscribe();
    }
    get hostClasses() {
        const classes = classNames(this.ngClass, this.class, {
            'c-sidebar-nav-dropdown': true,
            'c-show': this.open,
        });
        return classes;
    }
}
SidebarNavDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-dropdown',
                template: `
    <a class="c-sidebar-nav-dropdown-toggle"
       cSidebarNavDropdownToggle
       [cHtmlAttr]="item.attributes">
      <i *ngIf="helper.hasIcon(item)" [ngClass]="item | cSidebarNavIcon"></i>
      <ng-container>{{ item.name }}</ng-container>
      <span *ngIf="helper.hasBadge(item)" [ngClass]="item | cSidebarNavBadge">{{ item.badge.text }}</span>
    </a>
    <c-sidebar-nav
      [dropdownItems]="true"
      [navItems]="navItems">
    </c-sidebar-nav>
  `,
                providers: [SidebarNavHelper],
                styles: [".c-sidebar-nav-dropdown-toggle{cursor:pointer}.c-sidebar-nav-dropdown-items{display:block}"]
            },] }
];
SidebarNavDropdownComponent.ctorParameters = () => [
    { type: Router },
    { type: SidebarNavHelper }
];
SidebarNavDropdownComponent.propDecorators = {
    item: [{ type: Input }],
    dropdownMode: [{ type: Input }],
    show: [{ type: Input }],
    class: [{ type: Input }],
    ngClass: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SidebarNavItemsComponent {
    constructor(router, helper) {
        this.router = router;
        this.helper = helper;
    }
    set items(items) {
        this._items = [...items];
    }
    get items() {
        return this._items;
    }
}
SidebarNavItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-items',
                template: `
    <ng-container *ngFor="let item of items">
      <ng-container [ngSwitch]="helper.itemType(item)">
        <c-sidebar-nav-dropdown
          *ngSwitchCase="'dropdown'"
          [item]="item"
          [class.c-show]="helper.isActive(router, item)"
          [ngClass]="item | cSidebarNavItemClass"
          cSidebarNavDropdown
          routerLinkActive="c-show">
        </c-sidebar-nav-dropdown>
        <c-sidebar-nav-divider
          *ngSwitchCase="'divider'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
          [cHtmlAttr]="item.attributes">
        </c-sidebar-nav-divider>
        <c-sidebar-nav-title
          *ngSwitchCase="'title'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
          [cHtmlAttr]="item.attributes">
        </c-sidebar-nav-title>
        <c-sidebar-nav-label
          *ngSwitchCase="'label'"
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass">
        </c-sidebar-nav-label>
        <ng-container
          *ngSwitchCase="'empty'">
        </ng-container>
        <c-sidebar-nav-link
          *ngSwitchDefault
          [item]="item"
          [ngClass]="item | cSidebarNavItemClass"
        >
        </c-sidebar-nav-link>
      </ng-container>
    </ng-container>
  `
            },] }
];
SidebarNavItemsComponent.ctorParameters = () => [
    { type: Router },
    { type: SidebarNavHelper }
];
SidebarNavItemsComponent.propDecorators = {
    items: [{ type: Input }]
};

class SidebarNavLinkContentComponent {
    constructor(helper) {
        this.helper = helper;
    }
}
SidebarNavLinkContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-link-content',
                template: `
    <ng-container *ngIf="true">
      <ng-container>{{item.name}}</ng-container>
    </ng-container>
  `,
                providers: [SidebarNavHelper]
            },] }
];
SidebarNavLinkContentComponent.ctorParameters = () => [
    { type: SidebarNavHelper }
];
SidebarNavLinkContentComponent.propDecorators = {
    item: [{ type: Input }]
};
class SidebarNavLinkComponent {
    constructor(router, renderer, hostElement, sidebarService) {
        this.router = router;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.sidebarService = sidebarService;
        this.linkClick = new EventEmitter();
        this.navigationEndObservable = router.events.pipe(filter(event => {
            return event instanceof NavigationEnd;
        }));
    }
    set item(item) {
        this._item = JSON.parse(JSON.stringify(item));
    }
    get item() {
        return this._item;
    }
    ngOnInit() {
        this.url = typeof this.item.url === 'string' ? this.item.url : this.router.serializeUrl(this.router.createUrlTree(this.item.url));
        this.linkType = this.getLinkType();
        this.href = this.isDisabled() ? '' : (this.item.href || this.url);
        this.linkActive = this.router.url.split(/[?#(;]/)[0] === this.href.split(/[?#(;]/)[0];
        this.navSubscription = this.navigationEndObservable.subscribe(event => {
            const itemUrlArray = this.href.split(/[?#(;]/)[0].split('/');
            const urlArray = event.urlAfterRedirects.split(/[?#(;]/)[0].split('/');
            this.linkActive = itemUrlArray.every((value, index) => value === urlArray[index]);
        });
    }
    ngOnDestroy() {
        this.navSubscription.unsubscribe();
    }
    getLinkType() {
        return this.isDisabled() ? 'disabled' : this.isExternalLink() ? 'external' : 'link';
    }
    isDisabled() {
        return (this.item.attributes && this.item.attributes.disabled) ? true : null;
    }
    isExternalLink() {
        const linkPath = Array.isArray(this.item.url) ? this.item.url[0] : this.item.url;
        return !!this.item.href || linkPath.substring(0, 4) === 'http';
    }
    linkClicked() {
        this.linkClick.emit();
    }
}
SidebarNavLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-link',
                template: "<ng-container [ngSwitch]=\"linkType\">\r\n  <a *ngSwitchCase=\"'disabled'\"\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n  <a *ngSwitchCase=\"'external'\"\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [href]=\"href\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n     (click)=\"linkClicked()\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n  <a *ngSwitchDefault\r\n     [ngClass]=\"item | cSidebarNavLink\"\r\n     [cHtmlAttr]=\"item.attributes\"\r\n     [target]=\"item.attributes?.target\"\r\n     [queryParams]=\"item.linkProps?.queryParams\"\r\n     [fragment]=\"item.linkProps?.fragment\"\r\n     [queryParamsHandling]=\"item.linkProps?.queryParamsHandling\"\r\n     [preserveFragment]=\"item.linkProps?.preserveFragment\"\r\n     [skipLocationChange]=\"item.linkProps?.skipLocationChange\"\r\n     [replaceUrl]=\"item.linkProps?.replaceUrl\"\r\n     [state]=\"item.linkProps?.state\"\r\n     [routerLink]=\"item.url\"\r\n     [class.c-active]=\"linkActive\"\r\n     (click)=\"linkClicked()\"\r\n  >\r\n    <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>\r\n    <span *ngIf=\"!item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></span>\r\n    <c-sidebar-nav-link-content [item]=\"item\"></c-sidebar-nav-link-content>\r\n    <span *ngIf=\"item.badge\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\r\n  </a>\r\n</ng-container>\r\n",
                providers: [SidebarNavHelper]
            },] }
];
SidebarNavLinkComponent.ctorParameters = () => [
    { type: Router },
    { type: Renderer2 },
    { type: ElementRef },
    { type: SidebarService }
];
SidebarNavLinkComponent.propDecorators = {
    item: [{ type: Input }],
    linkClick: [{ type: Output }]
};

class SidebarNavTitleComponent {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    ngOnInit() {
        const nativeElement = this.el.nativeElement;
        const name = this.renderer.createText(this.item.name);
        if (this.item.class) {
            const classes = this.item.class;
            this.renderer.addClass(nativeElement, classes);
        }
        if (this.item.wrapper) {
            const wrapper = this.renderer.createElement(this.item.wrapper.element);
            this.addAttribs(this.item.wrapper.attributes, wrapper);
            this.renderer.appendChild(wrapper, name);
            this.renderer.appendChild(nativeElement, wrapper);
        }
        else {
            this.renderer.appendChild(nativeElement, name);
        }
    }
    addAttribs(attribs, element) {
        if (attribs) {
            for (const attr in attribs) {
                if (attr === 'style' && typeof (attribs[attr]) === 'object') {
                    this.setStyle(attribs[attr], element);
                }
                else if (attr === 'class') {
                    this.addClass(attribs[attr], element);
                }
                else {
                    this.setAttrib(attr, attribs[attr], element);
                }
            }
        }
    }
    setStyle(styles, el) {
        for (const style in styles) {
            if (style) {
                this.renderer.setStyle(el, style, styles[style]);
            }
        }
    }
    addClass(classes, el) {
        const classArray = (Array.isArray(classes) ? classes : classes.split(' '));
        classArray.filter((element) => element.length > 0).forEach(element => {
            this.renderer.addClass(el, element);
        });
    }
    setAttrib(key, value, el) {
        this.renderer.setAttribute(el, key, value);
    }
}
SidebarNavTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-title',
                template: ''
            },] }
];
SidebarNavTitleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SidebarNavTitleComponent.propDecorators = {
    item: [{ type: Input }]
};

class SidebarNavLabelComponent {
    constructor(helper) {
        this.helper = helper;
        this.classes = {
            'c-nav-label': true,
            'c-active': true
        };
        this.iconClasses = {};
    }
    ngOnInit() {
        this.iconClasses = this.helper.getIconClass(this.item);
    }
    getItemClass() {
        const itemClass = this.item.class;
        this.classes[itemClass] = !!itemClass;
        return this.classes;
    }
    getLabelIconClass() {
        const variant = `text-${this.item.label.variant}`;
        this.iconClasses[variant] = !!this.item.label.variant;
        const labelClass = this.item.label.class;
        this.iconClasses[labelClass] = !!labelClass;
        return this.iconClasses;
    }
}
SidebarNavLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-sidebar-nav-label',
                template: "<a [ngClass]=\"getItemClass()\"\r\n   href=\"{{item.url}}\"\r\n   [cHtmlAttr]=\"item.attributes\">\r\n  <i *ngIf=\"helper.hasIcon(item)\" [ngClass]=\"getLabelIconClass()\"></i>\r\n  <ng-container>{{ item.name }}</ng-container>\r\n  <span *ngIf=\"helper.hasBadge(item)\" [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\r\n</a>\r\n"
            },] }
];
SidebarNavLabelComponent.ctorParameters = () => [
    { type: SidebarNavHelper }
];
SidebarNavLabelComponent.propDecorators = {
    item: [{ type: Input }]
};

class SidebarNavIconPipe {
    transform(item, args) {
        const classes = {
            'c-sidebar-nav-icon': true
        };
        const icon = item.icon;
        classes[icon] = !!item.icon;
        return classes;
    }
}
SidebarNavIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cSidebarNavIcon'
            },] }
];

class SidebarNavBadgePipe {
    transform(item, args) {
        const classes = {
            badge: true
        };
        const variant = `badge-${item.badge.variant}`;
        classes[variant] = !!item.badge.variant;
        classes[item.badge.class] = !!item.badge.class;
        return classes;
    }
}
SidebarNavBadgePipe.decorators = [
    { type: Pipe, args: [{
                name: 'cSidebarNavBadge'
            },] }
];

class SidebarNavItemClassPipe {
    constructor(helper) {
        this.helper = helper;
    }
    transform(item, args) {
        const itemType = this.helper.itemType(item);
        let itemClass;
        if (['divider', 'title'].includes(itemType)) {
            itemClass = `c-sidebar-nav-${itemType}`;
        }
        else if (itemType === 'dropdown') {
            itemClass = '';
        }
        else {
            itemClass = 'c-sidebar-nav-item';
        }
        return item.class ? `${itemClass} ${item.class}` : itemClass;
    }
}
SidebarNavItemClassPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cSidebarNavItemClass'
            },] }
];
SidebarNavItemClassPipe.ctorParameters = () => [
    { type: SidebarNavHelper }
];

class SidebarNavLinkPipe {
    transform(item) {
        var _a;
        const disabled = (_a = item === null || item === void 0 ? void 0 : item.attributes) === null || _a === void 0 ? void 0 : _a.disabled;
        const classes = {
            'c-sidebar-nav-link': true,
            disabled,
            'btn-link': disabled,
        };
        classes[`c-sidebar-nav-link-${item.variant}`] = !!item.variant;
        return classes;
    }
}
SidebarNavLinkPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cSidebarNavLink'
            },] }
];

class SidebarNavDropdownToggleDirective {
    constructor(sidebarNavDropdown) {
        this.sidebarNavDropdown = sidebarNavDropdown;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.sidebarNavDropdown.toggleDropdown();
    }
}
SidebarNavDropdownToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cSidebarNavDropdownToggle]',
                exportAs: 'cSidebarNavDropdownToggle',
            },] }
];
SidebarNavDropdownToggleDirective.ctorParameters = () => [
    { type: SidebarNavDropdownComponent }
];
SidebarNavDropdownToggleDirective.propDecorators = {
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class SidebarModule {
}
SidebarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    SharedModule
                ],
                exports: [
                    SidebarBrandComponent,
                    SidebarFooterComponent,
                    SidebarFormComponent,
                    SidebarHeaderComponent,
                    SidebarMinimizerComponent,
                    SidebarComponent,
                    SidebarNavItemsComponent,
                    SidebarNavComponent,
                    SidebarNavDividerComponent,
                    SidebarNavDropdownComponent,
                    SidebarNavLinkComponent,
                    SidebarNavLinkContentComponent,
                    SidebarNavTitleComponent,
                    SidebarToggleDirective,
                    SidebarMinimizeDirective,
                    SharedModule
                ],
                declarations: [
                    SidebarBrandComponent,
                    SidebarFooterComponent,
                    SidebarFormComponent,
                    SidebarHeaderComponent,
                    SidebarMinimizerComponent,
                    SidebarComponent,
                    SidebarNavItemsComponent,
                    SidebarNavComponent,
                    SidebarNavDividerComponent,
                    SidebarNavDropdownComponent,
                    SidebarNavLinkComponent,
                    SidebarNavLinkContentComponent,
                    SidebarNavTitleComponent,
                    SidebarNavDropdownToggleDirective,
                    SidebarNavLabelComponent,
                    SidebarNavIconPipe,
                    SidebarNavBadgePipe,
                    SidebarNavItemClassPipe,
                    SidebarNavLinkPipe,
                    SidebarBackdropComponent,
                    SidebarToggleDirective,
                    SidebarMinimizeDirective
                ],
                providers: [
                    OutClickService,
                    SidebarService,
                    SidebarNavHelper,
                ]
            },] }
];

class SpinkitComponent {
    constructor() {
        this.center = true;
        this.name = 'plane';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            [`sk-${this.name}`]: true,
            'sk-center': this.center,
        });
        return classes;
    }
    ngOnInit() { }
}
SpinkitComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-spinkit',
                template: "<ng-container [ngSwitch]=\"name\">\n  <ng-container *ngSwitchCase=\"'plane'\"></ng-container>\n  <ng-container *ngSwitchCase=\"'chase'\">\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n    <div class=\"sk-chase-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'bounce'\">\n    <div class=\"sk-bounce-dot\"></div>\n    <div class=\"sk-bounce-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'wave'\">\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n    <div class=\"sk-wave-rect\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'pulse'\"></ng-container>\n  <ng-container *ngSwitchCase=\"'flow'\">\n    <div class=\"sk-flow-dot\"></div>\n    <div class=\"sk-flow-dot\"></div>\n    <div class=\"sk-flow-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'swing'\">\n    <div class=\"sk-swing-dot\"></div>\n    <div class=\"sk-swing-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'circle'\">\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n    <div class=\"sk-circle-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'circle-fade'\">\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n    <div class=\"sk-circle-fade-dot\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'grid'\">\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n    <div class=\"sk-grid-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'fold'\">\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n    <div class=\"sk-fold-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'wander'\">\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n    <div class=\"sk-wander-cube\"></div>\n  </ng-container>\n  <ng-container *ngSwitchDefault></ng-container>\n</ng-container>\n",
                styles: [":host{display:block}:host.sk-wave{display:flex}:host.sk-flow{display:flex;align-items:center}"]
            },] }
];
SpinkitComponent.ctorParameters = () => [];
SpinkitComponent.propDecorators = {
    center: [{ type: Input }],
    name: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SpinkitModule {
}
SpinkitModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SpinkitComponent],
                exports: [
                    SpinkitComponent
                ],
                imports: [
                    CommonModule
                ]
            },] }
];

class SpinnerComponent {
    constructor() {
        this.color = '';
        this.grow = false;
        this.size = '';
        this.role = 'status';
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const shape = this.grow ? 'grow' : 'border';
        const classes = classNames({
            [`spinner-${shape}`]: true,
            [`text-${this.color}`]: !!this.color,
            [`spinner-${shape}-${this.size}`]: !!this.size
        });
        return classes;
    }
}
SpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-spinner',
                template: "<!--<div [ngClass]=\"classes\" [attr.role]=\"role\" [ngStyle]=\"styles\">-->\n  <span class=\"sr-only\">Loading...</span>\n<!--</div>-->\n",
                styles: [""]
            },] }
];
SpinnerComponent.propDecorators = {
    color: [{ type: Input }],
    grow: [{ type: Input }],
    size: [{ type: Input }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class SpinnerModule {
}
SpinnerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SpinnerComponent
                ],
                exports: [
                    SpinnerComponent
                ],
                imports: [
                    CommonModule,
                    SharedModule
                ]
            },] }
];

class SwitchComponent {
    constructor(renderer, hostElement) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.variant = '';
        this.labelOn = '';
        this.labelOff = '';
        this.size = '';
        this.shape = '';
        this.tabindex = '0';
        this.type = 'checkbox';
        this.value = 'on';
        this.data = {};
        this._props = {
            autofocus: false,
            checked: false,
            disabled: false,
            required: false,
        };
        this.hostTabIndex = -1;
        this.toggle = new EventEmitter();
        this.classes = {};
        this.host = this.hostElement.nativeElement;
    }
    get label() {
        return !!this.labelOn || !!this.labelOff;
    }
    set autofocus(value) {
        this._props.autofocus = typeof value === 'string' || !!value;
    }
    get autofocus() {
        return this._props.autofocus;
    }
    set checked(value) {
        this._props.checked = typeof value === 'string' || !!value;
    }
    get checked() {
        return this._props.checked;
    }
    set disabled(value) {
        this._props.disabled = typeof value === 'string' || !!value;
        this.tabindex = this._props.disabled ? -1 : this.tabindex;
    }
    get disabled() {
        return this._props.disabled;
    }
    set required(value) {
        this._props.required = typeof value === 'string' || !!value;
    }
    get required() {
        return this._props.required;
    }
    ngOnInit() {
        this.data = {
            'data-checked': this.labelOn,
            'data-unchecked': this.labelOff
        };
        this.setClasses();
    }
    setClasses() {
        const variant = this.variant ? `-${this.variant}` : '';
        this.classes['c-switch'] = true;
        this.classes['form-check-label'] = true;
        this.classes[`c-switch-${this.size}`] = !!this.size;
        this.classes[`c-switch-${this.shape}`] = !!this.shape;
        this.classes[`c-switch${variant}-${this.color}`] = !!this.color;
        this.classes['c-switch-label'] = !!this.label || typeof this.label === 'string';
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.classes[`c-switch-${changes.color.previousValue}`] = false;
        }
        if (changes.size) {
            this.classes[`c-switch-${changes.size.previousValue}`] = false;
        }
        if (changes.variant) {
            this.classes[`c-switch-variant-${changes.variant.previousValue}-alt`] = false;
            this.classes[`c-switch-variant-${changes.variant.previousValue}`] = false;
        }
        if (changes.shape) {
            this.classes[`c-switch-${changes.shape.previousValue}`] = false;
        }
        this.setClasses();
    }
    onKeyDown(e) {
        if (e.code === 'Space' && e.target === this.host.firstChild) {
            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();
        }
    }
    onKeyUp(e) {
        if (e.key === 'Enter') {
            this.toggleSwitch();
        }
    }
    onClick(e) {
        if (e.target.tagName === 'INPUT') {
            if (e instanceof MouseEvent) {
                this.toggleSwitch();
            }
        }
    }
    toggleSwitch() {
        if (this.disabled) {
            return false;
        }
        this.checked = !this.checked;
        this.toggle.emit(this);
    }
}
SwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-switch',
                template: "<label [ngClass]=\"classes\" [tabindex]=\"-1\">\n  <input\n    class=\"c-switch-input form-check-input\"\n    [tabindex]=\"tabindex\"\n    [type]=\"type\"\n    [autofocus]=\"autofocus\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    [required]=\"required\"\n    [name]=\"name ? name : ''\"\n    [value]=\"value\">\n  <span class=\"c-switch-slider\" attr.data-checked=\"{{labelOn}}\" attr.data-unchecked=\"{{labelOff}}\"></span>\n</label>\n",
                styles: [":host{outline:0}:host,:host .c-switch,:host .c-switch-input,:host .c-switch-slider{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host .c-switch-label:focus{outline:0}.c-switch:focus{outline-style:auto;outline-offset:1px}.c-switch-slider:focus,.c-switch:hover{outline:none}"]
            },] }
];
SwitchComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
SwitchComponent.propDecorators = {
    color: [{ type: Input }],
    variant: [{ type: Input }],
    labelOn: [{ type: Input }],
    labelOff: [{ type: Input }],
    size: [{ type: Input }],
    shape: [{ type: Input }],
    name: [{ type: Input }],
    tabindex: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: Input }],
    autofocus: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    hostTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    toggle: [{ type: Output, args: ['checked',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class SwitchModule {
}
SwitchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SwitchComponent
                ],
                exports: [
                    SwitchComponent
                ],
                imports: [
                    CommonModule,
                ]
            },] }
];

class TabsetService {
    constructor() {
        this.activeTab = new Subject();
        this.activeTab$ = this.activeTab.asObservable();
    }
    setActiveTab(tab) {
        this.activeTab.next(tab);
    }
}
TabsetService.decorators = [
    { type: Injectable }
];
TabsetService.ctorParameters = () => [];

class TabComponent {
    constructor(renderer, tabsetService) {
        this.renderer = renderer;
        this.tabsetService = tabsetService;
        this.classMap = {};
        this._navItemClass = true;
    }
    set active(active) {
        this.classMap.active = active;
    }
    get active() {
        return this.classMap.active;
    }
    set disabled(disabled) {
        this.classMap.disabled = disabled;
    }
    get disabled() {
        return this.classMap.disabled;
    }
    onClick(e) {
        e.preventDefault();
        if (!this.disabled) {
            this.active = true;
            this.tabsetService.setActiveTab(this);
        }
    }
    ngOnInit() {
        this.classMap = {
            'nav-link': true,
            active: this.active,
            disabled: this.disabled
        };
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    ngAfterViewInit() {
        this.activeTabSubscribe();
    }
    ngOnChanges(changes) {
        this.classMap = {
            active: changes.active ? changes.active.currentValue : this.active,
            disabled: changes.disabled ? changes.disabled.currentValue : this.disabled
        };
        this.classMap = Object.assign(Object.create(null), this.classMap);
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
            this.active = this.indexKey === activeTab.indexKey;
            this.classMap.active = this.indexKey === activeTab.indexKey;
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-tab',
                template: "<!--<a #link href=\"javascript:void(0);\" [ngClass]=\"classMap\" (click)=\"onClick($event)\" tabindex=\"{{disabled ? -1 : 0}}\">-->\n<a #link href [ngClass]=\"classMap\" tabindex=\"{{disabled ? -1 : 0}}\">\n  <ng-content></ng-content>\n</a>\n",
                styles: [":host .nav-link:focus{outline:none!important}"]
            },] }
];
TabComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: TabsetService }
];
TabComponent.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    _navItemClass: [{ type: HostBinding, args: ['class.nav-item',] }],
    _link: [{ type: ViewChild, args: ['link', { static: true },] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class TabPaneComponent {
    constructor(tabsetService) {
        this.tabsetService = tabsetService;
        this.fade = true;
        this._tabPane = true;
        this._tabActive = true;
        this._tabShow = false;
        this._tabFade = this.fade;
    }
    set active(active) {
        this._tabActive = active;
        this._tabShow = active;
    }
    get active() {
        return this._tabActive;
    }
    ngOnInit() {
        this.activeTabSubscribe();
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
            setTimeout(() => {
                this.active = activeTab.indexKey === this.indexKey;
            });
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-tab-pane',
                template: "<ng-content *ngIf=\"active\"></ng-content>\n\n",
                styles: [""]
            },] }
];
TabPaneComponent.ctorParameters = () => [
    { type: TabsetService }
];
TabPaneComponent.propDecorators = {
    active: [{ type: Input }],
    _tabPane: [{ type: HostBinding, args: ['class.tab-pane',] }],
    _tabActive: [{ type: HostBinding, args: ['class.active',] }],
    _tabShow: [{ type: HostBinding, args: ['class.show',] }],
    _tabFade: [{ type: HostBinding, args: ['class.fade',] }]
};

class TabListComponent {
    constructor() {
        this._navClass = true;
    }
    set variant(variant) {
        this._navTabsClass = variant !== 'pills';
        this._navPillsClass = variant === 'pills';
    }
    set vertical(vertical) {
        this._navFlexColumn = !!vertical;
        this._navH100 = !!vertical;
    }
    set fill(fill) {
        this._navFill = !!fill;
    }
    set justified(justified) {
        this._navJustified = !!justified;
    }
}
TabListComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-tablist',
                template: "<ng-content></ng-content>\n",
                styles: [""]
            },] }
];
TabListComponent.ctorParameters = () => [];
TabListComponent.propDecorators = {
    variant: [{ type: Input }],
    vertical: [{ type: Input }],
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    _navClass: [{ type: HostBinding, args: ['class.nav',] }],
    _navTabsClass: [{ type: HostBinding, args: ['class.nav-tabs',] }],
    _navPillsClass: [{ type: HostBinding, args: ['class.nav-pills',] }],
    _navFill: [{ type: HostBinding, args: ['class.nav-fill',] }],
    _navJustified: [{ type: HostBinding, args: ['class.nav-justified',] }],
    _navFlexColumn: [{ type: HostBinding, args: ['class.flex-column',] }],
    _navH100: [{ type: HostBinding, args: ['class.h-100',] }]
};

class TabsetComponent {
    constructor(hostElement, renderer, tabsetService) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.tabsetService = tabsetService;
        this._activeTab = 0;
        this._tabsArray = [];
        this.variant = 'tabs';
        this.fade = true;
        this.boxed = false;
        this.activeTabChange = new EventEmitter();
        this.host = this.hostElement.nativeElement;
    }
    set activeTab(index) {
        this._activeTab = index >= 0 ? index : this._activeTab;
    }
    get activeTab() {
        return this._activeTab;
    }
    ngOnInit() {
        if (typeof this.boxed === 'string') {
            this.renderer.addClass(this.host, `nav-tabs-boxed-${this.boxed}`);
        }
        this.activeTabSubscribe();
    }
    ngOnDestroy() {
        this.activeTabUnsubscribe();
    }
    ngAfterContentInit() {
        this.tabList.variant = this.variant;
        this.tabList.vertical = this.vertical;
        this.tabList.fill = this.fill;
        this.tabList.justified = this.justified;
        this._tabsArray = this.tabs.toArray();
        if (this.tabs.length) {
            this._selectedTab = this.tabs.length - 1 < this.activeTab ? this.tabs.first : this._tabsArray[this.activeTab];
        }
        this.tabs.forEach((item, index) => {
            item.indexKey = index;
        });
        this.panes.forEach((item, index) => {
            item.indexKey = index;
        });
        this.tabsetService.setActiveTab(this._selectedTab);
        this.setActiveTab(this._selectedTab);
    }
    ngAfterContentChecked() {
    }
    ngOnChanges(changes) {
    }
    setActiveTab(tab = this._selectedTab) {
        this.activeTab = tab.indexKey;
        if (!tab.disabled) {
            tab.active = true;
            this.tabsetService.setActiveTab(tab);
            this.activeTabChange.emit(this.activeTab);
        }
    }
    activeTabSubscribe() {
        this.activeTabSubscription = this.tabsetService.activeTab$.subscribe((activeTab) => {
        });
    }
    activeTabUnsubscribe() {
        this.activeTabSubscription.unsubscribe();
    }
}
TabsetComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-tabset',
                template: "<ng-content></ng-content>\n",
                providers: [TabsetService],
                styles: [""]
            },] }
];
TabsetComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: TabsetService }
];
TabsetComponent.propDecorators = {
    fill: [{ type: Input }],
    justified: [{ type: Input }],
    variant: [{ type: Input }],
    fade: [{ type: Input }],
    vertical: [{ type: Input }],
    activeTab: [{ type: Input }],
    boxed: [{ type: HostBinding, args: ['class.nav-tabs-boxed',] }, { type: Input }],
    activeTabChange: [{ type: Output }],
    tabList: [{ type: ContentChild, args: [TabListComponent, { static: true },] }],
    tabs: [{ type: ContentChildren, args: [TabComponent, { descendants: true },] }],
    panes: [{ type: ContentChildren, args: [TabPaneComponent, { descendants: true },] }]
};

class TabContentComponent {
    constructor() {
        this._hasPanes = false;
        this._tabContent = true;
    }
    set hasPanes(hasPanes) {
        this._hasPanes = hasPanes;
    }
    get hasPanes() {
        return this._hasPanes ? null : true;
    }
    ngOnInit() {
    }
    ngAfterContentChecked() {
        this.hasPanes = this.panes.length > 0;
    }
}
TabContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-tab-content',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:block}"]
            },] }
];
TabContentComponent.ctorParameters = () => [];
TabContentComponent.propDecorators = {
    _tabContent: [{ type: HostBinding, args: ['class.tab-content',] }],
    hasPanes: [{ type: HostBinding, args: ['attr.hidden',] }],
    panes: [{ type: ContentChildren, args: [TabPaneComponent,] }]
};

class TabsetModule {
}
TabsetModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TabsetComponent, TabListComponent, TabComponent, TabContentComponent, TabPaneComponent],
                exports: [
                    TabsetComponent,
                    TabListComponent,
                    TabComponent,
                    TabContentComponent,
                    TabPaneComponent,
                ],
                imports: [
                    CommonModule
                ],
                providers: [
                    TabsetService
                ]
            },] }
];

const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextMaskDirective),
    multi: true
};
class TextMaskDirective {
    constructor(platform, _renderer, _elementRef, _compositionMode) {
        this.platform = platform;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !platform.ANDROID;
        }
    }
    ngOnChanges(changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() { this._composing = true; }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
TextMaskDirective.decorators = [
    { type: Directive, args: [{
                host: {
                    '(input)': '_handleInput($event.target.value)',
                    '(blur)': 'onTouched()',
                    '(compositionstart)': '_compositionStart()',
                    '(compositionend)': '_compositionEnd($event.target.value)'
                },
                selector: '[textMask]',
                exportAs: 'textMask',
                providers: [MASKEDINPUT_VALUE_ACCESSOR]
            },] }
];
TextMaskDirective.ctorParameters = () => [
    { type: Platform },
    { type: Renderer2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
TextMaskDirective.propDecorators = {
    textMaskConfig: [{ type: Input, args: ['textMask',] }]
};

class TextMaskConfig {
}

class TextMaskModule {
    static forRoot() {
        return {
            ngModule: TextMaskModule
        };
    }
}
TextMaskModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    TextMaskDirective
                ],
                exports: [
                    TextMaskDirective
                ]
            },] }
];

class ToasterService {
    constructor() {
        this.toasterState = new BehaviorSubject({});
        this.toasterState$ = this.toasterState.asObservable();
    }
    setState(state) {
        this.toasterState.next(state);
    }
}
ToasterService.ɵprov = ɵɵdefineInjectable({ factory: function ToasterService_Factory() { return new ToasterService(); }, token: ToasterService, providedIn: "root" });
ToasterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ToasterService.ctorParameters = () => [];

class ToastComponent {
    constructor(hostElement, renderer, ref, toasterService) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ref = ref;
        this.toasterService = toasterService;
        this.autohide = true;
        this.delay = 5000;
        this.fade = true;
        this.shown = new EventEmitter();
        this.hidden = new EventEmitter();
        this.timer = new EventEmitter();
    }
    set clock(value) {
        this._clock = value;
        this.timer.emit(this._clock);
    }
    get clock() {
        return this._clock;
    }
    get animationDisabled() {
        return !this.fade;
    }
    get animateType() {
        return this.show ? 'show' : 'hide';
    }
    onMouseOver() {
        this.clearTimer();
        this.clearClock();
    }
    onMouseOut() {
        this.setTimer();
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            toast: true,
            [`toast-${this.color}`]: !!this.color,
        });
        return classes;
    }
    ngOnInit() {
        if (this.show) {
            this.toasterService.setState({ toast: this, show: this.show, position: this.position });
            this.setTimer();
        }
        this.stateToasterSubscribe(true);
    }
    ngOnDestroy() {
        this.clearTimer();
        this.clearClock();
        this.stateToasterSubscribe(false);
    }
    ngOnChanges(changes) {
        if (changes.color) {
            this.renderer.removeClass(this.hostElement.nativeElement, `toast-${changes.color.previousValue}`);
        }
        if (changes.show) {
            this.toasterService.setState({ toast: this, show: this.show, position: this.position });
        }
    }
    setTimer() {
        this.clearTimer();
        if (this.autohide) {
            this.timerId = this.delay > 0 ? setTimeout(() => this.onClose(), this.delay) : null;
            this.setClock();
        }
    }
    clearTimer() {
        clearTimeout(this.timerId);
        this.timerId = null;
    }
    onClose() {
        this.clearTimer();
        this.show = false;
        this.hidden.emit();
        this.toasterService.setState({ toast: this, show: this.show, position: this.position });
    }
    setClock() {
        this.clearClock();
        this.clock = 0;
        this.clockId = setInterval(() => {
            this.clock += 1;
        }, 1000);
        this.clockTimerId = setTimeout(() => {
            this.clearClock();
        }, this.delay);
    }
    clearClock() {
        clearTimeout(this.clockTimerId);
        clearInterval(this.clockId);
        this.clockId = null;
    }
    stateToasterSubscribe(subscribe = true) {
        if (subscribe) {
            const filtered = this.toasterService.toasterState$.pipe(filter(state => state.toast === this));
            this.stateToasterSubscription = filtered.subscribe((state) => {
                this.state = state.toast;
            });
        }
        else {
            this.stateToasterSubscription.unsubscribe();
        }
    }
}
ToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-toast',
                template: "<ng-content></ng-content>\n",
                animations: [
                    trigger('fadeInOut', [
                        state('show', style({ opacity: 1 })),
                        state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                        transition('show => *', [
                            animate('{{ time }} {{ easing }}', style({ opacity: 0 })),
                            animate('{{ time }} {{ easing }}', style({ height: 0, padding: 0, border: 0, margin: 0 })),
                        ], {
                            params: { time: '300ms', easing: 'ease-out' }
                        }),
                        transition('* => show', [
                            animate('{{ time }} {{ easing }}', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                        ], {
                            params: { time: '300ms', easing: 'ease-in' }
                        })
                    ])
                ],
                styles: [""]
            },] }
];
ToastComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: ToasterService }
];
ToastComponent.propDecorators = {
    autohide: [{ type: Input }],
    color: [{ type: Input }],
    delay: [{ type: Input }],
    fade: [{ type: Input }],
    show: [{ type: Input }],
    index: [{ type: Input }],
    shown: [{ type: Output }],
    hidden: [{ type: Output }],
    timer: [{ type: Output }],
    animationDisabled: [{ type: HostBinding, args: ['@.disabled',] }],
    animateType: [{ type: HostBinding, args: ['@fadeInOut',] }],
    onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
    onMouseOut: [{ type: HostListener, args: ['mouseout',] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ToastHeaderComponent {
    constructor(toast) {
        this.toast = toast;
        this.closeButton = true;
        this.toastHeaderClass = true;
    }
}
ToastHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-toast-header',
                template: "<ng-container>\r\n  <ng-content></ng-content>\r\n  <button *ngIf=\"closeButton\" class=\"close mfs-auto\" aria-label=\"close\" [style]=\"{outline: 0}\" [cToastClose]=\"toast\">\u00D7</button>\r\n</ng-container>\r\n",
                styles: [""]
            },] }
];
ToastHeaderComponent.ctorParameters = () => [
    { type: ToastComponent, decorators: [{ type: Optional }] }
];
ToastHeaderComponent.propDecorators = {
    closeButton: [{ type: Input }],
    toastHeaderClass: [{ type: HostBinding, args: ['class.toast-header',] }]
};

class ToastBodyComponent {
    constructor(toast) {
        this.toast = toast;
        this.toastBodyClass = true;
    }
    ngOnInit() {
    }
}
ToastBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-toast-body',
                template: "<ng-content></ng-content>\n",
                styles: [":host{display:block}"]
            },] }
];
ToastBodyComponent.ctorParameters = () => [
    { type: ToastComponent, decorators: [{ type: Optional }] }
];
ToastBodyComponent.propDecorators = {
    toastBodyClass: [{ type: HostBinding, args: ['class.toast-body',] }]
};

class ToasterHostDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
ToasterHostDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cToasterHost]',
                exportAs: 'cToasterHost',
            },] }
];
ToasterHostDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

var ToasterPosition;
(function (ToasterPosition) {
    ToasterPosition["Static"] = "static";
    ToasterPosition["TopCenter"] = "top-center";
    ToasterPosition["TopFull"] = "top-full";
    ToasterPosition["TopLeft"] = "top-left";
    ToasterPosition["TopRight"] = "top-right";
    ToasterPosition["BottomCenter"] = "bottom-center";
    ToasterPosition["BottomFull"] = "bottom-full";
    ToasterPosition["BottomLeft"] = "bottom-left";
    ToasterPosition["BottomRight"] = "bottom-right";
})(ToasterPosition || (ToasterPosition = {}));
class ToasterComponent {
    constructor(componentFactoryResolver, hostElement, renderer, toasterService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.toasterService = toasterService;
        this.positions = Object.values(ToasterPosition);
        this.toastsDynamic = [];
        this.position = ToasterPosition.TopRight;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            toaster: true,
            [`toaster-${this.position}`]: this.position !== 'static' && !!this.position
        });
        return classes;
    }
    ngOnInit() {
        this.stateToasterSubscribe(true);
    }
    ngOnDestroy() {
        this.stateToasterSubscribe(false);
    }
    ngAfterContentChecked() {
        this.toasts = this.contentToasts;
    }
    stateToasterSubscribe(subscribe = true) {
        if (subscribe) {
            this.stateToasterSubscription = this.toasterService.toasterState$.subscribe((state) => {
                var _a;
                if (state.show === false) {
                    this.removeToast(state);
                }
                if (state.show === true && ((_a = state.toast) === null || _a === void 0 ? void 0 : _a.dynamic) === undefined) { }
            });
        }
        else {
            this.stateToasterSubscription.unsubscribe();
        }
    }
    addToast(toast, options) {
        const factory = this.componentFactoryResolver.resolveComponentFactory(toast);
        const componentRef = this.toasterHost.viewContainerRef.createComponent(factory);
        this.toastsDynamic.push(componentRef);
        const index = this.toastsDynamic.indexOf(componentRef);
        for (const [key, value] of Object.entries(options)) {
            componentRef.instance[key] = value;
        }
        componentRef.instance['position'] = this.position;
        componentRef.instance['dynamic'] = true;
        componentRef.instance['index'] = index;
        componentRef.instance['show'] = true;
        componentRef.changeDetectorRef.detectChanges();
        return componentRef;
    }
    removeToast(state) {
        var _a, _b;
        (_a = this.toastsDynamic) === null || _a === void 0 ? void 0 : _a.forEach(item => {
            if (state.toast.dynamic && (item.instance === state.toast)) {
                item.destroy();
            }
        });
        (_b = this.toasts) === null || _b === void 0 ? void 0 : _b.forEach(item => {
            if (item.element.nativeElement === state.toast.hostElement.nativeElement) {
                state.toast.show = false;
                setTimeout(() => {
                    item.element.nativeElement.remove();
                }, 300);
            }
        });
    }
}
ToasterComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-toaster',
                template: "<ng-template cToasterHost></ng-template>\n<ng-content cToasterHost></ng-content>\n",
                styles: [""]
            },] }
];
ToasterComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ToasterService }
];
ToasterComponent.propDecorators = {
    position: [{ type: Input }],
    toasterHost: [{ type: ViewChild, args: [ToasterHostDirective, { static: true },] }],
    contentToasts: [{ type: ContentChildren, args: [ToastComponent, { read: ViewContainerRef },] }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class ToastCloseDirective {
    constructor(toasterService) {
        this.toasterService = toasterService;
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.toasterService.setState({ show: false, toast: this.toast });
    }
}
ToastCloseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cToastClose]',
                exportAs: 'cToastClose',
            },] }
];
ToastCloseDirective.ctorParameters = () => [
    { type: ToasterService }
];
ToastCloseDirective.propDecorators = {
    toast: [{ type: Input, args: ['cToastClose',] }],
    toggleOpen: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class ToastModule {
}
ToastModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective],
                imports: [
                    CommonModule
                ],
                providers: [ToasterService],
                exports: [ToastComponent, ToastHeaderComponent, ToastBodyComponent, ToasterComponent, ToasterHostDirective, ToastCloseDirective]
            },] }
];

class TogglerComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.displayFlex = true;
        this.hasContent = true;
    }
    get buttonClass() {
        if (this.inHeader) {
            return 'c-header-toggler';
        }
        else if (this.inNavbar) {
            return 'navbar-toggler';
        }
    }
    get iconClass() {
        if (this.inHeader) {
            return 'c-header-toggler-icon';
        }
        else if (this.inNavbar) {
            return 'navbar-toggler-icon';
        }
    }
    ngAfterViewInit() {
        this.hasContent = this.content.nativeElement.childNodes.length;
        this.changeDetector.detectChanges();
    }
}
TogglerComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-toggler',
                template: "<div #content *ngIf = \"hasContent; else default\" class=\"d-flex\"><ng-content></ng-content></div>\n<ng-template #default>\n  <button [class]=\"buttonClass\" type=\"button\">\n    <span [class]=\"iconClass\"></span>\n  </button>\n</ng-template>\n",
                styles: [""]
            },] }
];
TogglerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
TogglerComponent.propDecorators = {
    inHeader: [{ type: Input }],
    inNavbar: [{ type: Input }],
    displayFlex: [{ type: HostBinding, args: ['class.d-flex',] }],
    content: [{ type: ViewChild, args: ['content',] }]
};

class TogglerModule {
}
TogglerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TogglerComponent],
                exports: [
                    TogglerComponent
                ],
                imports: [
                    CommonModule
                ]
            },] }
];

class WidgetSimpleComponent {
    constructor() { }
    ngOnInit() { }
}
WidgetSimpleComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-simple',
                template: "<div class=\"card\">\n  <div class=\"card-body text-center\">\n    <div *ngIf=\"!!header\" class=\"text-muted small text-uppercase font-weight-bold\">\n      {{header}}\n    </div>\n    <div *ngIf=\"!!text\" class=\"h2 py-3\">\n      {{text}}\n    </div>\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                styles: [""]
            },] }
];
WidgetSimpleComponent.ctorParameters = () => [];
WidgetSimpleComponent.propDecorators = {
    header: [{ type: Input }],
    text: [{ type: Input }]
};

class WidgetBrandComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
        });
        return classes;
    }
    ngOnInit() {
    }
    get headerClasses() {
        const classes = classNames({
            'card-header': true,
            'content-center': true,
            'text-white': true,
            'p-0': true,
            [`bg-${this.color}`]: !!this.color,
        }, this.addHeaderClasses);
        return classes;
    }
}
WidgetBrandComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-brand',
                template: "<ng-container>\n  <div [class]=\"headerClasses\">\n    <ng-content></ng-content>\n  </div>\n  <!--todo: <ng-content select=\"[slot=body]\"></ng-content>-->\n  <div class=\"card-body row text-center\">\n    <div class=\"col\">\n      <div *ngIf=\"!!rightHeader\" class=\"text-value-lg\">{{rightHeader}}</div>\n      <div *ngIf=\"!!rightFooter\" class=\"text-uppercase text-muted small\">{{rightFooter}}</div>\n    </div>\n    <div class=\"c-vr\"></div>\n    <div class=\"col\">\n      <div *ngIf=\"!!leftHeader\" class=\"text-value-lg\">{{leftHeader}}</div>\n      <div *ngIf=\"!!leftFooter\" class=\"text-uppercase text-muted small\">{{leftFooter}}</div>\n    </div>\n  </div>\n</ng-container>\n",
                styles: [""]
            },] }
];
WidgetBrandComponent.ctorParameters = () => [];
WidgetBrandComponent.propDecorators = {
    color: [{ type: Input }],
    rightHeader: [{ type: Input }],
    leftHeader: [{ type: Input }],
    rightFooter: [{ type: Input }],
    leftFooter: [{ type: Input }],
    addHeaderClasses: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WidgetIconComponent {
    constructor() {
        this.iconPadding = true;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
        });
        return classes;
    }
    ngOnInit() {
    }
    get cardBodyClasses() {
        const classes = classNames({
            'card-body': true,
            'd-flex': true,
            'align-items-center': true,
            [`p-${this.iconPadding ? '3' : '0'}`]: true,
        });
        return classes;
    }
    get bodySlotClasses() {
        const classes = classNames({
            'mfe-3': true,
            'text-white': true,
            [`bg-${this.color}`]: this.color,
            [`p-${this.iconPadding ? '3' : '4'}`]: true,
        });
        return classes;
    }
    get headerClasses() {
        const classes = classNames({
            'text-value': true,
            [`text-${this.color}`]: this.color
        });
        return classes;
    }
}
WidgetIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-icon',
                template: "<ng-container>\n  <div [class]=\"cardBodyClasses\">\n    <div [class]=\"bodySlotClasses\">\n      <ng-content></ng-content>\n    </div>\n    <div>\n      <div *ngIf=\"!!header\" [class]=\"headerClasses\">\n        {{header}}\n      </div>\n      <div *ngIf=\"!!text\" class=\"text-muted text-uppercase font-weight-bold small\">\n        {{text}}\n      </div>\n    </div>\n  </div>\n  <ng-content select=\"[slot=footer]\"></ng-content>\n</ng-container>\n",
                styles: [""]
            },] }
];
WidgetIconComponent.ctorParameters = () => [];
WidgetIconComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    iconPadding: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WidgetDropdownComponent {
    constructor() { }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': true,
            [`bg-${this.color}`]: !!this.color,
        });
        return classes;
    }
    ngOnInit() { }
}
WidgetDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-dropdown',
                template: "<ng-container>\n  <div class=\"card-body pb-0 d-flex justify-content-between align-items-start\">\n    <div>\n      <div v-if=\"header\" class=\"text-value-lg\">{{header}}</div>\n      <div v-if=\"text\">{{text}}</div>\n    </div>\n    <ng-content></ng-content>\n<!--    <ng-content select=\"[dropdown]\" ></ng-content>-->\n  </div>\n  <ng-content select=\"[slot=footer]\"></ng-content>\n</ng-container>\n",
                styles: [""]
            },] }
];
WidgetDropdownComponent.ctorParameters = () => [];
WidgetDropdownComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WidgetProgressComponent {
    constructor() {
        this.value = 25;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': this.inverse,
            [`bg-${this.color}`]: this.inverse && !!this.color
        });
        return classes;
    }
    ngOnInit() {
    }
}
WidgetProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-progress',
                template: "<div class=\"card-body\">\n  <div v-if=\"header\" class=\"h4 m-0\">{{header}}</div>\n  <div v-if=\"text\">{{text}}</div>\n  <c-progress size=\"xs\" [class]=\"{'my-3': true, 'mb-0': true, 'progress-white': inverse }\">\n    <c-progress-bar\n      [color]=\"!inverse ? color : ''\"\n      [value]=\"value\"\n    ></c-progress-bar>\n  </c-progress>\n  <small *ngIf=\"!!footer\" class=\"text-muted\">\n    {{footer}}\n  </small>\n</div>\n",
                styles: [""]
            },] }
];
WidgetProgressComponent.ctorParameters = () => [];
WidgetProgressComponent.propDecorators = {
    color: [{ type: Input }],
    footer: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    inverse: [{ type: Input }],
    value: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WidgetProgressIconComponent {
    constructor() {
        this.value = 25;
    }
    get getClasses() {
        return this.hostClasses;
    }
    get hostClasses() {
        const classes = classNames({
            card: true,
            'text-white': this.inverse,
            [`bg-${this.color}`]: this.inverse && !!this.color
        });
        return classes;
    }
    ngOnInit() {
    }
}
WidgetProgressIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'c-widget-progress-icon',
                template: "<div class=\"card-body\">\n  <div class=\"h1 text-muted text-right mb-4\">\n    <ng-content></ng-content>\n  </div>\n  <div *ngIf=\"!!header\" class=\"h4 mb-0\">{{header}}</div>\n  <small *ngIf=\"!!text\" class=\"text-muted text-uppercase font-weight-bold\">\n    {{text}}\n  </small>\n<!-- todo  <ng-content slot=\"progress\"></ng-content>-->\n    <c-progress size=\"xs\" [class]=\"{'my-3': true, 'mb-0': true, 'progress-white': inverse }\">\n      <c-progress-bar\n        [color]=\"!inverse ? color : ''\"\n        [value]=\"value\"\n        >\n      </c-progress-bar>\n    </c-progress>\n</div>\n",
                styles: [""]
            },] }
];
WidgetProgressIconComponent.ctorParameters = () => [];
WidgetProgressIconComponent.propDecorators = {
    color: [{ type: Input }],
    header: [{ type: Input }],
    text: [{ type: Input }],
    inverse: [{ type: Input }],
    value: [{ type: Input }],
    getClasses: [{ type: HostBinding, args: ['class',] }]
};

class WidgetModule {
}
WidgetModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    WidgetSimpleComponent,
                    WidgetBrandComponent,
                    WidgetIconComponent,
                    WidgetDropdownComponent,
                    WidgetProgressComponent,
                    WidgetProgressIconComponent
                ],
                exports: [
                    WidgetSimpleComponent,
                    WidgetBrandComponent,
                    WidgetIconComponent,
                    WidgetDropdownComponent,
                    WidgetProgressComponent,
                    WidgetProgressIconComponent,
                    ProgressModule
                ],
                imports: [
                    CommonModule,
                    ProgressModule
                ]
            },] }
];

export { AccordionModule, AlertModule, BadgeModule, BodyComponent, BreadcrumbModule, ButtonModule, CalloutModule, CardModule, CarouselModule, ChartModule, ClassToggleService, CollapseDirective, CollapseModule, DropdownModule, EmbedModule, FooterComponent, FormModule, GridModule, HeaderBrandComponent, HeaderComponent, ImgModule, LayoutModule, ListGroupModule, MediaModule, ModalModule, NavModule, NavbarModule, ProgressModule, SharedModule, SidebarBackdropComponent, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarFormComponent, SidebarHeaderComponent, SidebarMinimizeDirective, SidebarMinimizerComponent, SidebarModule, SidebarNavBadgePipe, SidebarNavComponent, SidebarNavDividerComponent, SidebarNavDropdownComponent, SidebarNavDropdownToggleDirective, SidebarNavIconPipe, SidebarNavItemClassPipe, SidebarNavItemsComponent, SidebarNavLabelComponent, SidebarNavLinkComponent, SidebarNavLinkContentComponent, SidebarNavLinkPipe, SidebarNavService, SidebarNavTitleComponent, SidebarService, SidebarToggleDirective, SpinkitModule, SpinnerModule, SubheaderComponent, SwitchModule, TabsetModule, TextMaskConfig, TextMaskDirective, TextMaskModule, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPosition, ToasterService, TogglerModule, WidgetModule, WrapperComponent, AccordionComponent as ɵa, AccordionGroupComponent as ɵb, CarouselComponent as ɵba, CarouselService as ɵbb, CarouselState as ɵbc, CarouselConfig as ɵbd, CarouselCaptionComponent as ɵbe, CarouselControlComponent as ɵbf, CarouselIndicatorsComponent as ɵbg, CarouselInnerComponent as ɵbh, toLeft as ɵbi, toRight as ɵbj, slideAnimation as ɵbk, CarouselItemComponent as ɵbl, DropdownDirective as ɵbm, DropdownService as ɵbn, DropdownState as ɵbo, OutClickService as ɵbp, DropdownToggleDirective as ɵbq, DropdownMenuDirective as ɵbr, DropdownHeaderDirective as ɵbs, DropdownDividerDirective as ɵbt, DropdownItemDirective as ɵbu, DropdownDividerComponent as ɵbv, EmbedComponent as ɵbw, EmbedItemDirective as ɵbx, FormDirective as ɵby, FormCheckComponent as ɵbz, CardModule as ɵc, FormFeedbackComponent as ɵca, FormGroupComponent as ɵcb, FormTextComponent as ɵcc, InputDirective as ɵcd, InputGroupComponent as ɵce, InputGroupTextComponent as ɵcf, InputGroupAddonComponent as ɵcg, InputGroupPrependComponent as ɵch, InputGroupAppendComponent as ɵci, TextareaDirective as ɵcj, SelectDirective as ɵck, LabelDirective as ɵcl, ContainerComponent as ɵcm, RowComponent as ɵcn, RowDirective as ɵco, ColComponent as ɵcp, ColDirective as ɵcq, ImgDirective as ɵcr, ListGroupDirective as ɵcs, ListGroupItemDirective as ɵct, MediaComponent as ɵcu, MediaDirective as ɵcv, MediaBodyComponent as ɵcw, ModalComponent as ɵcx, NavComponent as ɵcy, NavItemComponent as ɵcz, CollapseDirective as ɵd, NavLinkDirective as ɵda, NavbarComponent as ɵdb, NavbarBrandComponent as ɵdc, NavbarNavComponent as ɵdd, NavbarTextComponent as ɵde, ProgressComponent as ɵdf, ProgressBarComponent as ɵdg, OutClickDirective as ɵdh, OutClickService as ɵdi, HtmlAttributesDirective as ɵdj, SpinkitComponent as ɵdk, SpinnerComponent as ɵdl, SwitchComponent as ɵdm, TabsetComponent as ɵdn, TabsetService as ɵdo, TabListComponent as ɵdp, TabComponent as ɵdq, TabPaneComponent as ɵdr, TabContentComponent as ɵds, ToastComponent as ɵdt, ToasterService as ɵdu, ToastHeaderComponent as ɵdv, ToastBodyComponent as ɵdw, ToasterComponent as ɵdx, ToasterHostDirective as ɵdy, ToastCloseDirective as ɵdz, AlertComponent as ɵe, TogglerComponent as ɵea, WidgetSimpleComponent as ɵeb, WidgetBrandComponent as ɵec, WidgetIconComponent as ɵed, WidgetDropdownComponent as ɵee, WidgetProgressComponent as ɵef, WidgetProgressIconComponent as ɵeg, BadgeComponent as ɵf, SharedModule as ɵg, BreadcrumbComponent as ɵh, BreadcrumbDirective as ɵi, BreadcrumbService as ɵj, ButtonComponent as ɵk, ButtonDirective as ɵl, ButtonGroupComponent as ɵm, ButtonToolbarComponent as ɵn, RADIO_CONTROL_VALUE_ACCESSOR$1 as ɵo, ButtonRadioDirective as ɵp, RADIO_CONTROL_VALUE_ACCESSOR as ɵq, ButtonRadioGroupDirective as ɵr, CalloutComponent as ɵs, CardComponent as ɵt, CardBodyComponent as ɵu, CardFooterComponent as ɵv, CardGroupComponent as ɵw, CardHeaderComponent as ɵx, CardHeaderActionsComponent as ɵy, NoZoneBaseChartDirective as ɵz };
//# sourceMappingURL=coreui-angular.js.map
